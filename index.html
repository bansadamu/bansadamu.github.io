<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>前端学习笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="前端学习笔记">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="前端学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="banji">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="前端学习笔记" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">前端学习笔记</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-js-4" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/27/js-4/" class="article-date">
  <time class="dt-published" datetime="2021-07-27T13:35:59.000Z" itemprop="datePublished">2021-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/27/js-4/">book</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf ./js-4.pdf %&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/27/js-4/" data-id="ckrm3yfs50000bsw20yn9gbiw" data-title="book" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-2021.07.19" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/19/2021.07.19/" class="article-date">
  <time class="dt-published" datetime="2021-07-19T13:16:44.000Z" itemprop="datePublished">2021-07-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/19/2021.07.19/">划水计划</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li>学会写markdown文档</li>
<li>巩固JS基础，手撸代码</li>
<li>做一个中台</li>
<li>hexo博客主题</li>
<li>拉大神代码做个个人网站</li>
<li>封装组件</li>
<li>实现水印HOC</li>
</ol>
<p>如何使用settimeout实现setinterval，为什么不要用setinterval</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/19/2021.07.19/" data-id="ckrhwctpa0001dww2dohu84q9" data-title="划水计划" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-面试题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/16/%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2021-07-16T11:01:31.000Z" itemprop="datePublished">2021-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/16/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="变量提升-预编译造成的。"><a href="#变量提升-预编译造成的。" class="headerlink" title="变量提升 -预编译造成的。"></a>变量提升 -预编译造成的。</h1><ul>
<li><ol>
<li>当浏览器引擎解析 js 代码时，将 js 中的所有一开始就是 var 声明的和 function 声明的都提升到全局。此时又叫全局作用域</li>
</ol>
</li>
<li><ol start="2">
<li>当执行函数时，总是先从函数内部找寻局部变量,如果内部找不到（函数的局部作用域没有），则会向上一级继续查找，一直找到最外面。在函数体内，局部变量的优先级高于同名的全局变量-作用域链。</li>
</ol>
</li>
<li><ol start="3">
<li>普通函数如何地方进行调用：预编译造成的</li>
</ol>
</li>
<li>预编译： 1.先找 var 和 function 关键字，如果找到 var 关键字，提前赋值 undefined 给变量名称.如果找到 function，提前将整个函数赋值给函数名称。 2.如果变量名和函数名重名了，函数名优先(函数名会覆盖变量名，变量名不存在了); 3.函数的参数类似于变量，函数内部同样做预编译，支持预编译。<br>4.if 语句和 for 语句里面的变量和函数做预解析提前赋值 undefined,函数声明不会跳过。 - 少见(尽量不要在 if 语句和 for 语句里面使用函数)</li>
</ul>
<h1 id="内存泄漏-哪些场景"><a href="#内存泄漏-哪些场景" class="headerlink" title="内存泄漏 - 哪些场景"></a>内存泄漏 - 哪些场景</h1><p>1.闭包会产生内层泄漏，变量常驻内存 1.意外的全局变量 2.计时器或回调函数没有清除关掉 3.脱离 DOM 的引用</p>
<p>第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。<br>第二种情况是我们设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。<br>第三种情况是我们获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。<br>第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</p>
<h1 id="判断一个对象是-Array"><a href="#判断一个对象是-Array" class="headerlink" title="判断一个对象是 Array"></a>判断一个对象是 Array</h1><ul>
<li>Array.isArray() 用于确定传递的值是否是一个 Array。如果对象是 Array，则为 true; 否则为 false.</li>
<li>Object. prototype.toString.call(obj)===[ object Array]</li>
</ul>
<h1 id="判断一个对象为空"><a href="#判断一个对象为空" class="headerlink" title="判断一个对象为空"></a>判断一个对象为空</h1><ul>
<li>方法一：将对象转换成字符串，再判断是否等于“{}”<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringfy(obj) === <span class="string">&quot;&#123;&#125;&quot;</span>);</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
<li>ES : Object.keys()方法，返回对象的属性名组成的一个数组，若长度为 0，则为空对象（ES6 的写法）<br>console.log(Object.keys(obj).length==0);//返回 true</li>
<li>for in 循环<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//若不为空，可遍历，返回false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="ES5-和-ES6-继承的-区别"><a href="#ES5-和-ES6-继承的-区别" class="headerlink" title="ES5 和 ES6 继承的 区别"></a>ES5 和 ES6 继承的 区别</h1><p>1.ES5 先创建子类，在实例化父类并添加到子类 this 中<br>　　 2.ES6 先创建父类，在实例化子集中通过调用 super 方法访问父级后，在通过修改 this 实现继承<br> 在 ES5 的继承中，先创建子类的实例对象 this，然后再将父类的方法添加到 this 上（ Parent.apply(this) ）。<br>ES6 采用的是先创建父类的实例 this（故要先调用 super( )方法），完后再用子类的构造函数修改 this<br>ES6 中的继承是基于 class 类之间继承的。通过关键词 extends 实现。 通过 super 实例化调用父类</p>
<h1 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call apply bind"></a>call apply bind</h1><pre><code>第一个参数都是this要指向的对象
call第二个参数开始是函数的本身
apply第二个参数是数组
bind第二个参数是函数本身的参数
</code></pre>
<h1 id="px，em，rem，pt-的区别"><a href="#px，em，rem，pt-的区别" class="headerlink" title="px，em，rem，pt 的区别"></a>px，em，rem，pt 的区别</h1><p>1、px 实际上就是像素，用 px 设置字体大小时，比较稳定和精确<br>2、em 就是根据基准来缩放字体的大小<br>3、rem 是相对于根元素字体大小来显示的<br>4、pt 的大小等于 1 英寸的 1/72 浏览器的兼容性除了 IE6 - IE8，其他的浏览器都支持 em 和 rem，px 所有浏览器都支持<br>5、小程序 RPX #　防抖和节流<br>（1）防抖：就是将一段时间内连续的多次触发转化为一次触发。input 搜索框</p>
<p>（2）节流：减少一段时间内触发的频率　 onrize onscroll</p>
<p>区别：两者区别在于函数节流是固定时间做某一件事，比如每隔 1 秒发一次请求。而函数防抖是在频繁触发后，只执行一次（两者的前提都是频繁触发）</p>
<p>场景：</p>
<p>（1）节流：一般是 onrize，onscroll 等这些频繁触发的函数，比如你想获取滚动条的位置，然后执行下一步动作；鼠标不断点击触发，mousedown(单位时间内只触发一次)…<br>比如你想获取滚动条的位置，然后执行下一步动作。如果监听后执行的是 Dom 操作，这样的频繁触发执行，可能会影响到浏览器性能，甚至会将浏览器卡崩。</p>
<p>我们可以规定他多少秒执行一次，这种方法叫函数节流<br>const throttle=(fn, delay) =&gt; {<br>//记录上一次函数触发的时间<br>let lastTime = 0;<br>return () =&gt; {<br>//记录当前函数触发的时间<br>let nowTime = Date.now();<br>if (nowTime - lastTime &gt; delay) {<br>fn();<br>//同步时间<br>lastTime = nowTime;<br>}<br>}<br>};<br>（2）防抖：频繁操作点赞和取消点赞，因此需要获取最后一次操作结果并发送给服务器；search 搜索联想，用户在不断输入值时…</p>
<p>input 框不会有事件穿透发生，</p>
<h1 id="JSONP-跨域请求的原理"><a href="#JSONP-跨域请求的原理" class="headerlink" title="JSONP 跨域请求的原理"></a>JSONP 跨域请求的原理</h1><p>input 搜索框 oninput 添加事件 追加 script 属性</p>
<ul>
<li>ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。</li>
<li>前端 script 添加一个跨域的 url，后端也会对这个 url 做出一些设置，实际的请求是后端执行的，后端再把访问该 url 返回的数据拼接返回到 callback 函数中，前端通过 callback 获取数据</li>
</ul>
<h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><ul>
<li><p>同源策略即：同一协议，同一域名，同一端口号。当其中一个不满足时，我们的请求即会发生跨域问题。</p>
</li>
<li><p>弊端只支持 get 方式–传递函数名 –弊端</p>
</li>
<li><p>-浏览器自身安全功能</p>
</li>
</ul>
<h1 id="setTimeout-设置为-0"><a href="#setTimeout-设置为-0" class="headerlink" title="setTimeout 设置为 0"></a>setTimeout 设置为 0</h1><p>为啥不能立马执行 宏任务</p>
<p>setTimeout(fn, 0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，当前代码执行完（执行栈清空）以后，尽可能的早执行。它在“任务队列”的尾部添加一个事件，因此要等到同步任务和“任务队列”现有的事件都处理完，才会得到执行。</p>
<p>HTML5 标准规定了 setTimeout()的第二个参数的最小值不得小于 4 毫秒，如果低于这个值，则默认是 4 毫秒。在此之前。老版本的浏览器都将最短时间设为 10 毫秒。另外，对于那些 DOM 的变动（尤其是涉及页面重新渲染的部分），通常是间隔 16 毫秒执行。这时使用 requestAnimationFrame()的效果要好于 setTimeout();</p>
<p>注意：setTimeout()只是将事件插入了“任务队列”，必须等当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码消耗时间很长，也有可能要等很久，所以并没办法保证回调函数一定会在 setTimeout()指定的时间执行。所以，setTimeout()的第二个参数表示的是最少时间，并非是确切时间。</p>
<h1 id="事件轮询"><a href="#事件轮询" class="headerlink" title="事件轮询"></a>事件轮询</h1><p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。<br>（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。<br>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>（4）主线程不断重复上面的第三步。</p>
<p>宏任务和微任务的执行顺序<br>一次事件循环中，先执行宏任务队列里的一个任务，再把微任务队列里的所有任务执行完毕，再去宏任务队列取下一个宏任务执行。</p>
<h1 id="宏任务-微任务"><a href="#宏任务-微任务" class="headerlink" title="宏任务 微任务"></a>宏任务 微任务</h1><p>概念</p>
<p>先执行微任务，微任务实在 DOM 渲染前执行，这是时候 DOM 已经有结构了，但是没有渲染，再 DOM 渲染，再执行宏任务，是在 DOM 渲染之后执行的 1.宏任务：当前调用栈中执行的代码成为宏任务。（主代码快，定时器等等）浏览器 api。 2.微任务：当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务,可以理解为回调事件。 ES6 语法规定的（promise.then，proness.nextTick 等等）。 3.宏任务中的事件放在 callback queue 中，由事件触发线程维护；微任务的事件放在微任务队列中，由 js 引擎线程维护。 4.清空队列的时候，然后再 dom 渲染</p>
<p>运行机制</p>
<ol>
<li>在执行栈中执行一个宏任务。</li>
<li>执行过程中遇到微任务，将微任务添加到微任务队列中。</li>
<li>当前宏任务执行完毕，立即执行微任务队列中的任务。</li>
<li>当前微任务队列中的任务执行完毕，检查渲染，GUI 线程接管渲染。</li>
<li>渲染完毕后，js 线程接管，开启下一次事件循环，执行下一次宏任务（事件队列中取）。</li>
</ol>
<p>微任务：process.nextTick、MutationObserver、Promise.then catch finally DOM 渲染前触发<br>宏任务：I/O、setTimeout、setInterval、setImmediate、requestAnimationFrame DOM 渲染后触发</p>
<h1 id="setTimeout-延时-3-秒"><a href="#setTimeout-延时-3-秒" class="headerlink" title="setTimeout 延时 3 秒"></a>setTimeout 延时 3 秒</h1><p>实际却 5，6 秒才执行函数</p>
<p>答：setTimeout 并不能保证执行的时间，是否及时执行取决于 JavaScript 线程是拥挤还是空闲。<br>浏览器的 JS 引擎遇到 setTimeout，拿走之后不会立即放入异步队列，同步任务执行之后，timer 模块会到设置时间之后放到异步队列中。js 引擎发现同步队列中没有要执行的东西了，即运行栈空了就从异步队列中读取，然后放到运行栈中执行。所以 setTimeout 可能会多了等待线程的时间。<br>这时 setTimeout 函数体就变成了运行栈中的执行任务，运行栈空了，再监听异步队列中有没有要执行的任务，如果有就继续执行，如此循环，就叫 Event Loop。</p>
<h1 id="箭头函数与普通函数的区别"><a href="#箭头函数与普通函数的区别" class="headerlink" title="箭头函数与普通函数的区别"></a>箭头函数与普通函数的区别</h1><p>箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种只包含一个表达式，连{ … }和 return 都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ … }和 return。</p>
<ul>
<li><p>箭头函数是匿名函数，不能作为构造函数，不能使用 new</p>
</li>
<li><p>箭头函数不能使用 arguments 有作用域</p>
</li>
<li><p>箭头函数会把 arguments 当成一个普通的变量，顺着作用域链由内而外地查询（词法作用域）<br>arguments 可以用…rest 取代(es6 新特性,推荐替换 arguments)</p>
</li>
<li><p>箭头函数没有原型属性 -</p>
</li>
<li><p>箭头函数不绑定 this，会捕获其所在的上下文的 this 值，作为自己的 this 值，自身外的第一个 this（由于自身没有声明 this，所以会去作用域链上找 this）</p>
</li>
</ul>
<h1 id="闭包是什么-有什么特性？"><a href="#闭包是什么-有什么特性？" class="headerlink" title="闭包是什么 有什么特性？"></a>闭包是什么 有什么特性？</h1><p>闭包的特性：<br>函数内部嵌套函数，能够读取其他函数内部变量的函数。<br>①.封闭性：外界无法访问闭包内部的数据，如果在闭包内声明变量，外界是无法访问的，除非闭包主动向外界提供访问接口；<br>②.持久性：一般的函数，调用完毕之后，系统自动注销函数，而对于闭包来说，在外部函数被调用之后，闭包结构依然保存在<br>系统中，闭包中的数据依然存在，从而实现对数据的持久使用。<br>优点：<br>①  减少全局变量。<br>②  减少传递函数的参数量<br>③  封装；<br>缺点：<br>  使用闭包会占有内存资源，过多的使用闭包会导致内存溢出等.</p>
<h1 id="事件捕获和冒泡"><a href="#事件捕获和冒泡" class="headerlink" title="事件捕获和冒泡"></a>事件捕获和冒泡</h1><p>事件流：页面中接受事件的顺序 IE-微软-冒泡 -网景-捕获 对立</p>
<ol>
<li><p>IE 的事件流叫冒泡，事件流就是页面中接受事件的顺序，从最具体的到最不具体的节点， 取消冒泡 ev.stopPropagation,</p>
<p>ev.canclBubble = true</p>
</li>
<li><p>注意 事件冒泡的类型一定要相同</p>
<p>冒泡和捕获只能存在一种</p>
</li>
<li><p>捕获就是最不具体的到最具体的。从大到小</p>
<p>在 DOM 二级事件中 addEventListen(事件类型，事件处理函数，是否捕获) 一个元素可以绑定多个同类型的事件处理函数，按顺序执行<br>先有捕获，再有冒泡 true 是捕获，false 是冒泡<br>true 捕获是从大到小 冒泡是从小到大 中间的目标<br>IE 和 标准浏览器的事件绑定的区别</p>
</li>
</ol>
<p>1 事件类型不一样<br>2 参数个数不一样<br>3 执行数序不一样 标准正序<br>4this 指向不一样 标准浏览器 this 执行当前操作的对象，非标准版指向 window</p>
<h1 id="Generators-生成器函数"><a href="#Generators-生成器函数" class="headerlink" title="Generators 生成器函数"></a>Generators 生成器函数</h1><pre><code> -解决异步代码顺序问题
- Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。
- Generator 函数是一个状态机，封装了多个内部状态。
   但是有两个特征。
    一是，function关键字与函数名之间有一个星号；
    二是，函数体内部使用yield（产出）表达式，定义不同的内部状态.
- gen:Generator 函数返回遍历器对象  有一个next()方法
就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束
- 没有async await ES7  简洁 实际上是同步的，来去解决异步代码问题
   - async 生命这个函数是一个异步的， await等待这个执行结果完成
</code></pre>
<h1 id="XSS-和-CSRF"><a href="#XSS-和-CSRF" class="headerlink" title="XSS 和 CSRF"></a>XSS 和 CSRF</h1><p>1、CSRF（Cross-site request forgery）：跨站请求伪造。<br>（1）登录受信任网站 A，并在本地生成 Cookie。<br>（如果用户没有登录网站 A，那么网站 B 在诱导的时候，请求网站 A 的 api 接口时，会提示你登录）<br>（2）在不登出 A 的情况下，访问危险网站 B（其实是利用了网站 A 的漏洞）</p>
<p>CSRF 如何防御<br>方法一: Token 验证：（用的最多）<br>（1）服务器发送给客户端一个 token；<br>（2）客户端提交的表单中带着这个 token。<br>（3）如果这个 token 不合法，那么服务器拒绝这个请求。<br>方法二: 隐藏令牌：<br>把 token 隐藏在 http 的 head 头中。<br>方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。<br>方法三: Referer(锐服尔) 验证：<br>Referer 指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截。<br>2、XSS（Cross Site Scripting）：跨域脚本攻击。<br>XSS 攻击的核心原理是：<br>不需要你做任何的登录认证，它会通过合法的操作（比如在 url 中输入、在评论框中输入），<br>向你的页面注入脚本（可能是 js、hmtl 代码块等）。<br>最后导致的结果可能是：<br>盗用 Cookie 破坏页面的正常结构，插入广告等恶意内容 D-doss 攻击<br>XSS 的攻击方式<br>1、反射型<br>发出请求时，XSS 代码出现在 url 中，作为输入提交到服务器端，服务器端解析后响应，<br>XSS 代码随响应内容一起传回给浏览器，最后浏览器解析执行 XSS 代码。这个过程像一次反射，所以叫反射型 XSS。<br>2、存储型存<br>储型 XSS 和反射型 XSS 的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），<br>下次请求时目标页面时不用再提交 XSS 代码。</p>
<p>XSS 的防范措施（encode + 过滤）主要有三个：<br>1、编码：<br>对用户输入的数据进行 HTML Entity(安特踢) 编码。<br>2、过滤：<br>移除用户输入的和事件相关的属性。如 onerror 可以自动触发攻击，还有 onclick 等。<br>（总而言是，过滤掉一些不安全的内容）移除用户输入的 Style 节点、Script 节点、Iframe 节点。<br>（尤其是 Script 节点，它可是支持跨域的呀，一定要移除）。<br>3、校正<br>避免直接对 HTML Entity 进行解码。<br>使用 DOM Parse 转换，校正不配对的 DOM 标签。<br>这个概念，它的作用是把文本解析成 DOM 结构。<br>比较常用的做法是，通过第一步的编码转成文本，然后第三步转成 DOM 对象，然后经过第二步的过滤。<br>还有一种简洁的答案：<br>首先是 encode，如果是富文本，就白名单。</p>
<p>3、CSRF 和 XSS 的区别:<br>区别一：<br>CSRF：需要用户先登录网站 A，获取 cookie。<br>XSS：不需要登录。<br>区别二：（原理的区别）<br>CSRF：是利用网站 A 本身的漏洞，去请求网站 A 的 api。<br>XSS：是向网站 A 注入 JS 代码，然后执行 JS 里的代码，篡改网站 A 的内容。</p>
<h1 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h1><ul>
<li>有简单的了解，是一种理念 渐进式接近原生 app 的 web app，来让网站的体验变得更好</li>
</ul>
<h1 id="回流是什么？-怎么触发回流"><a href="#回流是什么？-怎么触发回流" class="headerlink" title="回流是什么？ 怎么触发回流"></a>回流是什么？ 怎么触发回流</h1><ul>
<li>什么是回流<br>通过构造 render tree，我们将可见 DOM 节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。<br>当 render tree 中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建时，这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建 render tree。</li>
<li>什么是重绘<br>当 render tree 中的一些元素需要更新属性时，而这些属性只是影响元素的外观、风格而不会影响布局的时候，比如 background-color，文字颜色、边框颜色等。则就称为重绘。</li>
<li>区别<br>回流必将引起重绘，重绘不一定引发回流，回流所需的成本比重绘高很多，改变父节点里的子节点很可能会导致父节点的一系列回流。</li>
<li>引起回流 -因为回流可能导致整个 Dom 树的重新构造,所以是性能的一大杀手。</li>
</ul>
<p>以下操作会引起回流：<br>① 改变窗口大小<br>② font-size 大小改变<br>③ 增加或者移除样式表<br>④ 内容变化（input 中输入文字会导致）<br>⑤ 激活 CSS 伪类（:hover）<br>⑥ 操作 class 属性，新增或者减少<br>⑦ js 操作 dom<br>⑧ offset 相关属性计算<br>⑨ 设置 style 的值 ……</p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><ul>
<li>内部定义的变量和方法是私有的，绑定在 this 上面的属性和方法是共有的</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一.概述构造函数</span></span><br><span class="line"><span class="comment">//1.最早的时候，js基于面向对象的，没有类这个概念，只是将构造函数理解成类。2015年es6出来后才真正的产生了类的概念，但是类实质上也是构造函数的语法糖。</span></span><br><span class="line"><span class="comment">// function Person1() &#123;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// let p1 = new Person1(); //p1:实例对象(对象)  Person1:构造函数</span></span><br><span class="line"><span class="comment">// class Person2 &#123;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// let p2 = new Person2(); //p2:实例对象  Person2:类</span></span><br><span class="line"><span class="comment">// console.log(typeof Person1); //function</span></span><br><span class="line"><span class="comment">// console.log(typeof Person2); //function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.构造函数</span></span><br><span class="line"><span class="comment">//构造函数：其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例对象，并且this变量会绑定在实例对象上。</span></span><br><span class="line"><span class="comment">//构造函数的基本特点：首字母大写, new运算符实例化对象。</span></span><br><span class="line"><span class="comment">// function Fn() &#123;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// Fn(); //Fn是普通的函数</span></span><br><span class="line"><span class="comment">// new Fn() //Fn是构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//这里的属性和方法都会绑定在实例对象上面，实例对象可以使用。</span></span><br><span class="line">  <span class="comment">//前提就是所有的属性和方法绑定在this上面，this代表的就是实例对象。</span></span><br><span class="line">  <span class="built_in">this</span>.name = name; <span class="comment">//实例的属性</span></span><br><span class="line">  <span class="built_in">this</span>.age = age; <span class="comment">//实例的属性</span></span><br><span class="line">  <span class="built_in">this</span>.sex = sex; <span class="comment">//实例的属性</span></span><br><span class="line">  <span class="built_in">this</span>.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//实例的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="built_in">this</span>.age + <span class="built_in">this</span>.sex;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 以 new 操作符调用函数的时候，函数内部发生以下变化：</span></span><br><span class="line"><span class="comment">// 1.创建一个空对象，并且 this 变量引用该对象。</span></span><br><span class="line"><span class="comment">// 2.属性和方法被加入到 this 引用的对象中。</span></span><br><span class="line"><span class="comment">// 3.并且最后隐式的返回 this （创建也是隐式）。</span></span><br></pre></td></tr></table></figure>

<h1 id="New-操作符的作用"><a href="#New-操作符的作用" class="headerlink" title="New 操作符的作用"></a>New 操作符的作用</h1><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">以 <span class="keyword">new</span> 操作符调用函数的时候，函数内部发生以下变化：</span><br><span class="line"><span class="number">1.</span>创建一个空对象，并且 <span class="built_in">this</span> 变量引用该对象。</span><br><span class="line"><span class="number">2.</span>属性和方法被加入到 <span class="built_in">this</span> 引用的对象中。</span><br><span class="line"><span class="number">3.</span>并且最后隐式的返回 <span class="built_in">this</span> （创建也是隐式）。</span><br></pre></td></tr></table></figure>

<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><ul>
<li>是 es6 新增的，异步编程的一种解决方案，用来取代回调函数和事件，比传统的解决方案——回调函数和事件——更合理和更强大。</li>
</ul>
<p>有三种状态：pending（进行中）、fulfilled（resolve 已成功）和 rejected(锐杰克腾德)（已失败）</p>
<p>promise 的特点：<br>（1）对象的状态不受外界影响。Promise 对象代表一个异步操作。<br>（2）一旦状态设定，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 pending 变为 resolve 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了<br>promise 的方法：<br>promise 实例方法：<br>Promise.prototype.then<br> Promise.prototype.catch</p>
<p>promise 静态方法<br>//1.Promise.all()： 用于将多个 Promise 实例， 包装成一个新的 Promise 实例，接受一个数组作为参数，只有数组里面的每个状态都变成 resolve， 则新的 Promise 实例状态才会变成 resolve.<br>//2.Promise.race()： 方法同样是将多个 Promise 实例， 包装成一个新的 Promise 实例， 接受一个数组作为参数， 只要其中有一个实例率先改变状态， 则整个的状态就跟着改变。</p>
<h1 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h1><ul>
<li>所有函数都有 prototype 属性 指向原型对象，</li>
<li>所有的对象都有__proto 这个属性。通过这个属性连接构造函数的原型</li>
</ul>
<h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><p>【浅拷贝】只复制一层对象，当对象的属性是引用类型时，实质上复制的是其引用，当引用指向的值发生变化的时候，原对象属性值也跟着变化，相互还是会受到影响。</p>
<p>【深拷贝】在拷贝的时候，创建新的对象，并把原对象所有属性都深拷贝被新对象，原属性如果是对象，也会重新创建新的对象并拷贝到新对象属性中，这样新旧对象，是相互对立的，互不影响，这个就是深拷贝。</p>
<ul>
<li>栈 自动分配内存空间，系统自动释放，基本类型的值和引用类型（object）的地址</li>
<li>堆 动态分配的内存，大小不定，也不会自动释放。存放引用类型的值。</li>
<li>引用类型遵循引用传递，传递的是地址。</li>
<li>基本类型遵循值传递</li>
<li>对象赋值- 重新开辟地址</li>
<li>浅拷贝<ul>
<li>直接等号赋值也是浅拷贝</li>
<li>遍历 for 循环 创建一个空数组，把 arr1 的每一项都给这个空数组<br>for (var i = 0; i &lt; arr1.length; i++) {<br>arr2[i] = arr1[i];<br>}<br>arr2.push(4);<br>console.log(arr1); //[1,2,3]<br>console.log(arr2); //[1,2,3,4]</li>
<li>Object.assign</li>
<li>Object.create</li>
</ul>
</li>
<li>深拷贝<ul>
<li>JSON 序列化，loadsh</li>
<li>loadsh: npm i lodash 安装依赖<br>import _ from ‘lodash’ 导入依赖<br>const v11= _.cloneDeep(v1) 使用深拷贝</li>
<li>递归+浅拷贝</li>
</ul>
</li>
</ul>
<h2 id="git-pull-和-git-fetch"><a href="#git-pull-和-git-fetch" class="headerlink" title="git pull 和 git fetch"></a>git pull 和 git fetch</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">说说 fetch 和 pull 的不同:</span><br><span class="line"></span><br><span class="line">fetch 只能更新远程仓库的代码为最新的，本地仓库的代码还未被更新，我们需要通过 git merge origin/master 来合并这两个版本，你可以把它理解为合并分支一样的。</span><br><span class="line"></span><br><span class="line">pull 操作是将本地仓库和远程仓库（本地的）更新到远程的最新版本。</span><br><span class="line"></span><br><span class="line">如果想要更加可控一点的话推荐使用fetch + merge。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="CORS-跨域原理"><a href="#CORS-跨域原理" class="headerlink" title="CORS 跨域原理"></a>CORS 跨域原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CORS，跨域资源共享，它需要浏览器和服务器同时支持，目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</span><br><span class="line"> 整个CORS通信中，都是浏览器自动完成的，不需要用户的参与，对于开发者来说cors通信与同源的ajax没有差别，代码完全一样。浏览器一旦发现ajax请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有察觉。</span><br><span class="line"> 要实现cors通信，主要是在服务器，也就是获得数据的一方做处理。</span><br></pre></td></tr></table></figure>

<h2 id="JQuery-链式调用"><a href="#JQuery-链式调用" class="headerlink" title="JQuery 链式调用"></a>JQuery 链式调用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主要使用作用域链  函数里面嵌套函数，return this</span><br><span class="line">为什么要返回this？</span><br><span class="line">因为在一个对象里面，this指向的是对象本身，而我们连续调用方法的时候，这些方法都是在对象内部定义的，所以this是可以访问到这些方法。</span><br></pre></td></tr></table></figure>

<h2 id="Node-js-模块"><a href="#Node-js-模块" class="headerlink" title="Node.js 模块"></a>Node.js 模块</h2><p>1.path,querystring,http,request</p>
<h2 id="Express-中间件的原理及实现-node"><a href="#Express-中间件的原理及实现-node" class="headerlink" title="Express 中间件的原理及实现-node"></a>Express 中间件的原理及实现-node</h2><p>app.use()就是通常所说的使用中间件<br>中间件其是一个函数，在响应发送之前对请求进行一些操作<br>这个函数有些不太一样，它还有一个 next 参数，而这个 next 也是一个函数，它表示函数数组中的下一个函数<br>一个请求发送到服务器后，它的生命周期是 先收到 request（请求），然后服务端处理，处理完了以后发送 response（响应）回去而这个服务端处理的过程就有文章可做了，想象一下当业务逻辑复杂的时候，为了明确和便于维护，需要把处理的事情分一下，分配成几个部分来做，而每个部分就是一个中间件</p>
<h2 id="洋葱模型-KOA"><a href="#洋葱模型-KOA" class="headerlink" title="洋葱模型 KOA"></a>洋葱模型 KOA</h2><p>请求进入一层一层包起来的中间件，最理念的请求从里一层一层返回出去。</p>
<h3 id="1-浏览器内核"><a href="#1-浏览器内核" class="headerlink" title="1. 浏览器内核"></a>1. 浏览器内核</h3><ul>
<li><p>五大浏览器内核<br>•Trident （MSHTML） （三叉戟；三叉线；三齿鱼叉）<br>•Gecko （壁虎）<br>•Presto （ 迅速的）<br>•Webkit （Safari 内核,Chrome 内核原型,它是苹果公司自己的内核，也是苹果的 Safari 浏览器使用的内核）<br>•Blink (由 Google 和 Opera Software 开发的浏览器排版引擎)</p>
</li>
<li><p>五大浏览器内核代表作品<br>*Trident:IE、Maxthon(遨游)、腾讯 、Theworld 世界之窗、360 浏览器<br>代表作品 IE,因为 IE 捆绑在 Windows 中，所以占有极高的市场份额，又称 IE 内核或是 MSHTML，此内核只能应用于 windows 平台，且是不开源的。<br>*Gecko：代表作品 Mozilla Firefox 是开源的,它的最大优势是跨平台，能在 Microsoft Windows、Linux 和 MacOS X 等主要操作系统上运行。<br>*Webkit :代表作品 Safari、Chrome ， 是一个开源项目。<br>*Presto :代表作品 Opera ，Presto 是由 Opera Software 开发的浏览器排版引擎。它也是世界上公认的渲染速度最快的引擎。<br>*Blink ：由 Google 和 Opera Software 开发的浏览器排版引擎，2013 年 4 月发布。</p>
</li>
</ul>
<h3 id="2-h5-新增了哪些内容"><a href="#2-h5-新增了哪些内容" class="headerlink" title="2. h5 新增了哪些内容"></a>2. h5 新增了哪些内容</h3><ul>
<li>语义化标签<br>header，footer，nav，section，article，aside 等</li>
<li>媒体标签<br>audio，video</li>
<li>功能性标签<br>svg，canvas</li>
<li>智能表单<br>一些 input 的 type 类型，和新的 input 属性</li>
<li>本地存储<br>localstorage 和 sessionstorage</li>
<li>api<br>websocket, fetch(浏览器自带的数据请求方式)和 requestAnimationFrame（动画定时器）等等</li>
<li>新事件<br>onrisize, ondrag, onscroll, onmousewheel, onerror, onplay, onpause 等</li>
</ul>
<h3 id="3-语义化的理解？"><a href="#3-语义化的理解？" class="headerlink" title="3. 语义化的理解？"></a>3. 语义化的理解？</h3><p>用正确的标签做正确的事情！ html 语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析； 在没有样式 CCS 情况下也以一种文档格式显示，并且是容易阅读的。 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</p>
<h3 id="4-什么是响应式"><a href="#4-什么是响应式" class="headerlink" title="4. 什么是响应式"></a>4. 什么是响应式</h3><p>它是关于网页制作的过程中让不同的设备有不同的尺寸和不同的功能。响应式设计是让所有 的人能在这些设备上让网站运行正常</p>
<h3 id="5-localStorage-sessionStorage-和-cookie-之间的区别"><a href="#5-localStorage-sessionStorage-和-cookie-之间的区别" class="headerlink" title="5. localStorage, sessionStorage 和 cookie 之间的区别"></a>5. localStorage, sessionStorage 和 cookie 之间的区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th>cookie</th>
<th>localStorage</th>
<th>sessionStorage</th>
<th>IndexDB</th>
</tr>
</thead>
<tbody><tr>
<td>数据生命周期</td>
<td>一般由服务器生成，可以设置过期时间</td>
<td>持久化本地存储，除非被主动删除，否则一直存在</td>
<td>页面关闭就清理</td>
<td>持久化本地存储，除非被主动删除，否则一直存在</td>
</tr>
<tr>
<td>数据存储大小</td>
<td>4K</td>
<td>5M</td>
<td>5M</td>
<td>无限</td>
</tr>
<tr>
<td>与服务端通信</td>
<td>每次都会携带在 header 中，对于请求性能影响</td>
<td>不参与</td>
<td>不参与</td>
<td>不参与</td>
</tr>
</tbody></table>
<p>作用域不同：sessisionStorage 不能在不同的浏览器窗口中共享，即使是同一个页面；localStorage 和 cookie 在同一个浏览器的所有的同源窗口中都是共享的。<br>cookie 的存取方法需要自己封装，本地存储的存取的方法更直接</p>
<h3 id="6-websocket-协议和-http-协议的区别"><a href="#6-websocket-协议和-http-协议的区别" class="headerlink" title="6. websocket 协议和 http 协议的区别"></a>6. websocket 协议和 http 协议的区别</h3><ul>
<li>http 协议：每次 http 请求都需要创建一次 tcp 连接，通信只能由客户端发起，做不到服务器主动向客户端推送信息。</li>
<li>websocket 协议： websocket 是保持长连接，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h5 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h5><pre><code>- 使用cdn加速
- 多使用GET请求
- 避免空的src的图片，因为空的也会进行请求
</code></pre>
<h5 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h5><pre><code>- 样式表写在head的里面
- 用link代替@import
- 少嵌套
</code></pre>
<h5 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h5><pre><code>- 写在body的最下面，让网页渲染内容尽快加载给用户
- 使用h5新增的async关键字，可以让js异步执行
- 将js和css外部引入，并且精简并压缩
</code></pre>
<h5 id="减少-DOM-操作"><a href="#减少-DOM-操作" class="headerlink" title="减少 DOM 操作"></a>减少 DOM 操作</h5><h5 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h5><pre><code>- 图片预加载/懒加载
- 不要在html中缩放图片，如果有小图片，直接值用小图片
</code></pre>
<p>1、HTML5 有哪些新特性？移除了哪些元素？<br>HTML5 的新特性如下：<br>拖放（ Drag and drop）APIl<br>语义化更好的内容标签（ header、nav、 footer、 aside、 article、 section）<br>音频、视频（ audio、 video）API<br>画布（ Canvas）API<br>地理（ Geolocation）APl<br>本地离线存储（ localStorage），即长期存储数据，浏览器关闭后数据不丢失。<br>会话存储（ sessionStorage），即数据在浏览器关闭后自动删除<br>表单控件包括 calendar、date、time、 email、url、 search。<br>新的技术包括 webwork、 websocket、 Geolocation<br>移除的元素如下：<br>纯表现的元素，包括 basefont,big、 center、font、s, strike,t、u<br>对可用性产生负面影响的元素，包括 frame、 frameset、 Noframes<br>2、如何处理 HTML5 新标签的浏览器兼容问题？<br>IE8、IE7、IE6 支持用 document. create Element 产生标签，可以利用这一特性让这些浏览器支持 HTML5 新标签。浏览器支持新标签后，还需要添加标签默认的样式（最好的方式是直接使用成熟的框架，使用最多的是 html5shim 框架），可以用 IE hack 引入该框架<br>&lt;！–[if 1t IE 9]&gt;</p>
<script>src="http://html5shim.googlecode.com/svn/trunk/htm15.js</script>
<p>&lt;！[end if]–&gt;<br>3、如何区别 HTML 和 HTML5？</p>
<p>用 DOCTYPE 声明新增的结构元素和功能元素来区别它们。</p>
<p>4、什么是 HTML5？</p>
<p>HTML5 是最新的 HTML 标准，它的主要目标是提供所有内容，而不需要任何 Flash、 SilverLight 等的额外插件，这些内容来自动画、视频、富 GUI 等</p>
<p>HTML5 是万维网联盟（W3C）和网络超文本应用技术工作组（ WHATWG）合作输出的。</p>
<p>5、新的 HTML5 文档类型和字符集是什么？</p>
<p>HTML5 文档类型是&lt;！doctype html&gt;。</p>
<p>HTML5 使用的字符集&lt; meta charset=”UTF8”&gt;。</p>
<p>6、HTML5 Canvas 元素有什么作用？</p>
<p>Canvas 元素用于在网页上绘制图形，该元素标签的强大之处在于可以直接在 HTML 上进行图形操作。</p>
<p>7、HTML5 新增了哪些功能 AP？</p>
<p>新增的功能 API 包括 Media APl、 Text Track API、 Application Cache API、User Interaction、 Data Transfer API、 Command API、 Constraint Validation API、 History API</p>
<p>8、HTML5 的离线存储有哪些？</p>
<p>有以下离线存储 localStorage，可长期存储数据，即浏览器关闭后数据不丢失 session Storage，数据在浏览器关闭后自动删除，</p>
<p>9、HTML5 的 form 如何关闭自动补全功能？</p>
<p>将不想要提示的 frm 元素下的 Input 元素的 autocomplete 属性设置为 off</p>
<p>10、如何在 HTML5 页面中嵌入音频？</p>
<p>HTML5 包含了嵌入音频文件的标准方式，支持的格式包括 MP3、Wav 和 Ogg 等，嵌入方式如下。</p>
<audio controls>
<source src="icketang.mp3" type="audio/mpeg">
Your browser does'nt support audio embedding feature.
</audio>
11、如何在HTML5页面中嵌入视频？

<p>和嵌入音频文件一样，HTML5 定义了嵌入视频的标准方式，支持的格式包括 MP4、WebM 和 Ogg 等，嵌入方式如下。</p>
<p>&lt; video width=”450” height=”340” contro1s&gt;</p>
<source src="icketang.mp4"  type="video/mp4">
Your browser does'nt support video embedding feature.
</video>
12、HTML5引入了哪些新的表单属性？

<p>新增表单属性包括 datalist、 datetime、 output、 keygen、date、 month、week、time、 number、 range、 emailurl</p>
<p>13、如何显示我们自己画的一个弹框？</p>
<p>可以用一个简单的方法，在页面上单击一个按钮，弹出一个弹框，而弹框也是自己写的一个 div。单击前，先把弹框隐藏， onclick 事件发生之后就会显示出来</p>
<p>14、HTML5 应用缓存和常规的 HTML 浏览器缓存有什么差别？</p>
<p>HTML5 应用缓存最关键的就是支持离线应用，可获取少数或者全部网站内容，包括 HTML、CSS、图像和 JavaScript 脚本并存在本地。该特性提升了网站的性能，可通过如下方式实现。</p>
<p>&lt;！doctype html&gt;</p>
<html manifest="example. appcache">
......
</html>
与传统的浏览器缓存比较，该特性并不强制要求用户访问网站。

<p>15、为什么 HTML5 里面不需要 DTD（ Document Type Definition，文档类型定义）？如果不放入&lt;！doctype html&gt;标签，HTML5 还会工作吗？</p>
<p>HTML5 没有使用 SGML 或者 XHTML，它是一个全新的类型，因此不需要参考 DTD。对于 HTML5，仅须放置下面的文档类型代码，让浏览器识别 HTML5 文档。</p>
<p>如果不放入&lt;！doctype html&gt;标签，HTML5 不会工作。浏览器将不能识别出它是 HTML 文档，同时 HTML5 的标签将不能正常工作。</p>
<p>16、哪些浏览器支持 HTML5？</p>
<p>几乎所有的浏览器（如 Safari、 Chrome、 Firefox、 Opera、IE）都支持 HTML5</p>
<p>17、本地存储和会话（事务）存储之间的区别是什么？</p>
<p>本地存储数据持续永久，但是会话存储在浏览器打开时有效，在浏览器关闭时会话重置存储数据。</p>
<p>18、HTML5 中的应用缓存是什么？</p>
<p>HTML5 应用缓存的最终目的是帮助用户离线浏览页面。换句话说，如果网络连接不可用，打开的页面就来自浏览器缓存，离线应用缓存可以帮助用户达到这个目的。</p>
<p>应用缓存可以帮助用户指定哪些文件需要缓存，哪些不需要</p>
<p>19、如果把 HTML5 看成一个开放平台，它的构建模块有哪些？</p>
<p>如果把 HTML5 看成一个开放平台，它的构建模块至少包括以下几个，如<nav><header><section><footer>。</p>
<p>≤nav&gt;标签用来将具有导航性质的链接划分在一起，使代码结构在语义化方面更加准确</p>
<p>&lt; header&gt;标签用来定义文档的页眉。</p>
<p>&lt; section&gt;标签用来描述文档的结构。</p>
<p>&lt; footer&gt;标签用来定义页脚。在典型情况下，该元素会包含文档作者的姓名、文档的创作日期和联系信息</p>
<p>20、HTML5 为什么只需要写&lt;！doctype htm&gt;？</p>
<p>HTML5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 DOCTYPE 来规范浏览器的行为（让浏览器按照它们的方式来运行）。而 HTM4.01 基于 SGML，所以需要对 DTD 进行引用，才能告知浏览器文档所使用的类型。</p>
<p>21、HTML5 应用程序缓存为应用带来什么优势？</p>
<p>应用程序缓存为应用带来 3 个优势。</p>
<p>（1）离线浏览，让用户可在应用离线时（网络不可用时）使用它们。</p>
<p>（2）速度，让已缓存资源加载得更快。</p>
<p>（3）减少服务器负载，让浏览器将只下载服务器更新过的资源。</p>
<p>22、与 HTML4 比较，HTML5 废弃了哪些元素？</p>
<p>废弃的元素包括 frame、frameset、 noframe、 applet、big、 center 和 basefont。</p>
<p>23、HTML5 标准提供了哪些新的 API？</p>
<p>HTML5 提供很多新的 AP1，包括 Media APl、 Text Track API、 Application Cache API、 User InteractionAPI、 Data Transfer API、 Command APl、 Constraintion Validation API 和 History API</p>
<p>24、请你说一下 Web Worker 和 WebSocket 的作用。</p>
<p>Web Worker 的作用如下：</p>
<p>（1）通过 worker= new Worker（url）加载一个 JavaScript 文件，创建一个 Worker，同时返回一个 Worker 实例</p>
<p>（2）用 worker.postMessage（data）向 Worker 发送数据</p>
<p>（3）绑定 worker.onmessage 接收 Worker 发送过来的数据</p>
<p>（4）可以使用 worker.terminate()终止一个 Worker 的执行。</p>
<p>WebSocket 的作用如下。</p>
<p>它是 Web 应用程序的传输协议，提供了双向的、按序到达的数据流。它是 HTML5 新増的协议， WebSocket 的连接是持久的，它在客户端和服务器之间保持双工连接，服务器的更新可以及时推送到客户端，而不需要客户端以一定的时间间隔去轮询。</p>
<p>25、如何实现浏览器内多个标签页之间的通信？</p>
<p>在标签页之间，调用 localstorge、 cookies 等数据存储，可以实现标签页之间的通信</p>
<p>26、如何让 Websocket 兼容低版本浏览器？</p>
<p>使用 Adobe Flash Socket、 ActiveX HTMLFile（E）、 multipart 编码发送 XHR</p>
<p>与长轮询发送 XHR 等，可以实现不支持 WebSocket API 的浏览器对 Web Socket 的兼容。</p>
<p>27、HTML5 为浏览器提供了哪些数据存储方案？</p>
<p>在较高版本的浏览器中，提供了 sessionStorage：和 globalStorage。在 HTML5 规范中，用 localStorage 取代 globalStorage 。</p>
<p>HTML5 中的 Web Storage 包括两种存储方式，分别是 sessionStorage 和 localStorage。</p>
<p>sessionStorage 用于在本地存储一个会话（ session）中的数据，这些数据只有同一个会话中的页面才能访问，当会话结来后，数据也随之销毀。因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。</p>
<p>localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p>
<p>localStorage 和 sessionStorage 都具有相同的操作方法，例如 setItem、 getItem 和 removeltem 等</p>
<p>28、请描述一下 sessionStorage 和 localStorage 的区别。</p>
<p>sessionStorage 用于在本地存储一个会话中的数据，这些数据只有同一个会话中的页面才能访问，当会话结束后，数据也随之销毀。因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。</p>
<p>而 localstorage 用于持久化本地存储，除非主动删除数据，否则数据是永远不会过期的。</p>
<p>29、localStorage 和 cookie 的区别是什么？</p>
<p>localStorage 的概念和 cookie 相似，区别是 localStorage 是为了更大容量的存储设计的。cookie 的大小是受限的，并且每次请求一个新页面时， cookie 都会被发送过去，这样无形中浪费了带宽。另外， cookie 还需要指定作用域，不可以跨域调用。</p>
<p>除此之外， localStorage 拥有 setlten, getItem、 removeltem、 clear 等方法， cookie 则需要前端开发者自己封装 setCookie 和 get Cookie。但 cookie 也是不可或缺的，因为 cookie 的作用是与服务器进行交互，并且还是 HTP 规范的一部分，而 localStorage 仅因为是为了在本地“存储”数据而已，无法跨浏览器使用。</p>
<p>30、请你谈谈 cookie 的特点。</p>
<p>cookie 虽然为持久保存客户端数据提供了方便，分担了服务器存储的负担，但是有以下局限性。</p>
<p>（1）每个特定的域名下最多生成 20 个 cookie。</p>
<p>（2）IE6 或更低版本最多有 20 个 cookie。</p>
<p>（3）IE7 和之后的版本最多可以有 50 个 cookie。</p>
<p>（4） Firefox 最多可以有 50 个 cookie。</p>
<p>（5） Chrome 和 Safari 没有做硬性限制。</p>
<p>IE 和 Opera 会清理近期最少使用的 cookie, Firefox 会随机清理 cookie。</p>
<p>cookie 最大为 4096 字节，为了兼容性，一般不能超过 4095 字节。</p>
<p>IE 提供了一种存储方式，可以让用户数据持久化，叫作 userdata，从 IE5.0 就开始支持此功能。每块数据最多 128KB，每个域名下最多 1MB。这个持久化数据放在缓存中，如果缓存没有被清理，就会一直存在。</p>
<p>优点如下：</p>
<p>（1）通过良好的编程，控制保存在 cookie 中的 session 对象的大小。</p>
<p>（2）通过加密和安全传输技术（SSL），降低 cookie 被破解的可能性。</p>
<p>（3）只在 cookie 中存放不敏感数据，即使被盗也不会有重大损失。</p>
<p>（4）控制 cookie 的生命周期，使之不会永远有效。数据偷盗者很可能得到一个过期的 cookie。</p>
<p>缺点如下：</p>
<p>（1）“ cookie”的数量和长度有限制。每个 domain 最多只能有 20 条 cookie，每个 cookie 的长度不能超过 4KB，否则会被截掉。</p>
<p>（2）安全性问题。如果 cookie 被别人拦截了，就可以取得所有的 session 信息。即使加密也于事无补，因为拦截者并不需要知道 cookie 的意义，他只要原样转发 cookie 就可以达到目的。</p>
<p>（3）有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果把这个计数器保存在客户端，那么它起不到任何作用</p>
<p>31、cookie 和 session 的区别是什么？</p>
<p>区别如下：</p>
<p>（1） cookie 数据存放在客户的浏览器上， session 数据存放在服务器上。</p>
<p>（2） cookie 不是很安全，别人可以分析存放在本地的 cookie 并进行 cookie 欺骗。考虑到安全问题应当使用 session。</p>
<p>（3） session 会在一定时间内保存在服务器上。当访问增多时，会占用较多服务器的资源。为了减轻服务器的负担，应当使用 cookie。</p>
<p>（4）单个 cookie 保存的数据不能超过 4KB，很多浏览器都限制一个站点最多保存 20 个 cookie。</p>
<p>所以个人建议可以将登录信息等重要信息存放在 session 中，其他信息（如果需要保留）可以存放在 cookie 中。</p>
<p>32、什么是 SVG？</p>
<p>SVG 即可缩放失量图形（ Scalable Vector Graphics）。它是基于文本的图形语言，使用文本、线条、点等来绘制图像，这使得它轻便、显示迅速。</p>
<p>33、Canvas 和 SvG 的区别是什么？</p>
<p>两者的区别如下：</p>
<p>（1）一旦 Canvas 绘制完成将不能访问像素或操作它；任何使用 SVG 绘制的形状都能被记忆和操作，可以被浏览器再次显示。</p>
<p>（2） Canvas 对绘制动画和游戏非常有利；SVG 对创建图形（如 CAD）非常有利。</p>
<p>（3）因为不需要记住以后事情，所以 Canvas 运行更快；因为为了之后的操作，SVG 需要记录坐标，所以运行比较缓慢。</p>
<p>（4）在 Canvas 中不能为绘制对象绑定相关事件；在 SVG 中可以为绘制对象绑定相关事件。</p>
<p>（5） Canvas 绘制出的是位图，因此与分辨率有关；SvG 绘制出的是矢量图，因此与分辨率无关。</p>
<p>34、如何使用 Canvas 和 HTML5 中的 SVG 画一个矩形？</p>
<p>使用 SVG 绘制矩形的代码如下：</p>
<svg xmlns=http://www.w3.org/2000/svg  version="1.1">
<rect style="fill:rgb（255,100，0）；"height=200"  width="400"></rect>
</svg>
使用 Canvas绘制矩形的代码如下。

<p>&lt;canvas id=”myCanvas” width=500” height=”500”&gt;</canvas><br>var canvas=document.getElementById（’mycanvas’）；<br>var ctx= canvas.getContext（’2d’）；<br>ctx.rect（100,100,300,200）；<br>ctx fillstyle = ‘pink ‘<br>ctx. fill()<br>35、本地存储的数据有生命周期吗？</p>
<p>本地存储的数据没有生命周期，它将一直存储数据，直到用户从浏览器清除或者使用 JavaScript 代码移除。</p>
<p>36、HTML5 中如何实现应用缓存？</p>
<p>首先，需要指定“ manifest”文件，” manifest”文件帮助你定义缓存如何工作以下是“ manifest”文件的结构。</p>
<p>CACHE MANTEEST</p>
<h1 id="version-1-0"><a href="#version-1-0" class="headerlink" title="version 1.0"></a>version 1.0</h1><p>/demo. css<br>/demo. js<br>/demo.png<br>所有 manifest 文件都以” CACHE MANIFEST”语句开始。 #（散列标签）有助于提供缓存文件的版本。<br>manifest 文件的内容类型应是”text/ cache- manifest”。<br>创建一个缓存 manifest 文件后，在 HTML 页面中提供 manifest 链接，代码如下所示。</p>
<html manifest="icketang. appcache">

<p>第一次运行以上文件时，它会添加到浏览器应用缓存中，在服务器宕机时，页面从应用缓存中获取数据。</p>
<p>37、如何刷新浏览器的应用缓存？</p>
<p>应用缓存通过变更“#”标签后的版本号来刷新，如下所示：</p>
<p>CACHE MANIFEST</p>
<h1 id="version-2-0"><a href="#version-2-0" class="headerlink" title="version 2.0"></a>version 2.0</h1><p>/icketang.css<br>/icketang.js<br>/icketang. png<br>NETWORK：<br>login. php<br>38、应用缓存中的回退是什么？</p>
<p>应用缓存中的回退会帮助你指定在服务器不可访问时，显示某文件。例如在下面的 manifest 文件中，如果用户输入了“/home”，同时服务器不可到达，“404htm”文件应送达。</p>
<p>FALLBACK：<br>/home//404. html<br>39、应用缓存中网络命令的作用是什么？</p>
<p>网络命令描述不需要缓存的文件，例如以下代码中“ login.php”始终都不应该缓存或者离线访问。</p>
<p>NETWORK<br>login. php<br>40、什么是 Websql？</p>
<p>Websql 是一个在浏览器客户端的结构关系数据库，是浏览器内的本地 RDBMS（关系型数据库管理系统），可以使用 SQL 查询。</p>
<p>41、Websql 是 HTML5 的一个规范吗？</p>
<p>不是，许多人把它标记为 HTML5，但是它不是 HTML5 规范的一部分，这个规范是基于 SQLite 的</p>
<p>42、HTML5 如何实现跨域？</p>
<p>在服务器端设置允许在其他域名下访问，例如允许所有域名访问以下内容。</p>
<p>response.setHeader（”Access-Control-Allow-Origin”，”*“）；<br>response.setHeader （”Access-Control-Allow-Methods”，”POST”）；<br>response.setHeader（”Access-Control-Allow-Headers”，”x-requested-with, content-type”）；</p>
<h1 id="CSS-1"><a href="#CSS-1" class="headerlink" title="CSS"></a>CSS</h1><h3 id="1-元素水平垂直居中的方式"><a href="#1-元素水平垂直居中的方式" class="headerlink" title="1. 元素水平垂直居中的方式"></a>1. 元素水平垂直居中的方式</h3><ul>
<li>弹性盒：<br>父元素： display: flex;<br>子元素： margin: auto;隐藏三个边</li>
<li>弹性盒 2：<br>父元素：display:flex;<br>justify-content: center;<br>align-item: center;</li>
<li>定位 1：<br>父元素：position: relative;<br>子元素：position:absolute;<br>top:0;<br>left:0;<br>right:0;<br>bottom:0;<br>margin:auto;</li>
<li>定位加 2d 变形<br>父元素： position:relative;<br>子元素：position:absolute;<br>top:50%;<br>left:50%;<br>transform:translate(-50%,-50%);</li>
</ul>
<h3 id="2-清除浮动的方式"><a href="#2-清除浮动的方式" class="headerlink" title="2. 清除浮动的方式"></a>2. 清除浮动的方式</h3><ul>
<li><p>给高度塌陷的元素添加 overflow: hidden</p>
</li>
<li><p>里面的最下面加一个空的 div，并添加 clear: both</p>
</li>
<li><p>万能清除法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.clearfix::after &#123;</span><br><span class="line">  content: &#x27;.&#x27;;</span><br><span class="line">  display: block;</span><br><span class="line">  height: 0;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  visibility: hidden;</span><br><span class="line">  clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>display:flow-root</p>
<ul>
<li>新出来的，没有副作用，但是还存在兼容性问题</li>
</ul>
</li>
</ul>
<h3 id="3-display-有哪些属性值"><a href="#3-display-有哪些属性值" class="headerlink" title="3. display 有哪些属性值"></a>3. display 有哪些属性值</h3><ul>
<li>block: 块状元素</li>
<li>inline-block：行内块元素</li>
<li>inline：行内元素</li>
<li>none：隐藏元素</li>
<li>flex：弹性盒</li>
<li>inline-flex: 行内的弹性盒</li>
<li>list-item: li 的默认属性值</li>
<li>table: table 的默认值</li>
<li>table-row: tr 的默认值</li>
<li>table-cell: rd 的默认值</li>
<li>inherit: 继承</li>
</ul>
<h3 id="4-介绍一下-em，rem，vw-vh-vmax-vmin"><a href="#4-介绍一下-em，rem，vw-vh-vmax-vmin" class="headerlink" title="4. 介绍一下 em，rem，vw, vh, vmax, vmin"></a>4. 介绍一下 em，rem，vw, vh, vmax, vmin</h3><ul>
<li><p>em: em 是相对长度单位。相对于当前元素内文本的字体尺寸</p>
</li>
<li><p>rem: rem 是 CSS3 新增的一个相对单位，相对的是 HTML 根元素的字体大小。除了 IE8 及更早版本外，所有浏览器均已支持 rem。</p>
</li>
<li><p>vw: 视窗宽度的百分比（1vw 代表视窗的宽度为 1%）</p>
</li>
<li><p>vh: 视窗高度的百分比</p>
</li>
<li><p>vmax: 当前 vw 和 vh 中较大的一个值</p>
</li>
<li><p>vmin: 当前 vw 和 vh 中较小的一个值</p>
</li>
<li><p>视窗(Viewport)是浏览器实际显示内容的区域，是不包括工具栏和按钮的网页浏览器的内容区域。</p>
</li>
<li><p>做移动页面开发时，如果使用 vw、wh 设置字体大小（比如 5vw），在竖屏和横屏状态下显示的字体大小是不一样的。由于 vmin 和 vmax 是当前较小的 vw 和 vh 和当前较大的 vw 和 vh。这里就可以用到 vmin 和 vmax。使得文字大小在横竖屏下保持一致。</p>
</li>
</ul>
<h3 id="5-定位有哪些？"><a href="#5-定位有哪些？" class="headerlink" title="5. 定位有哪些？"></a>5. 定位有哪些？</h3><ul>
<li>static: 默认值。没有定位，元素出现在正常的文档流中（忽略 top, bottom, left, right 或者 z-index 声明）。</li>
<li>relative: 相对于元素本身正常的位置进行定位，不脱离文档流，”left:20” 会向元素的 LEFT 位置移动 20 像素。</li>
<li>absolute: 生成绝对定位元素，相对于第一个 static 定位以外的父元素进行定位，元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定， 相对的是父元素 border 的位置</li>
<li>fixed: 生成固定定位的元素，相当于浏览器窗口进行定位。</li>
<li>sticky: 粘性定位，该定位基于用户滚动的位置。正常情况下，它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;它会固定在目标位置。</li>
<li>inherit: 规定从父元素继承 position 属性的值</li>
<li>initial: 设置属性为默认值(static)</li>
</ul>
<h3 id="6-浏览器的渲染原理"><a href="#6-浏览器的渲染原理" class="headerlink" title="6. 浏览器的渲染原理"></a>6. 浏览器的渲染原理</h3><ul>
<li>浏览器将获取的 HTML 文档解析成 DOM Tree（DOM 树）</li>
<li>将 Css 样式表，解析成 CSSOM Tree（CSS 树）</li>
<li>将 DOM 和 CSSOM 合并为渲染树（rendering tree），这个过程称之为 attachment</li>
<li>渲染树的每个元素经过精确的计算后，给出坐标，这个过程称之为 layout</li>
<li>将渲染树的各个节点绘制到屏幕上，这个过程称之为 painting<br><img src="https://upload-images.jianshu.io/upload_images/3534846-00ef9f3d405462ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/624/format/webp" alt="avatar"></li>
</ul>
<h3 id="8-C3-新增了哪些内容"><a href="#8-C3-新增了哪些内容" class="headerlink" title="8. C3 新增了哪些内容"></a>8. C3 新增了哪些内容</h3><ul>
<li>过渡     transition： CSS 属性，花费时间，效果曲线(默认 ease)，延迟时间(默认 0)复制代码</li>
<li>动画     animation：动画名称，一个周期花费时间，运动曲线（默认 ease），动画延迟（默认 0），播放次数（默认 1），是否反向播放动画（默认 normal），是否暂停动画（默认 running）复制代码</li>
<li>形状转换    transform:适用于 2D 或 3D 转换的元素<br>rotate(30deg);   translate(30px,30px);   scale(.8);        skew(10deg,10deg);        rotateX(180deg);     rotateY(180deg);        rotate3d(10,10,10,90deg);</li>
<li>选择器</li>
<li>阴影     box-shadow: 水平阴影的位置 垂直阴影的位置 模糊距离 阴影的大小 阴影的颜色 阴影开始方向（默认是从里往外，设置 inset 就是从外往里）;复制代码</li>
<li>边框     border-image: 图片 url 图像边界向内偏移 图像边界的宽度(默认为边框的宽度) 用于指定在边框外部绘制偏移的量（默认 0） 铺满方式–重复（repeat）、拉伸（stretch）或铺满（round）（默认：拉伸（stretch））;</li>
<li>背景   background-clip  制定背景绘制（显示）区域  background-origin    background-size 1.（background-clip: border-box;）默认情况（从边框开始绘制）                                                              2.（background-clip: padding-box;）从 padding 开始绘制（显示），不算 border,，相当于把 border 那里的背景给裁剪掉！                                                                                                                                             3.（background-clip: content-box;）只在内容区绘制（显示），不算 padding 和 border，相当于把 padding 和 border 那里的背景给裁剪掉！</li>
<li>反射      -webkit-box-reflect:方向[ above-上 | below-下 | right-右 | left-左 ]，偏移量，遮罩图片</li>
<li>文字     换行     语法：word-break: normal|break-all|keep-all;、语法：word-wrap: normal|break-word;  超出省略号    text-overflow:clip|ellipsis|string                                                                                                  文字阴影     语法：text-shadow:水平阴影，垂直阴影，模糊的距离，以及阴影的颜色。</li>
<li>颜色   rgba（rgb 为颜色值，a 为透明度） color: rgba(255,00,00,1);background: rgba(00,00,00,.5);  hsla h:色相”，“s：饱和度”，“l：亮度”，“a：透明度”  color: hsla( 112, 72%, 33%, 0.68);background-color: hsla( 49, 65%, 60%, 0.68);复制代码</li>
<li>渐变</li>
<li>Filter（滤镜）：黑白色 filter: grayscale(100%)、褐色 filter:sepia(1)、饱和度 saturate(2)、色相旋转 hue-rotate(90deg)、反色 filter:invert(1)、透明度 opacity(.5)、亮度 brightness(.5)、对比度 contrast(2)、模糊 blur(3px)</li>
<li>弹性布局   Flex</li>
<li>栅格布局 grid</li>
<li>多列布局</li>
<li>盒模型定义    box-sizing:border-box 的时候，边框和 padding 包含在元素的宽高之内！                            box-sizing:content-box 的时候，边框和 padding 不包含在元素的宽高之内！如下图</li>
<li>媒体查询 就在监听屏幕尺寸的变化，在不同尺寸的时候显示不同的样式！在做响应式的网站里面，是必不可少的一环！</li>
</ul>
<h3 id="9-过渡和动画"><a href="#9-过渡和动画" class="headerlink" title="9. 过渡和动画"></a>9. 过渡和动画</h3><ul>
<li>过渡需要用户触发，动画不需要用户触发</li>
<li>过渡不能控制中间过程，动画可以</li>
<li>过渡只能一次， 动画可以任意次数</li>
</ul>
<h3 id="10-回流和重绘"><a href="#10-回流和重绘" class="headerlink" title="10. 回流和重绘"></a>10. 回流和重绘</h3><h5 id="什么是回流"><a href="#什么是回流" class="headerlink" title="什么是回流"></a>什么是回流</h5><pre><code>通过构造render tree，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。
当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建时，这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。
</code></pre>
<h5 id="什么是重绘"><a href="#什么是重绘" class="headerlink" title="什么是重绘"></a>什么是重绘</h5><pre><code>当render tree中的一些元素需要更新属性时，而这些属性只是影响元素的外观、风格而不会影响布局的时候，比如background-color，文字颜色、边框颜色等。则就称为重绘。
</code></pre>
<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><pre><code>回流必将引起重绘，重绘不一定引发回流，回流所需的成本比重绘高很多，改变父节点里的子节点很可能会导致父节点的一系列回流。
</code></pre>
<ul>
<li><p>何时发生回流重绘<br>页面第一次渲染(初始化)<br>添加或删除可见的 DOM 元素<br>元素的位置发生变化<br>元素的尺寸发生变化(包括外边距，内边距，边框大小，高度和宽度等）<br>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代或者字体改变<br>浏览器窗口尺寸的变化（因为回流是根据视口的大小来计算元素的位置和大小的）<br>定位或者浮动，盒模型等<br>获取元素的某些属性</p>
</li>
<li><p>减少重绘和回流<br>使用 transform 做形变和位移替代定位 top<br>使用 visibility 替换 display:none, 因为前者只会引起重绘，而后者会引起回流<br>不要使用 table 布局，可能很小的一个改动会造成整个 table 的重新布局<br>动画实现的速度选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame<br>CSS 选择符会从右往左匹配查找，因此要避免层级过多<br>将频繁重绘或回流的节点设置为图层，图层能够阻止该节点渲染行为影响别的节点。比如 video 标签，浏览器会自动将该节点变为图层<br>避免多次读取某些属性<br>合并多次对 DOM 和样式的修改，然后一次处理掉</p>
</li>
</ul>
<h3 id="11-弹性盒"><a href="#11-弹性盒" class="headerlink" title="11. 弹性盒"></a>11. 弹性盒</h3><h5 id="父元素加"><a href="#父元素加" class="headerlink" title="父元素加"></a>父元素加</h5><pre><code>- display
- flex-direction:设置主轴方向
- justify-content：设置主轴对齐方式
- align-items：设置侧轴对齐方式
- flex-wrap 设置是否换行
- align-content : 行与行之间的排列方式
</code></pre>
<h5 id="子元素加"><a href="#子元素加" class="headerlink" title="子元素加"></a>子元素加</h5><pre><code>- align-self: 设置单独在侧轴对齐方式
- order: 设置排列顺序
- flex-grow: 放大比例
- flex-shrink: 缩小比例
- flex-basis: 分配剩余空间前占据的位置
- flex: flex-grow,flex-shrink,flex-basis的缩写
</code></pre>
<h3 id="12-标准盒模型有几种"><a href="#12-标准盒模型有几种" class="headerlink" title="12. 标准盒模型有几种"></a>12. 标准盒模型有几种</h3><ul>
<li>标准盒模型：margin，border，padding，content<br>宽 = 左 border + 左 padding + width + 右 padding + 右 border</li>
<li>怪异盒模型：border 和 padding 算在宽高的里面<br>宽 = width</li>
</ul>
<h3 id="13-移动端适配怎么做"><a href="#13-移动端适配怎么做" class="headerlink" title="13. 移动端适配怎么做"></a>13. 移动端适配怎么做</h3><ol>
<li><p>使用手机淘宝之前的方案 flexible.js</p>
</li>
<li><p>使用 less 或者 sass 等 css 预编译的 mixin 混合功能，带参数进行自动计算</p>
</li>
<li><p>使用最新的 postcss 的 postcss-pxtorem 插件和 lib-flexible 插件</p>
<p>1.Media Queries 通过查询设备的宽度来执行不同的 css 代码，最终达到界面 的配置<br>2.Flex弹性布局<br>3.rem + viewport 缩放 实现原理 根据rem将页面放大dpr倍, 然后viewport设置为1/dpr.<br>4、rem实现 移动端适配方案：</p>
<pre><code>1）viewport（scale=1/dpr）    dpr:备像素比
2）rem 3）flex 4）vm/vh
以iphone8为例，iphone8的CSS像素为375px*677px，DPR是2，
所以其设备像素为750px*1354px
750(px) / 375(px)  = 2
</code></pre>
</li>
</ol>
<h3 id="14-rgba-和-opacity-的透明效果有什么不同？"><a href="#14-rgba-和-opacity-的透明效果有什么不同？" class="headerlink" title="14. rgba()和 opacity 的透明效果有什么不同？"></a>14. rgba()和 opacity 的透明效果有什么不同？</h3><ul>
<li>rgba()和 opacity 都能实现透明效果，但最大的不同是 opacity 作用于元素，以及元素内的 所有内容的透明度， 而 rgba()只作用于元素的颜色或其背景色。（设置 rgba 透明的元素的子元素不会继承透明 效果！）</li>
</ul>
<h3 id="15-BFC"><a href="#15-BFC" class="headerlink" title="15. BFC"></a>15. BFC</h3><p>BFC: block formatting context(块状格式化上下文)<br>bfc 是一个独立的空间，只有块状元素参与，<br>它规定了里面的块状元素如何布局，它和外部的坏境毫不相干</p>
<h5 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h5><pre><code>1. 根元素（html）本身就是一个BFC
2. float不能none的时候
3. position为absolute或者fixed的时候
4. display为inline-block, table-cell, flex, inline-flex等
5. overflow不为visible的时候
</code></pre>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><pre><code>1. 内部的元素是从上往下排的
2. 垂直方向的距离有margin来决定的，属于同一个BFC的两个元素的上下margin会重叠
3. 每个元素的margin-left会和父元素的border-left相接触
4. bfc的区域不会和浮动的区域相重叠
5. bfc的区域和外部空间毫不相干
6. 在计算bfc高度的时候，浮动元素也会参与计算
</code></pre>
<h3 id="16-Css-中哪些属性可以继承"><a href="#16-Css-中哪些属性可以继承" class="headerlink" title="16. Css 中哪些属性可以继承"></a>16. Css 中哪些属性可以继承</h3><ul>
<li>字体系列属性<br>font-family：字体系列<br>font-weight：字体的粗细<br>font-size：字体的大小<br>font-style：字体的风格</li>
<li>文本系列属性<br>text-indent：文本缩进<br>text-align：文本水平对齐<br>line-height：行高<br>word-spacing：单词之间的间距<br>letter-spacing：中文或者字母之间的间距<br>text-transform：控制文本大小写（就是 uppercase、lowercase、capitalize 这三个）<br>color：文本颜色</li>
<li>元素可见性：<br>visibility：控制元素显示隐藏</li>
<li>列表布局属性：<br>list-style：列表风格，包括 list-style-type、list-style-image 等</li>
<li>光标属性：<br>cursor：光标显示为何种形态</li>
</ul>
<h3 id="17-有那些行内元素、有哪些块级元素"><a href="#17-有那些行内元素、有哪些块级元素" class="headerlink" title="17. 有那些行内元素、有哪些块级元素"></a>17. 有那些行内元素、有哪些块级元素</h3><h5 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h5><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;a&gt;标签可定义锚</span><br><span class="line">&lt;abbr&gt;表示一个bai缩写形式</span><br><span class="line">&lt;acronym&gt;定义只取首字母缩写</span><br><span class="line">&lt;b&gt;字体du加粗</span><br><span class="line">&lt;bdo&gt;可覆盖默zhi认的文本方向</span><br><span class="line">&lt;big&gt;大号字体加粗</span><br><span class="line">&lt;br&gt;换行</span><br><span class="line">&lt;cite&gt;引用进行定义</span><br><span class="line">&lt;code&gt;定义计算机代码文本</span><br><span class="line">&lt;dfn&gt;定义一个定义项目</span><br><span class="line">&lt;em&gt;定义为强调的内容</span><br><span class="line">&lt;i&gt;斜体文本效果</span><br><span class="line">&lt;img&gt;向网页中嵌入一幅图像</span><br><span class="line">&lt;input&gt;输入框</span><br><span class="line">&lt;kbd&gt;定义键盘文本</span><br><span class="line">&lt;label&gt;标签为</span><br><span class="line">&lt;input&gt; 元素定义标注（标记）</span><br><span class="line">&lt;q&gt;定义短的引用</span><br><span class="line">&lt;samp&gt;定义样本文本</span><br><span class="line">&lt;select&gt;创建单选或多选菜单</span><br><span class="line">&lt;small&gt;呈现小号字体效果</span><br><span class="line">&lt;span&gt;组合文档中的行内元素</span><br><span class="line">&lt;strong&gt;语气更强的强调的内容</span><br><span class="line">&lt;sub&gt;定义下标文本</span><br><span class="line">&lt;sup&gt;定义上标文本</span><br><span class="line">&lt;textarea&gt;多行的文本输入控件</span><br><span class="line">&lt;tt&gt;打字机或者等宽的文本效果</span><br><span class="line">&lt;var&gt;定义变量</span><br></pre></td></tr></table></figure>
</code></pre>
<h5 id="块状元素"><a href="#块状元素" class="headerlink" title="块状元素"></a>块状元素</h5><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;address&gt;定义地址</span><br><span class="line">&lt;caption&gt;定义表格标题</span><br><span class="line">&lt;dd&gt;定义列表中定义条目</span><br><span class="line">&lt;div&gt;定义文档中的分区或节</span><br><span class="line">&lt;dl&gt;定义列表</span><br><span class="line">&lt;dt&gt;定义列表中的项目</span><br><span class="line">&lt;fieldset&gt;定义一个框架集</span><br><span class="line">&lt;form&gt;创建 HTML 表单</span><br><span class="line">&lt;h1&gt;定义最大的标题</span><br><span class="line">&lt;h2&gt;定义副标题</span><br><span class="line">&lt;h3&gt;定义标题</span><br><span class="line">&lt;h4&gt;定义标题</span><br><span class="line">&lt;h5&gt;定义标题</span><br><span class="line">&lt;h6&gt;定义最小的标题</span><br><span class="line">&lt;hr&gt;创建一条水平线</span><br><span class="line">&lt;legend&gt;元素为 </span><br><span class="line">&lt;fieldset&gt;元素定义标题</span><br><span class="line">&lt;li&gt;标签定义列表项目</span><br><span class="line">&lt;noframes&gt;为那些不支持框架的浏览器显示文本，于 frameset 元素内部</span><br><span class="line">&lt;noscript&gt;定义在脚本未被执行时的替代内容</span><br><span class="line">&lt;ol&gt;定义有序列表</span><br><span class="line">&lt;ul&gt;定义无序列表</span><br><span class="line">&lt;p&gt;标签定义段落</span><br><span class="line">&lt;pre&gt;定义预格式化的文本</span><br><span class="line">&lt;table&gt;标签定义 HTML 表格</span><br><span class="line">&lt;tbody&gt;标签表格主体（正文）</span><br><span class="line">&lt;td&gt;表格中的标准单元格</span><br><span class="line">&lt;tfoot&gt;定义表格的页脚（脚注或表注）</span><br><span class="line">&lt;th&gt;定义表头单元格</span><br><span class="line">&lt;thead&gt;标签定义表格的表头</span><br><span class="line">&lt;tr&gt;定义表格中的行</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="18-css-权重"><a href="#18-css-权重" class="headerlink" title="18. css 权重"></a>18. css 权重</h3><p>!important &gt; id &gt; class &gt; 标签<br>包含选择器的权重等于每一级选择器的权重之和</p>
<h3 id="19-css-选择器有哪些"><a href="#19-css-选择器有哪些" class="headerlink" title="19. css 选择器有哪些"></a>19. css 选择器有哪些</h3><ul>
<li>通配符</li>
<li>ID 选择器</li>
<li>类选择器</li>
<li>元素选择器</li>
<li>后代选择器</li>
<li>层级选择器</li>
<li>属性选择器</li>
<li>伪类选择器<ul>
<li>结构伪类</li>
<li>目标伪类</li>
<li>ui 状态伪类</li>
<li>动态伪类</li>
<li>否定伪类</li>
</ul>
</li>
<li>等</li>
</ul>
<h3 id="19-清除图片间隙"><a href="#19-清除图片间隙" class="headerlink" title="19. 清除图片间隙"></a>19. 清除图片间隙</h3><ul>
<li>清除图片左右的间隙<ol>
<li>将图片挨着写（中间没有空格，也没有回车）</li>
<li>将图片的父元素的 font-size 设置成 0</li>
<li>给图片设置浮动</li>
</ol>
</li>
<li>清除图片的上下间距<ol>
<li>将图片设置成 display: block</li>
<li>给图片设置 vertical-align: top / middle / bottom</li>
</ol>
</li>
</ul>
<h3 id="20-stylus-sass-less-区别"><a href="#20-stylus-sass-less-区别" class="headerlink" title="20. stylus/sass/less 区别"></a>20. stylus/sass/less 区别</h3><ul>
<li>均具有“变量”、“混合”、“嵌套”、“继承”、“颜色混合”五大基本特性</li>
<li>Scss 和 LESS 语法较为严谨，LESS 要求一定要使用大括号“{}”，Scss 和 Stylus 可以通过缩进表示层次与嵌套关系</li>
<li>Scss 无全局变量的概念，LESS 和 Stylus 有类似于其它语言的作用域概念</li>
<li>Sass 是基于 Ruby 语言的，而 LESS 和 Stylus 可以基于 NodeJS NPM 下载相应库后进行编译；<br>less 和 css</li>
</ul>
<ol>
<li>less 嵌套使用</li>
<li>less 代码简洁</li>
<li>less 可以定义变量</li>
</ol>
<h1 id="JavaScript-1"><a href="#JavaScript-1" class="headerlink" title="JavaScript"></a>JavaScript</h1><h3 id="1-js-的数据类型"><a href="#1-js-的数据类型" class="headerlink" title="1. js 的数据类型"></a>1. js 的数据类型</h3><ul>
<li>基本数据类型（5 种）： string，number，null，undefined, boolean</li>
<li>复杂数据类型（1 种）： object</li>
<li>es6 新增（1 种）：symbol</li>
<li>es11 新增：bigint</li>
</ul>
<h3 id="2-js-的变量申明方式"><a href="#2-js-的变量申明方式" class="headerlink" title="2. js 的变量申明方式"></a>2. js 的变量申明方式</h3><ul>
<li>var</li>
<li>let</li>
<li>const</li>
<li>function</li>
<li>import</li>
<li>class</li>
</ul>
<h3 id="4-如何判断一个变量的类型，以及-typeof-和-instanceof-的区别"><a href="#4-如何判断一个变量的类型，以及-typeof-和-instanceof-的区别" class="headerlink" title="4. 如何判断一个变量的类型，以及 typeof 和 instanceof 的区别"></a>4. 如何判断一个变量的类型，以及 typeof 和 instanceof 的区别</h3><ul>
<li>typeof 和 instanceof 常用来判断一个变量是否为空， 或者是什么类型的</li>
<li>typeof 的返回值是一个字符串，用来说明变量的数据类型</li>
<li>typeof 一般只能返回如下几个结果： number, boolean, string, function, object, undefined。<ul>
<li>其中对象，数组，null，以及 window，document 的值都是 object</li>
</ul>
</li>
<li>instanceof 的返回值为布尔值;</li>
<li>instanceof 用于判断一个变量是否属于某个对象的实例。</li>
</ul>
<h3 id="5-用过哪些数组排序的方法"><a href="#5-用过哪些数组排序的方法" class="headerlink" title="5. 用过哪些数组排序的方法"></a>5. 用过哪些数组排序的方法</h3><p><img src="https://user-gold-cdn.xitu.io/2018/9/9/165bd6dedf755d33?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="avatar"></p>
<h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 冒泡排序: 比较两个相邻的项，如果第一个大于第二个则交换他们的位置,元素项向上移动至正确的顺序，就好像气泡往上冒一样</span><br><span class="line">// 冒泡demo:</span><br><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">    let len = arr.length;</span><br><span class="line">    for (let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        for (let j = 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j+1]) &#123;        //相邻元素两两对比</span><br><span class="line">                [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 1) 首先，在数组中选择一个中间项作为主元</span><br><span class="line">// 2) 创建两个指针，左边的指向数组第一个项，右边的指向最后一个项，移动左指针，直到找到一个比主元大的项，接着，移动右边的指针，直到找到一个比主元小的项，然后交换它们。重复这个过程，直到</span><br><span class="line">// 左侧的指针超过了右侧的指针。这个使比主元小的都在左侧，比主元大的都在右侧。这一步叫划分操作</span><br><span class="line">// 3) 接着，算法对划分后的小数组（较主元小的值组成的的小数组， 以及较主元大的值组成的小数组）重复之前的两个步骤，直到排序完成</span><br><span class="line">// 快排demo:</span><br><span class="line">function quickSort(arr, left, right) &#123;</span><br><span class="line">    let len = arr.length;</span><br><span class="line">    let partitionIndex;</span><br><span class="line">    left = typeof left !== &#x27;number&#x27; ? 0 : left;</span><br><span class="line">    right = typeof right !== &#x27;number&#x27; ? len - 1 : right;</span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        partitionIndex = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, partitionIndex - 1);</span><br><span class="line">        quickSort(arr, partitionIndex + 1, right);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">function partition(arr, left, right) &#123;     //分区操作</span><br><span class="line">    let pivot = left;                      //设定基准值（pivot）</span><br><span class="line">    let index = pivot + 1;</span><br><span class="line">    for (let i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        if (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            [arr[i], arr[index]] = [arr[index], arr[i]];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [arr[pivot], arr[index - 1]] = [arr[index - 1], arr[pivot]];</span><br><span class="line">    return index - 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 选择排序：大概思路是找到最小的放在第一位，找到第二小的放在第二位，以此类推 算法复杂度O(n^2)</span><br><span class="line">// 选择demo:</span><br><span class="line">function selectionSort(arr) &#123;</span><br><span class="line">  let len = arr.length;</span><br><span class="line">  let minIndex;</span><br><span class="line">  for (let i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">    minIndex = i;</span><br><span class="line">    for (let j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">      if (arr[j] &lt; arr[minIndex]) &#123;     //寻找最小的数</span><br><span class="line">          minIndex = j;                 //将最小数的索引保存</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];</span><br><span class="line">  &#125;</span><br><span class="line">return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 插入排序：每次排一个数组项，假设数组的第一项已经排序，接着，把第二项与第一项进行对比，第二项是该插入到第一项之前还是之后，第三项是该插入到第一项之前还是第一项之后还是第三项</span><br><span class="line">// 插入demo:</span><br><span class="line">function insertionSort(arr) &#123;</span><br><span class="line">  let len = arr.length;</span><br><span class="line">  let preIndex, current;</span><br><span class="line">  for (let i = 1; i &lt; len; i++) &#123;</span><br><span class="line">      preIndex = i - 1;</span><br><span class="line">      current = arr[i];</span><br><span class="line">      while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">        arr[preIndex + 1] = arr[preIndex];</span><br><span class="line">        preIndex--;</span><br><span class="line">      &#125;</span><br><span class="line">      arr[preIndex + 1] = current;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 归并排序：Mozilla Firefox 使用归并排序作为Array.prototype.sort的实现，而chrome使用快速排序的一个变体实现的,前面三种算法性能不好，但归并排序性能不错 算法复杂度O(nlog^n)</span><br><span class="line">// 归并排序是一种分治算法。本质上就是把一个原始数组切分成较小的数组，直到每个小数组只有一个位置，接着把小数组归并成较大的数组，在归并过程中也会完成排序，直到最后只有一个排序完毕的大数组</span><br><span class="line">// 归并demo:</span><br><span class="line">function mergeSort(arr) &#123;  //采用自上而下的递归方法</span><br><span class="line">    let len = arr.length;</span><br><span class="line">    if(len &lt; 2) &#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    let middle = Math.floor(len / 2),</span><br><span class="line">    left = arr.slice(0, middle),</span><br><span class="line">    right = arr.slice(middle);</span><br><span class="line">    return merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">function merge(left, right)&#123;</span><br><span class="line">    let result = [];</span><br><span class="line">    while (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">        if (left[0] &lt;= right[0]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(...left);</span><br><span class="line">    result.push(...right);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h5><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//堆排序：堆排序把数组当中二叉树来排序而得名。</span><br><span class="line">// 1）索引0是树的根节点；2）除根节点为，任意节点N的父节点是N/2；3）节点L的左子节点是2*L；4）节点R的右子节点为2*R + 1</span><br><span class="line">// 本质上就是先构建二叉树，然后把根节点与最后一个进行交换，然后对剩下对元素进行二叉树构建，进行交换，直到剩下最后一个</span><br><span class="line">// 堆demo:</span><br><span class="line">var len;    //因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</span><br><span class="line">    </span><br><span class="line">function buildMaxHeap(arr) &#123;   //建立大顶堆</span><br><span class="line">    len = arr.length;</span><br><span class="line">    for (let i = Math.floor(len / 2); i &gt;= 0; i--) &#123;</span><br><span class="line">        heapify(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">function heapify(arr, i) &#123;     //堆调整</span><br><span class="line">    let left = 2 * i + 1;</span><br><span class="line">    let right = 2 * i + 2;</span><br><span class="line">    let largest = i;</span><br><span class="line">    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line">    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line">    if (largest !== i) &#123;</span><br><span class="line">        [arr[i], arr[largest]] = [arr[largest], arr[i]];</span><br><span class="line">        heapify(arr, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">function heapSort(arr) &#123;</span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line">    for (let i = arr.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        [arr[0],arr[i]]=[arr[i],arr[0]];</span><br><span class="line">        len--;</span><br><span class="line">        heapify(arr, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="6-类型转换"><a href="#6-类型转换" class="headerlink" title="6. 类型转换"></a>6. 类型转换</h3><h5 id="转-Boolean"><a href="#转-Boolean" class="headerlink" title="转 Boolean"></a>转 Boolean</h5><pre><code>在条件判断时，除了 undefined， null， false， NaN， &#39;&#39;， 0， -0，其他所有值都转为 true，包括所有对象。
</code></pre>
<h5 id="对象转基本类型"><a href="#对象转基本类型" class="headerlink" title="对象转基本类型"></a>对象转基本类型</h5><pre><code>对象在转换基本类型时，首先会调用 valueOf 然后调用 toString。并且这两个方法你是可以重写的。
  let a = &#123;
    valueOf() &#123;
      return 0
    &#125;
  &#125;
当然你也可以重写 Symbol.toPrimitive ，该方法在转基本类型时调用优先级最高。
  let a = &#123;
    valueOf() &#123;
      return 0;
    &#125;,
    toString() &#123;
      return &#39;1&#39;;
    &#125;,
    [Symbol.toPrimitive]() &#123;
      return 2;
    &#125;
  &#125;
  1 + a // =&gt; 3
  &#39;1&#39; + a // =&gt; &#39;12&#39;
</code></pre>
<h5 id="四则运算符"><a href="#四则运算符" class="headerlink" title="四则运算符"></a>四则运算符</h5><pre><code>只有当加法运算时，其中一方是字符串类型，就会把另一个也转为字符串类型。其他运算只要其中一方是数字，那么另一方就转为数字。并且加法运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串。

1 + &#39;1&#39; // &#39;11&#39;
2 * &#39;2&#39; // 4
[1, 2] + [2, 1] // &#39;1,22,1&#39;
// [1, 2].toString() -&gt; &#39;1,2&#39;
// [2, 1].toString() -&gt; &#39;2,1&#39;
// &#39;1,2&#39; + &#39;2,1&#39; = &#39;1,22,1&#39;
对于加号需要注意这个表达式 &#39;a&#39; + + &#39;b&#39;

&#39;a&#39; + + &#39;b&#39; // -&gt; &quot;aNaN&quot;
// 因为 + &#39;b&#39; -&gt; NaN
// 你也许在一些代码中看到过 + &#39;1&#39; -&gt; 1
</code></pre>
<ol start="4">
<li><p>== 操作符</p>
<p><img src="https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043719.png" alt="avatar"></p>
</li>
</ol>
<h3 id="7-原型"><a href="#7-原型" class="headerlink" title="7. 原型"></a>7. 原型</h3><ul>
<li>每个函数都有 prototype 属性，除了 Function.prototype.bind()，该属性指向原型。</li>
<li>每个对象都有 <strong>proto</strong> 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使用 <em>proto</em> 来访问。</li>
<li>对象可以通过 <strong>proto</strong> 来寻找不属于该对象的属性，<strong>proto</strong> 将对象连接起来组成了原型链。</li>
</ul>
<h3 id="8-new-的过程做了什么"><a href="#8-new-的过程做了什么" class="headerlink" title="8. new 的过程做了什么"></a>8. new 的过程做了什么</h3><ol>
<li><p>新生成了一个对象</p>
</li>
<li><p>链接到原型</p>
</li>
<li><p>绑定 this</p>
</li>
<li><p>返回新对象 5. 隐士返回 this</p>
</li>
<li></li>
</ol>
<h3 id="10-call-apply-bind-区别"><a href="#10-call-apply-bind-区别" class="headerlink" title="10. call, apply, bind 区别"></a>10. call, apply, bind 区别</h3><ul>
<li>call 和 apply 都是为了解决改变 this 的指向。作用都是相同的，只是传参的方式不同。</li>
<li>除了第一个参数外，call 可以接收一个参数列表，apply 只接受一个参数数组。</li>
<li>bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化。</li>
</ul>
<h3 id="11-闭包"><a href="#11-闭包" class="headerlink" title="11. 闭包"></a>11. 闭包</h3><ul>
<li>闭包的定义很简单：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function A() &#123;</span><br><span class="line">  let a = 1</span><br><span class="line">  function B() &#123;</span><br><span class="line">      console.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  return B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么函数 A 已经弹出调用栈了，函数 B 还能引用到函数 A 中的变量。因为函数 A 中的变量这时候是存储在堆上的。现在的 JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。</li>
<li>经典面试题，循环中使用闭包解决 var 定义函数的问题</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">for ( var i=1; i&lt;=5; i++) &#123;</span><br><span class="line">  setTimeout( function timer() &#123;</span><br><span class="line">    console.log( i );</span><br><span class="line">  &#125;, i*1000 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用闭包解决</span><br><span class="line">for (var i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">  (function(j) &#123;</span><br><span class="line">    setTimeout(function timer() &#123;</span><br><span class="line">      console.log(j);</span><br><span class="line">    &#125;, j * 1000);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-深浅拷贝"><a href="#12-深浅拷贝" class="headerlink" title="12. 深浅拷贝"></a>12. 深浅拷贝</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">    age: 1</span><br><span class="line">&#125;</span><br><span class="line">let b = a</span><br><span class="line">a.age = 2</span><br><span class="line">console.log(b.age) // 2</span><br></pre></td></tr></table></figure>

<p>从上述例子中我们可以发现，如果给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。<br>通常在开发中我们不希望出现这样的问题，我们可以使用浅拷贝来解决这个问题。</p>
<h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><pre><code>1. 使用Object.assign
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">    age: 1</span><br><span class="line">&#125;</span><br><span class="line">let b = Object.assign(&#123;&#125;, a)</span><br><span class="line">a.age = 2</span><br><span class="line">console.log(b.age) // 1</span><br></pre></td></tr></table></figure>
2. 使用展开运算符（…）
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">    age: 1</span><br><span class="line">&#125;</span><br><span class="line">let b = &#123;...a&#125;</span><br><span class="line">a.age = 2</span><br><span class="line">console.log(b.age) // 1</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li>通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就需要使用到深拷贝了<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">    age: 1,</span><br><span class="line">    jobs: &#123;</span><br><span class="line">        first: &#x27;FE&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b = &#123;...a&#125;</span><br><span class="line">a.jobs.first = &#x27;native&#x27;</span><br><span class="line">console.log(b.jobs.first) // native</span><br><span class="line">浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到刚开始的话题了，两者享有相同的引用。要解决这个问题，我们需要引入深拷贝</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h5><pre><code>这个问题通常可以通过 JSON.parse(JSON.stringify(object)) 来解决。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let a = &#123;</span><br><span class="line">    age: 1,</span><br><span class="line">    jobs: &#123;</span><br><span class="line">        first: &#x27;FE&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b = JSON.parse(JSON.stringify(a))</span><br><span class="line">a.jobs.first = &#x27;native&#x27;</span><br><span class="line">console.log(b.jobs.first) // FE</span><br></pre></td></tr></table></figure>
但是该方法也是有局限性的：
  - 会忽略 undefined
  - 会忽略 symbol
  - 不能序列化函数
  - 不能解决循环引用的对象

如果遇到这些情况，可以使用递归或者 lodash 的深拷贝函数
</code></pre>
<h3 id="13-防抖"><a href="#13-防抖" class="headerlink" title="13. 防抖"></a>13. 防抖</h3><p>你是否在日常开发中遇到一个问题，在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。</p>
<p>这些需求都可以通过函数防抖动来实现。尤其是第一个需求，如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。</p>
<p>PS：防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于 wait，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数 wait）调用函数。</p>
<p>我们先来看一个袖珍版的防抖理解一下防抖的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// func是用户传入需要防抖的函数</span><br><span class="line">// wait是等待时间</span><br><span class="line">const debounce = (func, wait = 50) =&gt; &#123;</span><br><span class="line">  // 缓存一个定时器id</span><br><span class="line">  let timer = 0</span><br><span class="line">  // 这里返回的函数是每次用户实际调用的防抖函数</span><br><span class="line">  // 如果已经设定过定时器了就清空上一次的定时器</span><br><span class="line">  // 开始一个新的定时器，延迟执行用户传入的方法</span><br><span class="line">  return function(...args) &#123;</span><br><span class="line">    if (timer) clearTimeout(timer)</span><br><span class="line">    timer = setTimeout(() =&gt; &#123;</span><br><span class="line">      func.apply(this, args)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 不难看出如果用户调用该函数的间隔小于wait的情况下，上一次的时间还未到就被清除了，并不会执行函数</span><br></pre></td></tr></table></figure>

<p>这是一个简单版的防抖，但是有缺陷，这个防抖只能在最后调用。一般的防抖会有 immediate 选项，表示是否立即调用。这两者的区别，举个栗子来说：</p>
<ul>
<li>例如在搜索引擎搜索问题的时候，我们当然是希望用户输入完最后一个字才调用查询接口，这个时候适用延迟执行的防抖函数，它总是在一连串（间隔小于 wait 的）函数触发之后调用。</li>
<li>例如用户给 interviewMap 点 star 的时候，我们希望用户点第一下的时候就去调用接口，并且成功之后改变 star 按钮的样子，用户就可以立马得到反馈是否 star 成功了，这个情况适用立即执行的防抖函数，它总是在第一次调用，并且下一次调用必须与前一次调用的时间间隔大于 wait 才会触发。</li>
</ul>
<p>下面我们来实现一个带有立即执行选项的防抖函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 这个是用来获取当前时间戳的</span><br><span class="line">function now() &#123;</span><br><span class="line">  return +new Date()</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line">* 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行</span><br><span class="line">*</span><br><span class="line">* @param  &#123;function&#125; func        回调函数</span><br><span class="line">* @param  &#123;number&#125;   wait        表示时间窗口的间隔</span><br><span class="line">* @param  &#123;boolean&#125;  immediate   设置为ture时，是否立即调用函数</span><br><span class="line">* @return &#123;function&#125;             返回客户调用函数</span><br><span class="line">*/</span><br><span class="line">function debounce (func, wait = 50, immediate = true) &#123;</span><br><span class="line">  let timer, context, args</span><br><span class="line"></span><br><span class="line">  // 延迟执行函数</span><br><span class="line">  const later = () =&gt; setTimeout(() =&gt; &#123;</span><br><span class="line">    // 延迟函数执行完毕，清空缓存的定时器序号</span><br><span class="line">    timer = null</span><br><span class="line">    // 延迟执行的情况下，函数会在延迟函数中执行</span><br><span class="line">    // 使用到之前缓存的参数和上下文</span><br><span class="line">    if (!immediate) &#123;</span><br><span class="line">      func.apply(context, args)</span><br><span class="line">      context = args = null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, wait)</span><br><span class="line"></span><br><span class="line">  // 这里返回的函数是每次实际调用的函数</span><br><span class="line">  return function(...params) &#123;</span><br><span class="line">    // 如果没有创建延迟执行函数（later），就创建一个</span><br><span class="line">    if (!timer) &#123;</span><br><span class="line">      timer = later()</span><br><span class="line">      // 如果是立即执行，调用函数</span><br><span class="line">      // 否则缓存参数和调用上下文</span><br><span class="line">      if (immediate) &#123;</span><br><span class="line">        func.apply(this, params)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        context = this</span><br><span class="line">        args = params</span><br><span class="line">      &#125;</span><br><span class="line">    // 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个</span><br><span class="line">    // 这样做延迟函数会重新计时</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">      timer = later()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体函数实现的不难，总结一下。</p>
<ul>
<li>对于按钮防点击来说的实现：如果函数是立即执行的，就立即调用，如果函数是延迟执行的，就缓存上下文和参数，放到延迟函数中去执行。一旦我开始一个定时器，只要我定时器还在，你每次点击我都重新计时。一旦你点累了，定时器时间到，定时器重置为 null，就可以再次点击了。</li>
<li>对于延时执行函数来说的实现：清除定时器 ID，如果是延迟调用就调用函数</li>
</ul>
<h3 id="14-节流"><a href="#14-节流" class="headerlink" title="14. 节流"></a>14. 节流</h3><p>防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait</span><br><span class="line">*</span><br><span class="line">* @param  &#123;function&#125;   func      回调函数</span><br><span class="line">* @param  &#123;number&#125;     wait      表示时间窗口的间隔</span><br><span class="line">* @param  &#123;object&#125;     options   如果想忽略开始函数的的调用，传入&#123;leading: false&#125;。</span><br><span class="line">*                                如果想忽略结尾函数的调用，传入&#123;trailing: false&#125;</span><br><span class="line">*                                两者不能共存，否则函数不能执行</span><br><span class="line">* @return &#123;function&#125;             返回客户调用函数</span><br><span class="line">*/</span><br><span class="line">_.throttle = function(func, wait, options) &#123;</span><br><span class="line">    var context, args, result;</span><br><span class="line">    var timeout = null;</span><br><span class="line">    // 之前的时间戳</span><br><span class="line">    var previous = 0;</span><br><span class="line">    // 如果 options 没传则设为空对象</span><br><span class="line">    if (!options) options = &#123;&#125;;</span><br><span class="line">    // 定时器回调函数</span><br><span class="line">    var later = function() &#123;</span><br><span class="line">      // 如果设置了 leading，就将 previous 设为 0</span><br><span class="line">      // 用于下面函数的第一个 if 判断</span><br><span class="line">      previous = options.leading === false ? 0 : _.now();</span><br><span class="line">      // 置空一是为了防止内存泄漏，二是为了下面的定时器判断</span><br><span class="line">      timeout = null;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      if (!timeout) context = args = null;</span><br><span class="line">    &#125;;</span><br><span class="line">    return function() &#123;</span><br><span class="line">      // 获得当前时间戳</span><br><span class="line">      var now = _.now();</span><br><span class="line">      // 首次进入前者肯定为 true</span><br><span class="line">    // 如果需要第一次不执行函数</span><br><span class="line">    // 就将上次时间戳设为当前的</span><br><span class="line">      // 这样在接下来计算 remaining 的值时会大于0</span><br><span class="line">      if (!previous &amp;&amp; options.leading === false) previous = now;</span><br><span class="line">      // 计算剩余时间</span><br><span class="line">      var remaining = wait - (now - previous);</span><br><span class="line">      context = this;</span><br><span class="line">      args = arguments;</span><br><span class="line">      // 如果当前调用已经大于上次调用时间 + wait</span><br><span class="line">      // 或者用户手动调了时间</span><br><span class="line">    // 如果设置了 trailing，只会进入这个条件</span><br><span class="line">    // 如果没有设置 leading，那么第一次会进入这个条件</span><br><span class="line">    // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了</span><br><span class="line">    // 其实还是会进入的，因为定时器的延时</span><br><span class="line">    // 并不是准确的时间，很可能你设置了2秒</span><br><span class="line">    // 但是他需要2.2秒才触发，这时候就会进入这个条件</span><br><span class="line">      if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class="line">        // 如果存在定时器就清理掉否则会调用二次回调</span><br><span class="line">        if (timeout) &#123;</span><br><span class="line">          clearTimeout(timeout);</span><br><span class="line">          timeout = null;</span><br><span class="line">        &#125;</span><br><span class="line">        previous = now;</span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        if (!timeout) context = args = null;</span><br><span class="line">      &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class="line">        // 判断是否设置了定时器和 trailing</span><br><span class="line">      // 没有的话就开启一个定时器</span><br><span class="line">        // 并且不能不能同时设置 leading 和 trailing</span><br><span class="line">        timeout = setTimeout(later, remaining);</span><br><span class="line">      &#125;</span><br><span class="line">      return result;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="15-Promise"><a href="#15-Promise" class="headerlink" title="15. Promise"></a>15. Promise</h3><p>Promise 是 ES6 新增的语法，解决了回调地狱的问题。</p>
<p>可以把 Promise 看成一个状态机。初始是 pending 状态，可以通过函数 resolve 和 reject ，将状态转变为 resolved 或者 rejected 状态，状态一旦改变就不能再次变化。</p>
<p>then 函数会返回一个 Promise 实例，并且该返回值是一个新的实例而不是之前的实例。因为 Promise 规范规定除了 pending 状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个 then 调用就失去意义了。</p>
<p>Promise 还拥有很多的 api： - then - catch - all - race - finally</p>
<h3 id="16-async-和-await"><a href="#16-async-和-await" class="headerlink" title="16. async 和 await"></a>16. async 和 await</h3><p>一个函数如果加上 async ，那么该函数就会返回一个 Promise</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async function test() &#123;</span><br><span class="line">  return &quot;1&quot;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(test()); // -&gt; Promise &#123;&lt;resolved&gt;: &quot;1&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>可以把 async 看成将函数返回值使用 Promise.resolve() 包裹了下。</p>
<p>await 只能在 async 函数中使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function sleep() &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(&#x27;finish&#x27;)</span><br><span class="line">      resolve(&quot;sleep&quot;);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">async function test() &#123;</span><br><span class="line">  let value = await sleep();</span><br><span class="line">  console.log(&quot;object&quot;);</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<p>上面代码会先打印 finish 然后再打印 object 。因为 await 会等待 sleep 函数 resolve ，所以即使后面是同步代码，也不会先去执行同步代码再来执行异步代码。</p>
<p>async 和 await 相比直接使用 Promise 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码。缺点在于滥用 await 可能会导致性能问题，因为 await 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性。</p>
<p>下面来看一个使用 await 的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = 0</span><br><span class="line">var b = async () =&gt; &#123;</span><br><span class="line">  a = a + await 10</span><br><span class="line">  console.log(&#x27;2&#x27;, a) // -&gt; &#x27;2&#x27; 10</span><br><span class="line">  a = (await 10) + a</span><br><span class="line">  console.log(&#x27;3&#x27;, a) // -&gt; &#x27;3&#x27; 20</span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line">a++</span><br><span class="line">console.log(&#x27;1&#x27;, a) // -&gt; &#x27;1&#x27; 1</span><br></pre></td></tr></table></figure>

<p>对于以上代码你可能会有疑惑，这里说明下原理</p>
<ul>
<li>首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为在 await 内部实现了 generators ，generators 会保留堆栈中东西，所以这时候 a = 0 被保存了下来</li>
<li>因为 await 是异步操作，遇到 await 就会立即返回一个 pending 状态的 Promise 对象，暂时返回执行代码的控制权，使得函数外的代码得以继续执行，所以会先执行 console.log(‘1’, a)</li>
<li>这时候同步代码执行完毕，开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 10</li>
<li>然后后面就是常规执行代码了</li>
</ul>
<h3 id="17-解构"><a href="#17-解构" class="headerlink" title="17. 解构"></a>17. 解构</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。<br>举例： - let a = 1; let b = 2; [b, a] = [a, b]; - import {Component} from ‘react’ - import {getTableData} from ‘../api.js’ - getTableData().then(res =&gt; {let { data } = res})</p>
<h3 id="18-箭头函数"><a href="#18-箭头函数" class="headerlink" title="18. 箭头函数"></a>18. 箭头函数</h3><ol>
<li><p>写法简单</p>
<p>省略 function 关键字，如果只有一个参数可以省略小括号，代码块只有一条语句，可以省略大括号，省略大括号还有自动 return 的作用，等等</p>
</li>
<li><p>this 指向更加明确</p>
<p>箭头函数的 this 指向的是它外面的第一个不是箭头函数的函数的 this</p>
</li>
</ol>
<h3 id="19-Set"><a href="#19-Set" class="headerlink" title="19. Set"></a>19. Set</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值，所以 Set 方法一般用来数组去重</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr = [2, 3, 3, 4, 6, 5, 3, 4, 4];</span><br><span class="line">let arr2 = [...new Set(arr)];</span><br></pre></td></tr></table></figure>

<p>这里 new Set 出来的不是真正的数组，所以需要用到…扩展运算符</p>
<h3 id="20-高阶函数"><a href="#20-高阶函数" class="headerlink" title="20. 高阶函数"></a>20. 高阶函数</h3><ul>
<li>foreach</li>
<li>map</li>
<li>some</li>
<li>filter</li>
<li>every</li>
<li>reduce</li>
</ul>
<h3 id="21-V8-下的垃圾回收机制"><a href="#21-V8-下的垃圾回收机制" class="headerlink" title="21. V8 下的垃圾回收机制"></a>21. V8 下的垃圾回收机制</h3><p>V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。</p>
<h5 id="新生代算法"><a href="#新生代算法" class="headerlink" title="新生代算法"></a>新生代算法</h5><pre><code>新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。

在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。
</code></pre>
<h5 id="老生代算法"><a href="#老生代算法" class="headerlink" title="老生代算法"></a>老生代算法</h5><pre><code>老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。
在讲算法前，先来说下什么情况下对象会出现在老生代空间中：
- 新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。
- To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。

在老生代中，以下情况会先启动标记清除算法：
- 某一个空间没有分块的时候
- 空间中被对象超过一定限制
- 空间不能保证新生代中的对象移动到老生代中
</code></pre>
<h3 id="22-eventloop"><a href="#22-eventloop" class="headerlink" title="22. eventloop"></a>22. eventloop</h3><ul>
<li>见 ppt</li>
</ul>
<h3 id="23-事件机制"><a href="#23-事件机制" class="headerlink" title="23. 事件机制"></a>23. 事件机制</h3><h5 id="事件触发三阶段"><a href="#事件触发三阶段" class="headerlink" title="事件触发三阶段"></a>事件触发三阶段</h5><pre><code>- window 往事件触发处传播，遇到注册的捕获事件会触发
- 传播到事件触发处时触发注册的事件
- 从事件触发处往 window 传播，遇到注册的冒泡事件会触发
</code></pre>
<h5 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h5><pre><code>通常我们使用 addEventListener 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false 。useCapture 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性

- capture，布尔值，和 useCapture 作用一样
- once，布尔值，值为 true 表示该回调只会调用一次，调用后会移除监听
- passive，布尔值，表示永远不会调用 preventDefault

一般来说，我们只希望事件只触发在目标上，这时候可以使用 stopPropagation 来阻止事件的进一步传播。通常我们认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。stopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。
</code></pre>
<h5 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h5><pre><code>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上
&lt;ul id=&quot;ul&quot;&gt;
  &lt;li&gt;1&lt;/li&gt;
  &lt;li&gt;2&lt;/li&gt;
  &lt;li&gt;3&lt;/li&gt;
  &lt;li&gt;4&lt;/li&gt;
  &lt;li&gt;5&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
  let ul = document.querySelector(&#39;##ul&#39;)
  ul.addEventListener(&#39;click&#39;, event =&gt; &#123;
    console.log(event.target)
  &#125;)
&lt;/script&gt;
事件代理的方式相对于直接给目标注册事件来说，有以下优点

- 节省内存
- 不需要给子节点注销事件
</code></pre>
<h3 id="24-跨域"><a href="#24-跨域" class="headerlink" title="24. 跨域"></a>24. 跨域</h3><p>因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败。<br>我们可以通过以下几种常用方法解决跨域的问题</p>
<h5 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h5><pre><code>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。

浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。

服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源
</code></pre>
<h5 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h5><pre><code>该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。

只需要给页面添加 document.domain = &#39;test.com&#39; 表示二级域名都相同就可以实现跨域
</code></pre>
<h5 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h5><pre><code>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息
</code></pre>
<h3 id="25-模块化"><a href="#25-模块化" class="headerlink" title="25. 模块化"></a>25. 模块化</h3><p>在有 Babel 的情况下，我们可以直接使用 ES6 的模块化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// file a.js</span><br><span class="line">export function a() &#123;&#125;</span><br><span class="line">export function b() &#123;&#125;</span><br><span class="line">// file b.js</span><br><span class="line">export default function() &#123;&#125;</span><br><span class="line"></span><br><span class="line">import &#123;a, b&#125; from &#x27;./a.js&#x27;</span><br><span class="line">import XXX from &#x27;./b.js&#x27;</span><br></pre></td></tr></table></figure>

<h5 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h5><pre><code>CommonJs 是 Node 独有的规范，浏览器中使用就需要用到 Browserify 解析了。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// a.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    a: 1</span><br><span class="line">&#125;</span><br><span class="line">// or</span><br><span class="line">exports.a = 1</span><br><span class="line">    </span><br><span class="line">// b.js</span><br><span class="line">var module = require(&#x27;./a.js&#x27;)</span><br><span class="line">module.a // -&gt; log 1</span><br></pre></td></tr></table></figure>
在上述代码中，module.exports 和 exports 很容易混淆，让我们来看看大致内部实现
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var module = require(&#x27;./a.js&#x27;)</span><br><span class="line">module.a</span><br><span class="line">// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，</span><br><span class="line">// 重要的是 module 这里，module 是 Node 独有的一个变量</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    a: 1</span><br><span class="line">&#125;</span><br><span class="line">// 基本实现</span><br><span class="line">var module = &#123;</span><br><span class="line">  exports: &#123;&#125; // exports 就是个空对象</span><br><span class="line">&#125;</span><br><span class="line">// 这个是为什么 exports 和 module.exports 用法相似的原因</span><br><span class="line">var exports = module.exports</span><br><span class="line">var load = function (module) &#123;</span><br><span class="line">    // 导出的东西</span><br><span class="line">    var a = 1</span><br><span class="line">    module.exports = a</span><br><span class="line">    return module.exports</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
再来说说 module.exports 和 exports，用法其实是相似的，但是不能对 exports 直接赋值，不会有任何效果。

对于 CommonJS 和 ES6 中的模块化的两者区别是：

- 前者支持动态导入，也就是 require($&#123;path&#125;/xx.js)，后者目前不支持，但是已有提案

- 前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响

- 前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化

- 后者会编译成 require/exports 来执行的
</code></pre>
<h5 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h5><pre><code>AMD 是由 RequireJS 提出的

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// AMD</span><br><span class="line">define([&#x27;./a&#x27;, &#x27;./b&#x27;], function(a, b) &#123;</span><br><span class="line">    a.do()</span><br><span class="line">    b.do()</span><br><span class="line">&#125;)</span><br><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">    var a = require(&#x27;./a&#x27;)</span><br><span class="line">    a.doSomething()</span><br><span class="line">    var b = require(&#x27;./b&#x27;)</span><br><span class="line">    b.doSomething()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="# 逻辑运算符"></a># 逻辑运算符</h2><ol>
<li>逻辑运算符 1.逻辑与 - and - &amp;&amp;<br> 逻辑与运算符和符号两边的操作数有关系。<br> 两边的操作数转换成布尔值，结果不一定是布尔值。<br> 规则：目标是符号两边的操作数都要为真。<br> 如果第一个操作数为真，结果一定是第二个操作数。<br> 如果第一个操作数为假，结果就是第一个操作数，跳过第二个操作数(短路操作)<br> 总结：逻辑与碰到操作数为假，结束了。</li>
</ol>
<figure class="highlight plaintext"><figcaption><span>&& 4); 4</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">console.log(4 &amp;&amp; 0); 0</span><br><span class="line">console.log(0 &amp;&amp; 呵呵呵呵呵呵); 0  短路操作</span><br><span class="line">console.log(0 &amp;&amp; false); 0 短路操作</span><br><span class="line">console.log(&#x27;&#x27; &amp;&amp; 0); &#x27;&#x27;</span><br><span class="line"></span><br><span class="line">console.log(&#x27;hello&#x27; &amp;&amp; 100); 100</span><br><span class="line">console.log(&#x27;hello&#x27; &amp;&amp; false); false</span><br><span class="line"></span><br><span class="line">console.log(2 &amp;&amp; 3 &amp;&amp; 0 &amp;&amp; 4); 0</span><br><span class="line">console.log(2 &amp;&amp; 3 &amp;&amp; 4 &amp;&amp; 5); 5</span><br><span class="line">console.log(false &amp;&amp; 3 &amp;&amp; 4 &amp;&amp; 5); false</span><br><span class="line">console.log(true &amp;&amp; undefined &amp;&amp; null); undefined</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>逻辑或 - or - ||<br> 逻辑或运算符和符号两边的操作数有关系。<br> 两边的操作数转换成布尔值，结果不一定是布尔值。<br> 规则：目标是符号两边的操作数有一个为真即可。</p>
<p> 如果第一个操作数为假，结果一定是第二个操作数。<br> 如果第一个操作数为真，结果就是第一个操作数，跳过第二个操作数(短路操作)<br> 总结：逻辑或碰到操作数为真，结束了。</p>
</li>
</ol>
<figure class="highlight plaintext"><figcaption><span>|| 2);1</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(1 || 哈哈哈哈);1</span><br><span class="line">console.log(false || 1);1</span><br><span class="line">console.log(false || 0 || &#x27;&#x27;);&#x27;&#x27;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>逻辑非 - not - ! - 取反<br> 逻辑非的结果一定是布尔值。取代前面 Boolean()<br> 先将当前的值转换成布尔值，然后取反。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(!!3);true</span><br><span class="line">console.log(!!!!!!!3);false</span><br></pre></td></tr></table></figure>

<h1 id="循环的嵌套面试题"><a href="#循环的嵌套面试题" class="headerlink" title="循环的嵌套面试题"></a>循环的嵌套面试题</h1><ol>
<li>金典的面试题 - 循环的嵌套。<br> 100 块钱买 100 只鸡，列出有多少种买法。<br> 母鸡：5 元一只 i 只<br> 公鸡：3 元一只 j 只<br> 小鸡：1 元三只 k 只</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">i+j+k === 100只</span><br><span class="line">i*5 + j*3 + k/3 === 100只</span><br><span class="line"> console.time(&#x27;timename&#x27;);</span><br><span class="line"> for (var i = 0; i &lt;= 20; i++) &#123;</span><br><span class="line">     for (var j = 0; j &lt;= 33; j++) &#123;</span><br><span class="line">         for (var k = 0; k &lt;= 100; k++) &#123;</span><br><span class="line">             if (i + j + k === 100 &amp;&amp; i * 5 + j * 3 + k / 3 === 100) &#123;</span><br><span class="line">                 document.write(&#x27;你可以买&#x27; + i + &#x27;只母鸡，&#x27; + j + &#x27;只公鸡，&#x27; + k + &#x27;只小鸡&#x27; + &#x27;&lt;br&gt;&#x27;);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> console.timeEnd(&#x27;timename&#x27;);</span><br><span class="line">通过console.time(自定义的标记) console.timeEnd(自定义的标记)计算代码执行的时间。括号里面的标记值要一致。</span><br></pre></td></tr></table></figure>

<h1 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h1><ol>
<li><p>作用域链 - 内-外<br> 通俗地讲，当声明一个函数时，局部作用域一级一级向上包起来，就是作用域链。<br> 当执行函数时，总是先从函数内部找寻局部变量,如果内部找不到（函数的局部作用域没有），则会向上一级继续查找，一直找到最外面。<br> 在函数体内，局部变量的优先级高于同名的全局变量-作用域链。</p>
</li>
<li><p>作用域的特殊性<br> 如何函数内部的变量，声明变量的时候，忘记了添加 var，不但不报错，反而会将此变量当做全局变量。<br> function fn() {<br> a = 1; 声明变量，没有 var 关键字，改变变量的作用域。变成全局<br> JS 的编译和执行</p>
</li>
<li><p>JS 的解析过程分为两个阶段：预编译期(预处理)与执行期。<br> 第一步：预编译期(预处理) - 代码进入浏览器逐行执行之前干的事情。</p>
<ul>
<li>先找 var 和 function 关键字，如果找到 var 关键字，提前赋值 undefined 给变量名称.如果找到 function，提前将整个函数赋值给函数名称。</li>
<li>如果变量名和函数名重名了，函数名优先(函数名会覆盖变量名，变量名不存在了);</li>
<li>函数的参数类似于变量，函数内部同样做预编译，支持预编译。</li>
<li>if 语句和 for 语句里面的变量和函数做预解析提前赋值 undefined,函数声明不会跳过。 - 少见(尽量不要在 if 语句和 for 语句里面使用函数)</li>
</ul>
<p> 第二步：逐行执行，根据代码的顺序执行代码，遇到错误终止。(函数声明跳过).</p>
</li>
<li><p>JS 的解析过程分为两个阶段：预编译期(预处理)与执行期。<br> 第一阶段(预编译期)：<br> 找 var 和 function 关键字，如果找到 var 关键字，提前赋值 undefined 给变量名. 如果找到 function，提前将整个函数赋值给函数名称<br> 如果函数和变量出现重名，函数优先。<br> 函数的参数类似于变量，函数内部同样做预解析，支持预解析。<br> if 语句和 for 语句里面的变量和函数做预解析提前赋值 undefined,函数声明不会跳过。</p>
<p> 第二阶段(执行期)：在编译后的基础上开始从上到下执行脚本，遇到错误时中断。<br> 正常情况下(排除 if、for)， 普通函数声明跳过， 变量声明未初始化跳过(var a)。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"> 预编译后的结果：</span><br><span class="line"> function a() &#123;alert(5);&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> alert(a); function a() &#123;alert(5);&#125;</span><br><span class="line"> a(); 5</span><br><span class="line"> var a = 3;</span><br><span class="line"></span><br><span class="line"> function a() &#123;</span><br><span class="line">     alert(10);</span><br><span class="line"> &#125;</span><br><span class="line"> alert(a); 3</span><br><span class="line"></span><br><span class="line"> function a() &#123;</span><br><span class="line">     alert(5);</span><br><span class="line"> &#125;</span><br><span class="line"> a = 6;</span><br><span class="line"> alert(a); 6</span><br><span class="line"> var a = function() &#123;</span><br><span class="line">     alert(8);</span><br><span class="line"> &#125;</span><br><span class="line"> a(); 8</span><br><span class="line">预编译的结果：</span><br><span class="line">var b = undefined</span><br><span class="line"> function a(b) &#123; var b = 100</span><br><span class="line">     console.log(b); 100</span><br><span class="line">     var b = 1;</span><br><span class="line">     console.log(b); 1</span><br><span class="line"> &#125;</span><br><span class="line"> a(100)</span><br><span class="line">预编译的结果：</span><br><span class="line"> var b = undefined</span><br><span class="line"> function a(b) &#123; var b = 100   里面没有函数，这里先执行(预编译结果是变量)</span><br><span class="line">     var b;</span><br><span class="line">     console.log(b); 100</span><br><span class="line">     b = 1;</span><br><span class="line">     console.log(b); 1</span><br><span class="line"> &#125;</span><br><span class="line"> a(100)</span><br><span class="line"></span><br><span class="line">预编译的结果：</span><br><span class="line">b =  function b() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">总结：如果函数内部预编译的结果是函数优先，内部的函数提升到可见的代码的第一行</span><br><span class="line"> function a(b) &#123; 这里是形参，相当于 var b = 100 ，自己理解的，不可见</span><br><span class="line">     函数提升到这里， function b() &#123;&#125;</span><br><span class="line">     console.log(b);</span><br><span class="line">     b = 1;</span><br><span class="line"></span><br><span class="line">     function b() &#123;&#125;; 这里的函数提升</span><br><span class="line">     console.log(b);</span><br><span class="line"> &#125;</span><br><span class="line"> a(100)</span><br><span class="line"></span><br><span class="line"> var a = 10;</span><br><span class="line"></span><br><span class="line"> function fn(a) &#123;</span><br><span class="line">     函数提升到这里， function a() &#123;&#125;</span><br><span class="line">     console.log(a);</span><br><span class="line"></span><br><span class="line">     function a() &#123;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> fn(a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">预编译的结果：</span><br><span class="line">a = undefined - a函数再if语句里面</span><br><span class="line">b = undefined - 变量提升</span><br><span class="line">c = undefined - c函数再if语句里面</span><br><span class="line">d = undefined - 变量提升</span><br><span class="line"> function fn() &#123;</span><br><span class="line">     console.log(a); undefined</span><br><span class="line">     console.log(b); undefined</span><br><span class="line">     console.log(c); undefined</span><br><span class="line">     console.log(d); undefined</span><br><span class="line">     if (false) &#123; 逐行执行跳过，预编译要做的。</span><br><span class="line">         function a() &#123;&#125;;</span><br><span class="line">         var b = 1;</span><br><span class="line">     &#125;</span><br><span class="line">     if (true) &#123;</span><br><span class="line">         function c() &#123;&#125;;</span><br><span class="line">         var d = 1;</span><br><span class="line">     &#125;</span><br><span class="line">     console.log(a); undefined</span><br><span class="line">     console.log(b); undefined</span><br><span class="line">     console.log(c);  function c() &#123;&#125;;</span><br><span class="line">     console.log(d);  1</span><br><span class="line"> &#125;</span><br><span class="line"> fn()</span><br></pre></td></tr></table></figure>

<h1 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h1><ol>
<li>递归函数<br>递归函数是在一个函数通过名字调用自身情况下构成的<br>递归函数就函数内部调用函数本身</li>
<li>递归：<br>递:传递，递进…..。<br>归:回来，基点…..。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">案例：求阶乘</span><br><span class="line">5!=5*4*3*2*1 = 5*4!</span><br><span class="line">4!=4*3*2*1 = 4*3!</span><br><span class="line">3!=3*2*4 = 3*2!</span><br><span class="line">2!=2*1 = 2*1!</span><br><span class="line">1!=1; -- 归</span><br><span class="line"></span><br><span class="line">计算任意数的阶乘。</span><br><span class="line"> function jc(n) &#123; n=5</span><br><span class="line">     return n * jc(n - 1); Maximum call stack size exceeded栈溢出(内存有堆和栈组成)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> console.log(jc(5));</span><br><span class="line"></span><br><span class="line">解决：设置基点。</span><br><span class="line"> function jc(n) &#123; n=5</span><br><span class="line">     if (n === 1) &#123; 设置基点，归的值。</span><br><span class="line">         return 1;</span><br><span class="line">     &#125;</span><br><span class="line">     return n * jc(n - 1); 5*4!  4*3!  3*2!  2*1!</span><br><span class="line"> &#125;</span><br><span class="line"> console.log(jc(5)); 120</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">利用递归求斐波那契数列的前20项。（递归）</span><br><span class="line">前面两项的和等于第三项。(F(n)=F(n - 1)+F(n - 2)（n ≥ 2，n ∈ N*）)</span><br><span class="line">这个数列从第3项开始，每一项都等于前两项之和。</span><br><span class="line">0,1,1,2,3,5,8,13,21......</span><br><span class="line"></span><br><span class="line"> function feibo(n) &#123; n:第几项，第20项。</span><br><span class="line">     if (n === 1) &#123; 设置基点，归的值。</span><br><span class="line">         return 0;</span><br><span class="line">     &#125;</span><br><span class="line">     if (n === 2) &#123; 设置基点，归的值。</span><br><span class="line">         return 1;</span><br><span class="line">     &#125;</span><br><span class="line">     return feibo(n - 1) + feibo(n - 2);</span><br><span class="line"> &#125;</span><br><span class="line"> console.log(feibo(20)); 4181</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">编写一个函数,输入n为偶数时,调用函数求1/2+1/4+1/6...+1/n,当输入n为奇数时,调用函数求 1+1/3+1/5...+1/n.</span><br><span class="line">function calc(n) &#123;</span><br><span class="line">    if (n === 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (n === 2) &#123;</span><br><span class="line">        return 1 / 2;</span><br><span class="line">    &#125;</span><br><span class="line">    return calc(n - 2) + 1 / n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> console.log(calc(6));</span><br><span class="line"> console.log(calc(5));</span><br><span class="line"> console.log(calc(4));</span><br><span class="line"> console.log(calc(3));</span><br><span class="line"></span><br><span class="line">n = 6   1/2+1/4+1/6  =&gt; calc(4)+1/6  =&gt; calc(n-2)+1/n</span><br><span class="line">n = 5   1+1/3+1/5 =&gt; clac(3)+1/5 =&gt; calc(n-2)+1/n</span><br><span class="line">n = 4   1/2+1/4 =&gt;  calc(2)+1/4  =&gt; calc(n-2)+1/n</span><br><span class="line">n = 3   1+1/3  =&gt; calc(1)+1/3 =&gt; calc(n-2)+1/n</span><br><span class="line"></span><br><span class="line">基点：calc(1)=&gt;1   calc(2)=&gt;1/2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">利用递归求两个数字的最大公约数和最小公倍数(最小公倍数的算法，是两个数的乘积除以最大公约数)（递归）</span><br><span class="line">最大公因数，也称最大公约数、最大公因子，指两个或多个整数共有约数中最大的一个</span><br><span class="line">两个或多个整数公有的倍数叫做它们的公倍数</span><br><span class="line"> (12, 24) =&gt; 12;</span><br><span class="line"> (12, 24) =&gt; 24;</span><br><span class="line"></span><br><span class="line">function fn1(m, n) &#123; 辗转相除法。</span><br><span class="line">    var r = m % n;</span><br><span class="line">    m = n;</span><br><span class="line">    n = r;</span><br><span class="line">    if (r === 0) &#123;</span><br><span class="line">        return m;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return fn1(m, n); 递归</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> console.log(fn1(12, 24));</span><br><span class="line"> console.log(fn1(3, 8)); 1</span><br><span class="line"></span><br><span class="line">最小公倍数:和递归没有关系。是两个数的乘积除以最大公约数</span><br><span class="line">function fn2(m, n) &#123;</span><br><span class="line">    return (m * n) / fn1(m, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> console.log(fn2(12, 24)); 24</span><br><span class="line"></span><br><span class="line">console.log(fn2(3, 8)); 24</span><br></pre></td></tr></table></figure>

<h1 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h1><ol>
<li> push() 可以接收任意数量的参数， 把它们逐个添加到数组末尾， 并返回修改后数组的长度。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&#x27;start&#x27;];</span><br><span class="line">console.log(arr.push(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));  并返回修改后数组的长度 11</span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line">for (var i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">    arr.push(i * 2);</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li> pop() 从数组末尾移除最后一项， 减少数组的 length 值， 然后返回移除的项。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> var arr = [1, 2, 3, 4, 5];</span><br><span class="line"> console.log(arr.pop()); 5</span><br><span class="line"> console.log(arr.pop()); 4</span><br><span class="line"> console.log(arr.pop()); 3</span><br><span class="line"> console.log(arr);</span><br><span class="line"></span><br><span class="line">清空一个数组，三种方式。</span><br><span class="line"> arr = []; 替换</span><br><span class="line"> arr.length = 0;设置length</span><br><span class="line"> console.log(arr);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>unshift() 可以接收任意数量的参数， 把它们逐个添加到数组前面， 并返回修改后数组的长度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&#x27;ending&#x27;];</span><br><span class="line">console.log(arr.unshift(1, 2, 3, 4, 5)); 6</span><br><span class="line">console.log(arr); [1, 2, 3, 4, 5,&#x27;ending&#x27;];</span><br></pre></td></tr></table></figure></li>
<li><p>shift() 从数组前面移除一项， 减少数组的 length 值， 然后返回移除的项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(arr.shift());1</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure></li>
<li><p>reverse() 方法会反转数组项的顺序.</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5];</span><br><span class="line">console.log(arr.reverse()); [5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>sort() 方法按字母表升序排列数组项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">unicode编码  0-9 48-57   A-Z 65-90  a-z 97-122</span><br><span class="line">var arr = [&#x27;pear&#x27;, &#x27;banana&#x27;, &#x27;apple&#x27;, &#x27;orange&#x27;];</span><br><span class="line">console.log(arr.sort());  [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;pear&quot;]</span><br><span class="line">var arrnum = [2, 5, 8, 9, 6, 3, 4, 1, 7];</span><br><span class="line">console.log(arrnum.sort()); [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">console.log(&#x27;--------------------------------------------&#x27;);</span><br><span class="line">var arrnum = [200, 51, 81, 91, 6, 3, 4, 1000, 7];</span><br><span class="line">console.log(arrnum.sort());  [1000,200,3,4]</span><br><span class="line">console.log(arrnum.sort(compare2));</span><br><span class="line">console.log(arrnum.sort(function(a, b) &#123;</span><br><span class="line">    return a - b</span><br><span class="line">&#125;));</span><br><span class="line">console.log(arrnum.sort(function(a, b) &#123;</span><br><span class="line">    return b - a</span><br><span class="line">&#125;));</span><br><span class="line">如果按其他方式而非字母表顺序进行数组排列，必须给sort方法传递一个比较函数做参数。</span><br><span class="line">function compare2(a, b) &#123;</span><br><span class="line">    return b - a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>concat() 方可以基于当前数组中的所有项创建一个新数组，参数可以是数组项或者数组。不改变原数组</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&#x27;hello&#x27;, &#x27;hi&#x27;];</span><br><span class="line">var newarr = arr.concat(); 将当前的数组拷贝了一份。</span><br><span class="line">var newarr1 = arr.concat(1, 2, 3, 4, 5);</span><br><span class="line">var newarr2 = arr.concat(1, 2, 3, 4, 5, arr);</span><br><span class="line">var newarr3 = arr.concat(1, 2, 3, 4, 5, arr, &#x27;zhangsan&#x27;, &#x27;lisi&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(arr); [&#x27;hello&#x27;, &#x27;hi&#x27;]</span><br><span class="line">console.log(newarr); [&#x27;hello&#x27;, &#x27;hi&#x27;]</span><br><span class="line">console.log(newarr1); [&quot;hello&quot;, &quot;hi&quot;, 1, 2, 3, 4, 5]</span><br><span class="line">console.log(newarr2); [&quot;hello&quot;, &quot;hi&quot;, 1, 2, 3, 4, 5,&quot;hello&quot;, &quot;hi&quot;]</span><br><span class="line">console.log(newarr3); [&quot;hello&quot;, &quot;hi&quot;, 1, 2, 3, 4, 5,&quot;hello&quot;, &quot;hi&quot;,&#x27;zhangsan&#x27;, &#x27;lisi&#x27;]</span><br><span class="line">console.log(arr.concat(arr, arr, arr, arr));]</span><br><span class="line">应用：拼接数组项 + 数组值的拷贝 + 数组的扁平化(多维数组转一维)</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><p>slice() 方法它能够基于当前数组中的一或多个项创建一个新数组。可以接受一或两个参数，即要返回项的起始和结束位置，不包括结束位置。</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;];</span><br><span class="line">console.log(arr.slice()); 全部截取 [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;]</span><br><span class="line">console.log(arr.slice(2)); 第一个参数表示截取的起始位置的索引。[ &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;]</span><br><span class="line">console.log(arr.slice(2, 5)); 第一个参数是起始位置的索引，第二个参数是结束位置的索引(不包括) [ &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span><br><span class="line">console.log(arr.slice(2, -2)); 负数从后往前数，-1开始，截取还是从前往后。 [ &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span><br><span class="line">console.log(arr.slice(-5, -2)); [ &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span><br><span class="line">console.log(arr.slice(2, -20)); []  没有范围</span><br><span class="line">console.log(arr.slice(20, 200)); [] 没有范围</span><br></pre></td></tr></table></figure>

<ol start="9">
<li> splice() 方法对数组进行删除、插入、替换，是最强大的数组方法，返回值是数组，改变原数组。</li>
</ol>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;];</span><br><span class="line">删除:参1：删除的起始索引位置 参2：删除的长度，返回删除的值组成的数组。</span><br><span class="line">console.log(arr.splice(1, 3));  [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span><br><span class="line">console.log(arr);[&quot;a&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;]</span><br><span class="line">console.log(arr.splice(1, -3));[]</span><br><span class="line">console.log(arr.splice(1)); [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;] 没有删除长度，从起始位置全部删除。</span><br><span class="line"></span><br><span class="line">插入：参1：删除的起始索引位置 参2：删除的长度，返回删除的值组成的数组。 从第三个参数开始插入的值。</span><br><span class="line">console.log(arr.splice(1, 0, &#x27;hehe&#x27;, &#x27;hello&#x27;));[] 没有删除</span><br><span class="line">console.log(arr);[&quot;a&quot;, &quot;hehe&quot;, &quot;hello&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;]</span><br><span class="line"></span><br><span class="line">替换：删除几项，插入几项。</span><br><span class="line">console.log(arr.splice(1, 2, &#x27;apple&#x27;, &#x27;orange&#x27;)); [&#x27;b&#x27;, &#x27;c&#x27;]</span><br><span class="line">console.log(arr); [&quot;a&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;]</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>join()方法，将数组转换成对应的字符串。参数就是连接符。</li>
</ol>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用参数就数组项连接成字符串。</span><br><span class="line">var arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;];</span><br><span class="line">console.log(arr.join()); a,b,c,d,e,f,g</span><br><span class="line">console.log(arr.join(&#x27;#&#x27;)); a#b#c#d#e#f#g</span><br><span class="line">console.log(arr.join(&#x27;&#x27;)); 经典用法  abcdefg</span><br><span class="line">console.log(arr.join(&#x27; &#x27;)); a b c d e f g</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="数组相关案例"><a href="#数组相关案例" class="headerlink" title="数组相关案例"></a>数组相关案例</h2><ol>
<li><p>编写函数 norepeat(arr) 将数组的重复元素去掉 - splice(改变原数组)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr = [12, 5, 6, 100, 12, 5, 6, 6, 6, 100];</span><br><span class="line">for (var i = 0; i &lt; arr.length; i++) &#123; i=0</span><br><span class="line">    for (var j = i + 1; j &lt; arr.length; j++) &#123; j=1-&gt;arr.length-1</span><br><span class="line">        if (arr[i] === arr[j]) &#123;</span><br><span class="line">            arr.splice(j, 1); splice改变原数组，如果删除一位，j++ 跳过一位</span><br><span class="line">            j--; 删除一位，退一位。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure></li>
<li><p>标记法：筛选需要的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var arr = [12, 12, 5, 6, 100, 12, 5, 6, 6, 6, 100];</span><br><span class="line"> var newarr = []; 存储去重后的数组的</span><br><span class="line"> for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">     var flag = 1; 标记</span><br><span class="line"></span><br><span class="line">     检测</span><br><span class="line">     for (var j = 0; j &lt; newarr.length; j++) &#123; 如果待去重的数组在新数组中存在，改变标记。</span><br><span class="line">         if (arr[i] === newarr[i]) &#123; 待去重的数组和新数组里面的每一项进行比较。如果存在，标记变成2</span><br><span class="line">             flag = 2;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     等待检测结果进行判断。</span><br><span class="line">     if (flag === 1) &#123; 如果标记没有改变，表示在新数组中不存在，追加到新数组中。</span><br><span class="line">         newarr.push(arr[i]);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>有一个从小到大排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 3, 56, 89];</span><br><span class="line"> arr.push(20);</span><br><span class="line"> arr.sort(function(a, b) &#123;</span><br><span class="line">     return a - b;</span><br><span class="line"> &#125;);</span><br><span class="line"> console.log(arr);</span><br><span class="line"></span><br><span class="line"> function sortnum(num) &#123;</span><br><span class="line">     var arr = [1, 3, 56, 89];</span><br><span class="line">     arr.push(num);</span><br><span class="line">     arr.sort(function(a, b) &#123;</span><br><span class="line">         return a - b;</span><br><span class="line">     &#125;);</span><br><span class="line">     return arr;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> console.log(sortnum(38));</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 数组和对象的遍历</span><br><span class="line">1. 数组和对象的遍历</span><br><span class="line"> - 数组的遍历 - for</span><br></pre></td></tr></table></figure>

<p>var arr = [‘a’, ‘b’, ‘c’];<br>for (var i = 0; i &lt; arr.length; i++) {arr.length 执行了 3 次<br>console.log(arr[i]);<br>}</p>
<pre><code> for (var i = 0, len = arr.length; i &lt; len; i++) &#123; arr.length执行了1次
     console.log(arr[i]);
 &#125;

 for (var i in arr) &#123; var i:数组的索引
     console.log(i); 0,1,2
     console.log(arr[i]); a,b,c
 &#125;
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 对象的遍历 - 无序的集合，没有规律</span><br><span class="line"></span><br></pre></td></tr></table></figure>
for...in...循环(专为对象而生，虽然可以遍历数组)
 var obj = &#123;
     a: 1,
     b: 2,
     c: 3
 &#125;;
 for (var i in obj) &#123; var i:表示对象的属性名称。  obj[i]:对象的属性值。
 console.log(i); a,b,c
 console.log(obj[i]); 1,2,3
 &#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 堆和栈</span><br><span class="line"></span><br><span class="line">1. JS 堆和栈的了解</span><br><span class="line">   1.JS 的数据类型</span><br><span class="line">   基本类型：number/string/boolean/undefined/null</span><br><span class="line">   引用类型：object</span><br><span class="line"></span><br><span class="line">   2.赋值(值传递和引用传递)</span><br><span class="line">   基本类型</span><br><span class="line">   栈：自动分配内存空间，系统自动释放，基本类型的值和引用类型（object）的地址</span><br><span class="line">   基本类型遵循值传递。</span><br><span class="line">   var a = 10;</span><br><span class="line">   var b = a; 值传递 将 a 的值赋值给 b</span><br><span class="line">   b++;</span><br><span class="line">   console.log(a); 10</span><br><span class="line">   console.log(b); 11</span><br><span class="line"></span><br><span class="line">   堆：动态分配的内存，大小不定，也不会自动释放。存放引用类型的值。</span><br><span class="line">   引用类型遵循引用传递，传递的是地址。</span><br><span class="line">   var arr1 = [1, 2, 3];</span><br><span class="line">   var arr2 = arr1;地址传递，将 arr1 的地址传给 arr2,相当于 arr1 和 arr2 的地址一样的。</span><br><span class="line">   arr2.push(4);</span><br><span class="line">   console.log(arr1); [1,2,3,4]</span><br><span class="line">   console.log(arr2); [1,2,3,4]</span><br><span class="line"></span><br><span class="line">   如何解决对象间的赋值 - 重新开辟地址，逐个赋值。</span><br><span class="line">   var arr1 = [1, 2, 3];</span><br><span class="line">   var arr2 = []; 重新开辟地址</span><br><span class="line"></span><br><span class="line">   浅拷贝</span><br><span class="line">   for (var i = 0; i &lt; arr1.length; i++) &#123;</span><br><span class="line">   arr2[i] = arr1[i];</span><br><span class="line">   &#125;</span><br><span class="line">   arr2.push(4);</span><br><span class="line">   console.log(arr1); [1,2,3]</span><br><span class="line">   console.log(arr2); [1,2,3,4]</span><br><span class="line"></span><br><span class="line">   console.log([] == []); false 比较的也是地址</span><br><span class="line"></span><br><span class="line">   总结：</span><br><span class="line">   基本类型遵循值传递，任意传值，引用类型遵循引用传递，不能直接赋值，拷贝方式进行赋值。</span><br><span class="line">   0</span><br><span class="line"></span><br><span class="line"># ES5 新增的严格模式</span><br><span class="line"></span><br><span class="line">1. 严格模式的目的 消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</span><br><span class="line">   为未来新版本的 Javascript 做好铺垫。</span><br><span class="line">2. 进入&quot;严格模式&quot;的标志 &quot;use strict&quot;;</span><br><span class="line">3. 如何使用</span><br><span class="line">   - 将&quot;use strict&quot;放在脚本文件的第一行，则整个脚本都将以&quot;严格模式&quot;运行</span><br><span class="line">   - 将&quot;use strict&quot;放在函数体的第一行，则整个函数以&quot;严格模式&quot;运行。</span><br><span class="line">4. 哪些语法和行为改变</span><br><span class="line">5. 变量显式声明：一定加 var</span><br><span class="line">   var a = 10; 全局属性,全局变量。</span><br><span class="line">   alert(a); 10</span><br><span class="line">   alert(window.a); 10</span><br><span class="line">   任何变量都是 window 下面的属性。</span><br><span class="line">   任何函数都是 window 下面的方法。</span><br><span class="line">   function fn() &#123;</span><br><span class="line">   alert(&#x27;function&#x27;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fn();</span><br><span class="line">   window.fn();</span><br><span class="line"></span><br><span class="line">6. 禁止使用 with 语句 - 了解</span><br><span class="line">   var obj = &#123;</span><br><span class="line">   a: 1,</span><br><span class="line">   b: 2,</span><br><span class="line">   c: 3</span><br><span class="line">   &#125;;</span><br><span class="line">   with(obj) &#123;</span><br><span class="line">   console.log(a);</span><br><span class="line">   console.log(b);</span><br><span class="line">   console.log(c);</span><br><span class="line">   &#125;</span><br><span class="line">7. 禁止 this 关键字指向全局对象(window)</span><br><span class="line">   this 指向函数的调用者。</span><br><span class="line">   function fn() &#123;</span><br><span class="line">   alert(this);</span><br><span class="line">   &#125;</span><br><span class="line">   fn(); 这里不应该指向 window，指向 undefined。</span><br><span class="line">   window.fn(); 这里指向 window</span><br><span class="line"></span><br><span class="line">8. 函数不能有重名的参数</span><br><span class="line">   function sum(a, a, b) &#123;</span><br><span class="line">   alert(a + a + b); 7</span><br><span class="line">   &#125;</span><br><span class="line">   sum(1, 2, 3);</span><br><span class="line"></span><br><span class="line">9. 禁止八进制表示法</span><br><span class="line">   八进制：0 开头 十六进制：0x 开头</span><br><span class="line">   var num = 012;</span><br><span class="line">   var num1 = 0x12345;</span><br><span class="line">   console.log(num);</span><br><span class="line">   console.log(num1);</span><br><span class="line"></span><br><span class="line">10. 不允许对 arguments 赋值 ,禁止使用 arguments.callee/arguments.caller</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code> arguments:类数组(类似数组)
 arguments.callee表示函数指针。
 function calc() &#123;
      arguments++; 这里会报错。
     for (var i = 0, sum = 0; i &lt; arguments.length; i++) &#123;
         sum += arguments[i];
     &#125;
     alert(sum);
 &#125;
 calc(1, 2, 3, 4, 5, 6);


 function feibo(n) &#123;
     if (n === 1) &#123;
         return 0;
     &#125;
     if (n === 2) &#123;
         return 1;
     &#125;
     return arguments.callee(n - 1) + arguments.callee(n - 2);
 &#125;
 console.log(feibo(20)); 4181
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># ES5 新增的数组方法</span><br><span class="line"></span><br><span class="line">1. 位置方法--indexOf() lastIndexOf()返回要查找的项在数组中的索引位置，没找到的情况下返回-1。</span><br><span class="line">   两个参数：要查找的项和(可选的)表示查找起点位置的索引</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>var arr = [&#39;apple&#39;, &#39;hello&#39;, &#39;hi&#39;, &#39;zhangsan&#39;, &#39;hi&#39;, &#39;orange&#39;];
1.indexOf() 方法从数组的开头开始向后查找。
console.log(arr.indexOf(&#39;hi&#39;)); 2
console.log(arr.indexOf(&#39;hehe&#39;)); -1
console.log(arr.indexOf(&#39;hi&#39;, 3)); 4
2.lastIndexOf() 方法则从数组的末尾开始向前查找。
console.log(arr.lastIndexOf(&#39;hi&#39;)); 4
</code></pre>
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ES7 里面的方法：includes():查找存在。</span><br><span class="line">   查找一个数值是否在数组中，只能判断一些简单类型的数据，对于复杂类型的数据无法判断。该方法接受两个参数，分别是查询的数据和初始的查询索引值。</span><br><span class="line">   console.log(arr.includes(&#x27;hi&#x27;)); true</span><br><span class="line">   console.log(arr.includes(&#x27;hehe&#x27;)); false</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>数组去重。<br>   var arr = [2, 5, 8, 6, 9, 8, 5, 2, 6, 9, ];<br>   var newarr = [];<br>  思路：<br>  如果待去重的数组项在新的数组中不存在，添加到新数组。<br>   for (var i = 0; i &lt; arr.length; i++) {<br>       if (newarr.indexOf(arr[i]) === -1) { 满足条件，不存在<br>           newarr.push(arr[i]);<br>       }<br>   }</p>
<p>   for (var i = 0; i &lt; arr.length; i++) {<br>       if (!newarr.includes(arr[i])) { 满足条件，不存在<br>           newarr.push(arr[i]);<br>       }<br>   }<br>    console.log(newarr);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 迭代方法（不会改变原数组）- 自带遍历</span><br><span class="line"></span><br><span class="line">    两个参数：</span><br><span class="line">    第一个参数：要在每一项上运行的函数(函数当参数，回调函数)。</span><br><span class="line">    此函数会接收三个参数：数组项的值、该项在数组中的位置、数组对象本身。</span><br><span class="line">    第二个参数：（可选的）运行该函数的作用域对象（影响 this 的值）。</span><br><span class="line"></span><br><span class="line">1.  every()对数组中的每一项运行给定函数，如果该函数对每一项都返回 true ，则返回 true 。</span><br><span class="line">    适合统一或者一致的事情。</span><br><span class="line">    `var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; var result = arr.every(function(value, index, array) &#123; value:数组项的值 index:数组项的索引 array:数组本身 return value &gt; 0; &#125;); console.log(result); var arr = [&#x27;hello&#x27;, &#x27;123&#x27;]; var result = arr.every(function(v, i) &#123; return typeof v === &#x27;string&#x27;; &#125;); console.log(result);`</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>some()对数组中的每一项运行给定函数，如果该函数对任意一项返回 true ，则返回 true 。<br>类似于或运算符，满足一个即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];</span><br><span class="line">     var result = arr.some(function(value, index, array) &#123;</span><br><span class="line">         return value &gt; 6;</span><br><span class="line">     &#125;);</span><br><span class="line">     console.log(result);</span><br><span class="line"></span><br><span class="line">3. filter()对数组中的每一项运行给定函数，返回该函数结果为 true 的项组成的数组。</span><br></pre></td></tr></table></figure>
<p> var arr = [1, 2, 3, 4, 1, 2, 3, 4];<br> var result = arr.filter(function(value, index, array) {</p>
<pre><code>  console.log(index); 每一个数组项的索引位置。
  console.log(arr.indexOf(value)); 当前value在数组中第一次出现的位置。
 return array.indexOf(value) === index; 如果满足此条件，证明当前的value是第一次出现，绝对不会第二次出现。
</code></pre>
<p> });<br> console.log(result);<br> var arr1 = [1, ‘hehe’, 2, ‘hello’, 3, ‘apple’, 4, 1, ‘orange’, 2, 3, 4];<br> var result1 = arr1.filter(function(value, index, array) {</p>
<pre><code> return typeof value === &#39;string&#39;;
</code></pre>
<p> });<br> console.log(result1);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4. map() 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。返回就是数组，不考虑 true 或者 false。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];<br>var result = arr.map(function(value, index, array) {</p>
<pre><code> return value * 100;
</code></pre>
<p>});<br>console.log(result); [100, 200, 300, 400, 500, 600, 700, 800, 900]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. forEach() ：对数组中的每一项运行给定函数。这个方法没有返回值。</span><br></pre></td></tr></table></figure>
<p> var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];<br> arr.forEach(function(value, index, array) {</p>
<pre><code> console.log(index + &#39;:&#39; + value + &#39;--&#39; + array);
</code></pre>
<p> });</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 归并方法---- reduce() reduceRight()</span><br><span class="line"></span><br><span class="line">    迭代：为了一个结果，比如累加累减，统计个数...</span><br><span class="line">    迭代：而每一次迭代得到的结果会作为下一次迭代的初始值。</span><br><span class="line">    这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。</span><br><span class="line"></span><br><span class="line">1. reduce() 方法从数组的第一项开始，逐个遍历到最后。</span><br><span class="line">   两个参数：每一项上调用的函数和（可选的）作为归并的初始值。</span><br><span class="line"></span><br><span class="line">   - 使用一个参数,每一项上调用的函数</span><br><span class="line">     调用的函数又接收 4 个参数：前一个值、当前值、项的索引和数组对象。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];<br> var result = arr.reduce(function(prev, curr, index, array) { prev:前一个值  curr:当前值</p>
<pre><code>  console.log(prev); 第一次表示数组项的第一位，后面的每一次都是前面迭代的结果。
  console.log(curr); 表示数组从第二次开始的值。  2, 3, 4, 5, 6, 7, 8, 9, 10
 console.log(prev + &#39;|&#39; + curr);
 return prev + curr;
</code></pre>
<p> });<br> console.log(result); 55</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 使用两个参数，每一项上调用的函数和（可选的）作为归并的初始值 - 重点</span><br></pre></td></tr></table></figure>
<p>var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];<br>var result = arr.reduce(function(prev, curr, index, array) {</p>
<pre><code> console.log(prev); 第一次表示迭代的初始值，后面的每一次都是前面迭代的结果。
 console.log(curr); 表示数组从第一次开始的值。 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
console.log(prev + &#39;|&#39; + curr);
return prev + curr;
</code></pre>
<p>}, 100); 100迭代的初始值。<br>console.log(result); 155</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. reduceRight() 方法从数组的最后一项开始，向前遍历到第一项。</span><br></pre></td></tr></table></figure>
<p>var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];<br> var result = arr.reduceRight(function(prev, curr, index, array) {</p>
<pre><code>  console.log(prev); 第一次表示迭代的初始值，后面的每一次都是前面迭代的结果。
  console.log(curr); 表示数组从最后一次开始的值。 10, 9, 8, 7, 6, 5, 4, 3, 2, 1
 console.log(prev + &#39;|&#39; + curr);
 return prev + curr;
</code></pre>
<p> }, 100); 100迭代的初始值。<br> console.log(result); 155</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4. flat(num):ES6 新增的扁平化的方法。</span><br><span class="line">   扁平化：将一个多维数组转换成一位数组。</span><br><span class="line">   Infinity:无穷</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> var arr = [1, 2, [3, 4, [5, 6, [7, 8], 9], 10]]; [1,2,3,4,5,6,7,8,9,10]<br> console.log(arr);<br> console.log(arr.flat(Infinity));</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 包装对象</span><br><span class="line"></span><br><span class="line">1. 包装对象的概念：</span><br><span class="line">   当要操作字符串、数字、布尔值的属性时,js 会在内存中自动创建一个对象,用来对内置类型进行包装，使内置类型暂时拥有普通对象功能，可以存取属性，一旦引用结束，包装对象自动销毁。</span><br><span class="line">   一.一切皆对象。</span><br><span class="line"></span><br><span class="line">   - 函数对象，数组对象，自定义对象</span><br><span class="line">   - 字符串，数字，布尔值是包装对象。</span><br><span class="line">   - null 空对象</span><br><span class="line">   - undefined:undefined 和 null 的值是相等的。企业级语言里面的 null 和 undefined 是一回事。</span><br><span class="line">     console.log(null == undefined); true</span><br><span class="line">     console.log(null === undefined); false</span><br><span class="line"></span><br><span class="line">2. 字符串，数字，布尔值是包装对象。</span><br><span class="line"></span><br><span class="line">   - 包装对象的特点就是临时性??</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> var str1 = ‘hello’;<br> var str2 = new String(‘hello’); String:类  str2:实例对象<br> console.log(str1 == str2); true<br> console.log(str1 === str2); false<br> console.log(typeof str1); string<br> console.log(typeof str2); object</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 字符串，数字，布尔值是基本类型，为什么基本类型拥有属性和方法???</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>var str3 = ‘javascript’;<br>console.log(str3.length); 10</p>
<p>var arr = [‘a’, ‘b’, ‘c’, ‘d’];<br>console.log(arr.length); 4<br>var arr = [‘a’, ‘b’, ‘c’, ‘d’];<br>arr.length = 2; 数组是真正的对象，不需要包装，直接使用。<br>console.log(arr.length); 2</p>
<p>var str3 = ‘javascript’;<br>str3.length = 5; 系统会临时采用对象的方式创建 var str3 = new String(‘javascript’),用完即销毁。<br>console.log(str3.length); 10  ?????</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 字符串方法</span><br><span class="line"></span><br><span class="line">1. 字符串对象 - 包装对象 - 临时性 1.类数组：类数组也就伪数组。在 js 中有一些对象它也拥有 length 属性，且拥有为非负整数的索引，但是它又不能调用数组的方法，这种对象被称为类数组对象。</span><br><span class="line">   arguments 字符串 获取多个元素对象。</span><br><span class="line"></span><br><span class="line">   2.创建字符串对象。</span><br><span class="line">   var str = new String(&#x27;hello&#x27;); 不需要采用此形式定义字符串，系统会帮助我们完成这种定义。</span><br><span class="line">   var str = &#x27;hello&#x27;; 定义字符串的正确的方式</span><br><span class="line"></span><br><span class="line">   3.字符串的属性和方法</span><br><span class="line">   length 属性：获取字符串的长度。</span><br><span class="line">   var str = &#x27;hello&#x27;;</span><br><span class="line">   console.log(str.length); 5</span><br><span class="line"></span><br><span class="line">2. 字符串的方法。</span><br><span class="line"></span><br><span class="line">   1. charAt(num):返回对应字符串索引的内容。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>var str = ‘abcdefg’;<br> console.log(str[2]); c<br> console.log(str.charAt(2)); c</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. charCodeAt(num):返回对应的字符串索引的内容的 unicode 编码</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>var str = ‘abcdefg’;<br>console.log(str.charCodeAt(0)); 97<br>var str = ‘我很喜欢你’;<br>for (var i = 0; i &lt; str.length; i++) {</p>
<pre><code>console.log(str.charCodeAt(i));
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. String.fromCharCode(unicode 编码);将参数中的 unicode 编码返回成对应的字符串的内容，多个编码用逗号分隔。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>for (var i = 0; i &lt;= 30000; i++) {</p>
<pre><code> document.write(String.fromCharCode(i));
</code></pre>
<p> }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. trim() 创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>var str = ‘    abc de fff       ‘;<br>console.log(str);<br>console.log(str.trim());</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. split——根据分隔符、将字符串拆分成数组。</span><br><span class="line">   把一个字符串分割成一个数组。通过传递一个参数来分割。第一个参数就是分割字符串的符号。如果参数为空，也是数组，只有一个数据。第二个参数用来限制数组的长度，多余的切掉。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>var str = ‘fksadltueriohfdsjkdklsfadjlkfeuiqrohdfjkafhdsyiqer’;<br>console.log(str.split(‘a’)); [“fks”, “dltueriohfdsjkdklsf”, “djlkfeuiqrohdfjk”, “fhdsyiqer”]<br>console.log(str.split(‘’));<br>console.log(str.split(‘’).sort().join(‘’)); aaaddddddeeeffffffhhhiiijjjkkkkklllooqqrrrsssstuuy</p>
<p>var str = ‘abcdefg’;<br>console.log(str.split()); [“abcdefg”]<br>console.log(str.split(‘’)); [“a”, “b”, “c”, “d”, “e”, “f”, “g”]<br>console.log(str.split(‘’, 3)); [“a”, “b”, “c”]<br>console.log(str.split(‘,’)); [“abcdefg”]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. substring()：用来截取字符串的内容</span><br><span class="line">   substring 如果索引是负数，当 0 处理。如果起始的索引大于结束的索引，交换位置。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> var str = ‘abcdefg’;<br> console.log(str.substring(1)); bcdefg<br> console.log(str.substring(1, 4)); bcd<br> console.log(str.substring(4, 1)); bcd<br> console.log(str.substring(4, -4)); abcd<br> console.log(str.substring(4, 0)); abcd<br> console.log(str.substring(0, 4)); abcd</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">7. substr(start, length); 用来截取字符串的内容</span><br><span class="line">   start：开始的索引，如果为负数，从后往前进行数，包括开始的索引。</span><br><span class="line">   length：截取的长度。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>var str = ‘abcdefg’;<br>console.log(str.substr(2, 3)); cde<br>console.log(str.substr(-5, 3)); cde<br>console.log(str.substr(-5, 30)); cdefg</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">9. toUpperCase()转换成大写 / toLowerCase()转换成小写.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>var str = ‘hello,WORLD’;<br>console.log(str.toUpperCase()); HELLO,WORLD<br>console.log(str.toLowerCase()); hello,world</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. slice() 截取字符串的方法，如果为负数，从后往前进行截取，包括开始的索引。</span><br><span class="line"></span><br><span class="line">   ````</span><br><span class="line">   var str = &#x27;hello&#x27;;</span><br><span class="line">   console.log(str.slice(1, 4)); ell</span><br><span class="line">   console.log(str.slice(1, -1)); ell```</span><br><span class="line">   ````</span><br><span class="line"></span><br><span class="line">4. indexOf 和 lastIndexOf():区别是如果第二个参数为负数，数组是从后往前找，字符串是当做 0 处理。</span><br></pre></td></tr></table></figure>
<p>var str = ‘javascriptjava’;<br>console.log(str.indexOf(‘a’)); 1<br>console.log(str.indexOf(‘a’, -5)); 1  字符串是负数当做0处理<br>console.log(str.lastIndexOf(‘a’)); 13</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5. concat( )：和数组方法使用一致。</span><br></pre></td></tr></table></figure>
<p>var str1 = ‘hello’;<br>var str2 = ‘world’;<br>console.log(str1.concat(str2)); helloworld</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># BOM</span><br><span class="line"></span><br><span class="line">1. BOM 的概念：</span><br><span class="line">   BOM 提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。</span><br><span class="line">   BOM 的核心对象是 window ，它表示浏览器的一个实例。</span><br><span class="line">   window 有双重角色，既是通过 JavaScript 访问浏览器窗口的一个接口,又是 ECMAScript 规定的全局对象。</span><br><span class="line"></span><br><span class="line">2. window 内置对象及方法</span><br><span class="line"></span><br><span class="line">   - window 的子对象 - location 对象(和地址栏有关)</span><br><span class="line">     地址栏的组成部分。</span><br><span class="line">     网站网址(域名) + 路径(文件位置) + ?拼接数据(多条数据用&amp;符号连接) + #哈希值(hash)</span><br><span class="line">     http:www.baidu.com/src/index.html?name=zhangsan&amp;age=100#about</span><br><span class="line">     域名：http:www.baidu.com</span><br><span class="line">     路径：/src/index.html</span><br><span class="line">     数据：?name=zhangsan&amp;age=100 -- 重要</span><br><span class="line">     哈希值(页面跳转使用): #about -- 重要</span><br><span class="line"></span><br><span class="line">   - href 属性：读写地址栏的所有的内容。地址栏的中文自动编码(系统自动完成)</span><br><span class="line">     console.log(window.location.href); 读</span><br><span class="line">     location.href = &#x27;http:www.jd.com&#x27;; 写</span><br><span class="line"></span><br><span class="line">   - search 属性：读取地址栏?后面的数据，包括?一起。</span><br><span class="line">     console.log(location.search);</span><br><span class="line"></span><br><span class="line">   - hash 属性：读取地址栏#后面的数据，包括#一起。</span><br><span class="line">     console.log(location.hash);</span><br><span class="line"></span><br><span class="line">   - assign()方法：设置地址栏。</span><br><span class="line">     location.assign(&#x27;http:www.baidu.com&#x27;); 设置地址栏</span><br><span class="line">     window.location = &#x27;http:www.qq.com&#x27;; 设置地址栏</span><br><span class="line">     document.onclick = function() &#123;</span><br><span class="line">     window.location = &#x27;http:www.qq.com&#x27;;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   - reload(true)方法：刷新页面，可以设置参数为 true，缓存中刷新.</span><br><span class="line">     location.reload(true); 刷新</span><br><span class="line"></span><br><span class="line">3. window 的子对象 -- history 对象 - 了解</span><br><span class="line">   history.go(num) 函数 -- 前进或后退指定的页面数（负数后退，正数前进）</span><br><span class="line">   history.back () 函数 -- 后退一页</span><br><span class="line">   history.forward () 函数 -- 前进一页</span><br><span class="line">   history.length 属性 -- history 对象中缓存了多少个 URL</span><br><span class="line"></span><br><span class="line">4. window 的子对象 -- navigator 对象(浏览器自身的信息)</span><br><span class="line">   userAgent 用户代理信息，通过该属性可以获取浏览器及操作系统信息</span><br><span class="line">   firefox:</span><br><span class="line">   &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:80.0) Gecko/20100101 Firefox/80.0&quot;</span><br><span class="line">   chrome:</span><br><span class="line">   &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.106 Safari/537.36&quot;</span><br><span class="line">   IE</span><br><span class="line">   &quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)&quot;</span><br><span class="line"></span><br><span class="line"># window 相关事件</span><br><span class="line"></span><br><span class="line">1. 读写可视区的宽高:浏览器内部看得见的区域。</span><br><span class="line">   获取浏览器看得见的区域的尺寸。</span><br></pre></td></tr></table></figure>
<p>document.documentElement:表示html元素。通过此方式获取html元素对象。<br>alert(document.documentElement); [object HTMLHtmlElement]<br>alert(document.querySelector(‘html’)); [object HTMLHtmlElement]<br>获取可视区的宽度：html元素对象的宽度<br>document.documentElement.clientWidth:获取可视区的宽度<br>document.documentElement.clientHeight:获取可视区的高度<br>window.onresize = function() {</p>
<pre><code>console.log(document.documentElement.clientWidth, document.documentElement.clientHeight);
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2. 读写滚动条距离 滚动条的距离是比例形成的值，并不是测量距离。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>document.documentElement.scrollTop:获取滚动条离顶部的距离。<br>document.documentElement.scrollLeft:获取滚动条离左边的距离。</p>
<p> window.onscroll = function() {</p>
<pre><code> console.log(document.documentElement.scrollTop, document.documentElement.scrollLeft);
</code></pre>
<p> }</p>
<p> 点击document，滚动条的top值设置为0<br> document.onclick = function() {</p>
<pre><code> document.documentElement.scrollTop = 0;
 document.documentElement.scrollLeft = 0;
</code></pre>
<p> }<br> scrollTo() 方法可把内容滚动到指定的坐标。<br> scrollTo(x坐标, y坐标)<br> xpos: 必需。 要在窗口文档显示区左上角显示的文档的 x 坐标。<br> ypos: 必需。 要在窗口文档显示区左上角显示的文档的 y 坐标。</p>
<p> document.onclick = function() {</p>
<pre><code> window.scrollTo(0, 0);
</code></pre>
<p> }</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 获取常见的元素对象。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  document:文档对象，表示获取document整个文档。<br>  alert(document);[object HTMLDocument]<br>  document.documentElement:获取html元素。<br>  document.body : 获取body元素<br>  document.title: 获取title元素<br>  document.head:  获取head元素<br>  其他的div,span,strong,p…通过querySelector进行获取。</p>
</li>
</ol>
<pre><code>获取对应元素的尺寸。
 console.log(document.documentElement.clientWidth); 891  可视区
 console.log(document.body.clientWidth); 2000  自己设置body的width
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 正则</span><br><span class="line"></span><br><span class="line">1. 正则表达式(regular expression)是一个描述字符规则的对象。我们可以通过 RegExp 类（构造函数）创建正则表达式，同时 String 和 RegExp 都定义了使用正则表达式进行强大的模式匹配和文本检索与替换的方法。</span><br><span class="line">   - 正则表达式(regular expression)是一个描述字符规则的对象。</span><br><span class="line">   - 字符串进行强大的模式匹配和文本检索与替换</span><br><span class="line">   - 利用自定义的规则的操作，控制，约定字符串的使用</span><br><span class="line">2. 创建正则对象。</span><br><span class="line">   - 利用类创建正则对象。</span><br><span class="line">     参 1：正则的规则,可以是字符串或者变量</span><br><span class="line">     参 2：可选的，修饰符 (i:忽略大小写,g:全局匹配,m:多行匹配)</span><br></pre></td></tr></table></figure>
<p>   var reg = new RegExp(‘hello’, ‘i’); reg:正则表达式对象。<br>   console.log(reg.test(‘abcdehellofghi’)); true<br>   console.log(reg.test(‘abcdehEllofghi’)); true<br>   console.log(reg.test(‘h1e2l3l4o5’)); false<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3. 字面量创建正则对象。注意：字面量方式创建正则，里面的字符规则一定是字符串。</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   var reg = /hello/i;<br>   console.log(reg.test(‘abcdehellofghi’)); true<br>   console.log(reg.test(‘abcdehEllofghi’)); true</p>
<p>   var str = ‘afds67法8ag7发顺丰f8da大事发生ds67fg89fd打发第三方sa90g三大法师f90sgfdhgkfadfds77f6das78f’;<br>   console.log(str.match(/\d+/g));<br>   console.log(str.match(/[a-z]+/g));<br>   console.log(str.match(/[\u4e00-\u9fa5]+/g));<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 正则的方法。</span><br><span class="line">   - test(str)方法在字符串中查找是否存在指定的正则表达式并返回布尔值，存在返回 true，不存在返回 false。(存在感)</span><br><span class="line">   - 可以配合正则使用的字符串方法</span><br><span class="line">     使用 match 方法获取匹配内容,返回数组,参数就是正则表达式。</span><br></pre></td></tr></table></figure><br>   var str = ‘heheHELLOabcHELLOabcHELLOabHELLO’;<br>   var reg = /hello/gi; 匹配字符串里面所有的hello,忽略大小写+全局匹配<br>   console.log(str.match(reg)); [“HELLO”, “HELLO”, “HELLO”, “HELLO”]<br>   console.log(str.match(/hello/gi));<br>   console.log(str.match(/hello/i)); 获取第一个<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用 search 来查找匹配数据，和全局没有关系，查找第一个匹配值的位置。(-1)</span><br><span class="line">- 了解</span><br><span class="line">  功能类似于 indexOf,但是优势是里面的参数可以是正则。</span><br></pre></td></tr></table></figure><br>   var str = ‘heheHELLOabcHELLOabcHELLOabHELLO’;<br>   console.log(str.search(/H/)); 4<br>   console.log(str.search(/H/g)); 4<br>   console.log(str.search(/HH/g)); -1<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- SSSSSSSSSSSS replace</span><br><span class="line">  使用 replace 替换匹配到的数据, 2 个参数： 1 代表正则， 2 代表用来替换的字符 - 非常重要</span><br><span class="line">  过滤敏感词。</span><br></pre></td></tr></table></figure><br>   var str = ‘这件衣服是你妈的还是你妹的我猜是你大爷的’;<br>   this|where|logo匹配this或where或logo中任意一个<br>   console.log(str.replace(/妈|妹|大爷/g, ‘<em>‘)); 这件衣服是你</em>的还是你<em>的我猜是你</em>的<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   - 使用 split 拆分成字符串数组</span><br><span class="line">     var str = &#x27;a1b2c3d4e5f&#x27;;</span><br><span class="line">     console.log(str.split(/[0-9]/g));[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]</span><br><span class="line">5. 控制字符</span><br><span class="line">   通过控制字符定义正则规则。 1.字符类：重复字符(量词)</span><br><span class="line"></span><br><span class="line">   - x?:匹配 0 个或 1 个 x</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   console.log(/a?/.test(‘bcd’)); true<br>   console.log(/a?/.test(‘abcd’)); true<br>   console.log(/a?/.test(‘aabcd’)); true<br>   console.log(/^a?$/.test(‘’)); true  匹配的要是空，要么一个a<br>   console.log(/^a?$/.test(‘a’)); true<br>   console.log(/^a?$/.test(‘aa’)); false<br>   console.log(/^a?$/.test(‘b’)); false<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- x\*:匹配 0 个或任意多个 x</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   console.log(/a*/.test(‘’)); true<br>   console.log(/a*/.test(‘a’)); true<br>   console.log(/a*/.test(‘aa’)); true<br>   console.log(/^a*$/.test(‘’)); true<br>   console.log(/^a*$/.test(‘a’)); true<br>   console.log(/^a*$/.test(‘ab’)); false<br>   console.log(/^a*$/.test(‘aaaaaaa’)); true<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- x+:匹配至少一个 x，1 个或者多个。</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   console.log(/a+/.test(‘’)); false<br>   console.log(/a+/.test(‘abc’)); true<br>   console.log(/^a+$/.test(‘a’)); true<br>   console.log(/^a+$/.test(‘ab’)); false<br>   console.log(/^a+$/.test(‘aa’)); true<br>   console.log(/^a+$/.test(‘aaaaaa’)); true<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (xyz)+:匹配至少一个(xyz),整体匹配</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   console.log(/xyz+/.test(‘xyzxyz’)); true<br>   console.log(/^xyz+$/.test(‘xyzxyz’)); false<br>   console.log(/^xyz+$/.test(‘xyzz’)); true<br>   console.log(/^xyz+$/.test(‘xyzzzz’)); true<br>   console.log(/^(xyz)+$/.test(‘xyzzzz’)); false<br>   console.log(/^(xyz)+$/.test(‘xyz’)); true<br>   console.log(/^(xyz)+$/.test(‘xyzxyzxyz’)); true<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- x&#123;m,n&#125;匹配最少 m 个、最多 n 个 x - 数量区间</span><br><span class="line">  x&#123;m&#125;：匹配 m 个 x。</span><br><span class="line">  x&#123;m,&#125;：匹配至少 m 个 x。</span><br><span class="line">  x&#123;m,n&#125;:最少 m 个、最多 n 个 x</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   console.log(/^1[3|5|6|7|8][0-9]{9}$/.test(‘18123456789’))<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - []:值的区间，每一个中括号表示一个字符。</span><br><span class="line">     [0-9]:数字 0-9 中的任意一个。</span><br><span class="line">     [a-z]:小写字母 a-z 中的任意一个。</span><br><span class="line">     [A-Z]:大写字母 A-Z 中的任意一个。</span><br><span class="line">     [A-F]:大写字母 A-F 中的任意一个。</span><br><span class="line">     [A-Za-z]:字母中的一个 [A-z]==[A-Za-z]参考 unicode 编码</span><br><span class="line">     [0-9a-zA-Z]:数字字母中的任意一个。</span><br><span class="line">     [0-9a-zA-Z_]:数字字母下划线中的任意一个</span><br><span class="line">     [0-9]+ : 一个或者多个数字。</span><br><span class="line">     [a-z0-9]匹配括号中的字符集中的任意一个字符（小写字母和数字）</span><br><span class="line"></span><br><span class="line">[^a-z0-9]: 匹配任意不在括号中的字符集中的字符（非小写字母和数字） 注意使用在中括号里面才表示取反。</span><br><span class="line"></span><br><span class="line">- 字符类：锚字符(位置) -SSSSSSSSSSSSSSS</span><br><span class="line">  ^行首匹配</span><br><span class="line">  $行尾匹配</span><br></pre></td></tr></table></figure><br>  var reg = /abc/;<br>  var str = ‘aabcc’;<br>  console.log(reg.test(str));true<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>添加了行首行尾，并不是只匹配行首行尾，而是按照顺序逐个进行匹配。(等价关系)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var reg = /^abc$/;</span><br><span class="line">var str = &#x27;abc&#x27;;</span><br><span class="line">console.log(reg.test(str)); true</span><br><span class="line"></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">   - (.匹配除换行符\n 外的任意字符)</span><br></pre></td></tr></table></figure>
<pre><code> console.log(/^.*$/.test(&#39;adkjfadslf&#39;));
 console.log(/^.*$/.test(&#39;adkj\nfadslf&#39;)); false
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> - 其他的重要的匹配字符。</span><br><span class="line">   \d 匹配数字，相当于[0-9]</span><br><span class="line">   console.log(/^1[3|5|6|7|8]\d&#123;9&#125;$/.test(&#x27;18123456789&#x27;));</span><br><span class="line">   \D 匹配非数字，相当于[^0-9]</span><br><span class="line">   \w 匹配字母和数字及* 相当于[ a-zA-Z0-9* ]</span><br><span class="line"></span><br><span class="line">  \W 匹配非字母和数字及\_</span><br><span class="line">  </span><br><span class="line">   \s 匹配空白字符、空格、制表符和换行符</span><br><span class="line">  \S 匹配非空白字符</span><br><span class="line"></span><br><span class="line">this|where|logo 匹配 this 或 where 或 logo 中任意一个</span><br><span class="line"></span><br></pre></td></tr></table></figure>
 function fnTrim(str) &#123;
     return str.replace(/^\s+|\s+$/g, &#39;&#39;); 将行首一个或者多个空格和行尾一个或者多个空格替换成空隙。
 &#125;
 console.log(&#39;(   abc de    )&#39;);
 console.log(&#39;(&#39; + fnTrim(&#39;   abc de    &#39;) + &#39;)&#39;); abc de
 console.log(&#39;   abc de    &#39;.trim()); abc de
  1.地址栏数据转对象--https:www.baidu.com?a=1&amp;b=2&amp;c=3&amp;d=4
 &#123;a:1,b:2,c:3,d:4&#125;
 var obj = &#123;&#125;;
 var str = &#39;https:www.baidu.com?a=1&amp;b=2&amp;c=3&amp;d=4&#39;;
 console.log(str.substring(str.indexOf(&#39;?&#39;))); ?a=1&amp;b=2&amp;c=3&amp;d=4
 console.log(str.substring(str.indexOf(&#39;?&#39;) + 1)); a=1&amp;b=2&amp;c=3&amp;d=4
 str = str.substring(str.indexOf(&#39;?&#39;) + 1); a=1&amp;b=2&amp;c=3&amp;d=4
 console.log(str.split(&#39;&amp;&#39;));  [&quot;a=1&quot;, &quot;b=2&quot;, &quot;c=3&quot;, &quot;d=4&quot;]
 var strarr = str.split(&#39;&amp;&#39;);
 strarr.map(function(value) &#123;
     var newarr = value.split(&#39;=&#39;); [a,1]
     obj[newarr[0]] = +newarr[1];
 &#125;);
 console.log(obj); &#123;a: 1, b: 2, c: 3, d: 4&#125;
</code></pre>
<pre><code>
6. 正则操作

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = str.substring(str.indexOf(&#x27;?&#x27;) + 1); a=1&amp;b=2&amp;c=3&amp;d=4</span><br><span class="line">console.log(str.replace(/&amp;/g, &#x27;,&#x27;)); a=1,b=2,c=3,d=4</span><br><span class="line">console.log(str.replace(/&amp;/g, &#x27;,&#x27;).replace(/=/g, &#x27;:&#x27;)); a:1,b:2,c:3,d:4</span><br><span class="line">console.log(eval(&#x27;(&#123;&#x27; + str.replace(/&amp;/g, &#x27;,&#x27;).replace(/=/g, &#x27;:&#x27;) + &#x27;&#125;)&#x27;));</span><br></pre></td></tr></table></figure>

7. eval(str):js 内置的函数，解析括号里面的字符串，括号里面的字符串当做 js 代码执行。

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">eval(&#x27;alert(&quot;hello&quot;)&#x27;);</span><br><span class="line"> eval(&#x27;var a=1;var b=2;alert(a+b);&#x27;);</span><br><span class="line"> console.log(eval(&#x27;&#123;&#125;&#x27;)); undefined</span><br><span class="line"> console.log(eval(&#x27;&#123;a:1&#125;&#x27;)); 1</span><br><span class="line"> console.log(eval(&#x27;&#123;a:1,b:2&#125;&#x27;)); 报错，js无法解析里面的代码。</span><br><span class="line"> eval(&#x27;(console.log(123))&#x27;);</span><br><span class="line"></span><br><span class="line"> console.log(eval(&#x27;&#123;&#125;&#x27;)); undefined</span><br><span class="line"> console.log(eval(&#x27;(&#123;&#125;)&#x27;)); &#123;&#125; 添加括号的目的，希望不要解析里面的代码，将其当成一个整体。除非内部的字符串存在一些输出。</span><br><span class="line"> 如果你需要将一个对象格式的字符串转换成对象，可以添加括号的方式进行转换。</span><br><span class="line"> console.log(eval(&#x27;(&#123;&#125;)&#x27;));</span><br><span class="line"> console.log(eval(&#x27;(&#123;a:1,b:2&#125;)&#x27;));</span><br><span class="line"> console.log(&#123;</span><br><span class="line">     a: 1,</span><br><span class="line">     b: 2</span><br><span class="line"> &#125;);</span><br><span class="line"> console.log(&#x27;&#123;a:1,b:2&#125;&#x27;);</span><br><span class="line"></span><br><span class="line">案例：</span><br><span class="line"> var data = &#x27;[&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;]&#x27;;</span><br><span class="line"> var data1 = &#x27;&#123;name:&quot;zhangsan&quot;,age:100,sex:&quot;男&quot;&#125;&#x27;;</span><br><span class="line"> console.log(data);</span><br><span class="line"> console.log(data1);</span><br><span class="line"> data = eval(&#x27;(&#x27; + data + &#x27;)&#x27;);</span><br><span class="line"> data1 = eval(&#x27;(&#x27; + data1 + &#x27;)&#x27;);</span><br><span class="line"> console.log(data);</span><br><span class="line"> console.log(data1);</span><br><span class="line"> console.log(data[1]); lisi</span><br><span class="line"> console.log(data1.name); zhangsan</span><br></pre></td></tr></table></figure>

8. 正则的分组

   - 正则的分组--()符号实现, \1 \2...
     正则表达式中括号表示分组的意义，第一个括号第一个分组，第二个括号表示第二个分支....
     \1\2...表示对应的分组中的值。

     如何匹配中文 - [\u4e00-\u9fa5]

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var str = &#x27;abc你好def谢谢123对不起kkkk&#x27;;</span><br><span class="line">console.log(str.match(/[\u4e00-\u9fa5]/g)); [&quot;你&quot;, &quot;好&quot;, &quot;谢&quot;, &quot;谢&quot;, &quot;对&quot;, &quot;不&quot;, &quot;起&quot;]</span><br><span class="line">console.log(str.match(/[\u4e00-\u9fa5]+/g)); [&quot;你好&quot;, &quot;谢谢&quot;, &quot;对不起&quot;]</span><br><span class="line">var str = &#x27;希望大家好好学习，天天向上&#x27;;</span><br><span class="line">var reg = /([\u4e00-\u9fa5])\1/g;</span><br><span class="line">console.log(str.match(reg)); [&quot;好好&quot;, &quot;天天&quot;]</span><br><span class="line">    </span><br><span class="line">var str = &#x27;天上的星星是一闪一闪的，地上的人儿一动一动的&#x27;;</span><br><span class="line">var reg = /([\u4e00-\u9fa5])([\u4e00-\u9fa5])\1\2/g;</span><br><span class="line">console.log(str.match(reg));  [&quot;一闪一闪&quot;, &quot;一动一动&quot;]</span><br><span class="line">    </span><br><span class="line">var str = &#x27;天上的星是亮晶晶，地上的人儿傻呼呼&#x27;;</span><br><span class="line">var reg = /[\u4e00-\u9fa5]([\u4e00-\u9fa5])\1/g;</span><br><span class="line">console.log(str.match(reg)); [&quot;亮晶晶&quot;, &quot;傻呼呼&quot;]</span><br></pre></td></tr></table></figure>

   - RegExp.$1,RegExp.$2,RegExp.$3...通过正则类下面的静态属性来匹配分组的值
     使用上面的属性获取匹配值的时候，正则必须先执行一次

   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = &#x27;hello,world&#x27;;</span><br><span class="line">var reg = /(\w+),(\w+)/;</span><br><span class="line">reg.test(str); 正则必须先执行一次</span><br><span class="line">console.log(RegExp.$1); hello  获取第一个分组的值</span><br><span class="line">console.log(RegExp.$2); world  获取第二个分组的值</span><br></pre></td></tr></table></figure>

- 转义字符：转义字符是字符的一种间接表示方式。在特殊语境中，无法直接使用字符自身。如果在一个正常字符前添加反斜杠,JavaScript 会忽略该反斜杠
  构造函数定义正则 -- \\
  字面量定义正则 -- \
   console.log(&#39;h\ello&#39;);如果在一个正常字符前添加反斜杠,JavaScript 会忽略该反斜杠
  console.log(&#39;hello\nworld&#39;); \n 换行，这里不会省略，在特殊语境中，无法直接使用字符自身
  var reg = /^\a$/;这里表示的就是 a， 会忽略该反斜杠
  console.log(reg.test(&#39;a&#39;));true

  var reg = /^\d$/;
  console.log(reg.test(&#39;d&#39;)); false
  console.log(reg.test(&#39;1&#39;)); true

  字符串中输出单双引号必须添加转义字符。
  var reg = /^a&quot;b&#39;c$/;
  console.log(reg.test(&#39;a\&quot;b\&#39;c&#39;)); 这里必须通过\进行转义，否则报错。

  var reg = /^\.com$/; 这里必须添加转义字符，否则当做正则的(.)进行匹配
  console.log(reg.test(&#39;.com&#39;)); true

  构造函数定义
  var reg = new RegExp(&#39;\d&#39;); \d 表示的是 d 字符，不是数字。
  console.log(reg.test(&#39;12345&#39;)); false
  console.log(reg.test(&#39;12d345&#39;)); true

  var reg = new RegExp(&#39;\\d&#39;); 表示的是数字
  console.log(reg.test(&#39;12345&#39;)); true
  console.log(reg.test(&#39;abcde&#39;)); false

  var reg1 = /\d/;
  console.log(reg1.test(&#39;12345&#39;)); true
  1.replace:替换。
  参 1：正则表达式
  参 2：替换的字符串，也可以是函数
  var str = &#39;aabbbccdeefffgghhhiiiiijjjjjjjjj&#39;;
  var reg = /(\w)\1\*/g;
  var obj = &#123;&#125;;
  str.replace(reg, function(a, b) &#123;
  console.log(a); 匹配结果，具有 length 属性
  console.log(a.length);
  console.log(b);分组里面的值
  obj[b] = a.length;
  &#125;);
  console.log(obj);

  2.将字符串 get-element-by-id 转换成 getElementById

  var str = &#39;get-element-by-id&#39;;
  console.log(str.split(&#39;-&#39;)); [&quot;get&quot;, &quot;element&quot;, &quot;by&quot;, &quot;id&quot;]
  var arr = str.split(&#39;-&#39;);
  for (var i = 1; i &lt; arr.length; i++) &#123;
  console.log(arr[i].substring(0, 1));e,b,i
  console.log(arr[i].substring(0, 1).toUpperCase());E,B,I
  arr[i] = arr[i].substring(0, 1).toUpperCase() + arr[i].substring(1)
  &#125;
  console.log(arr.join(&#39;&#39;)); getElementById

  var str = &#39;get-element-by-id&#39;;
  console.log(str.replace(/-([a-z])/g, function(result, value) &#123;
  result:-e -b -i
  value:e,b,i
  return value.toUpperCase();
  &#125;));

# ES6

1. this 的概念

   - this 是 Javascript 语言的一个关键字。它代表函数运行时,自动生成的一个内部对象,只能在函数内部使用。随着函数使用场合的不同,this 的值会发生变化。但是有一个总的原则,那就是 this 指的是调用函数的那个对象。
   - 谁调用此函数，this 指向谁。
     普通函数，自执行函数，函数表达式 - this 指向 window
     严格模式，this 指向 undefined

   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">function fn() &#123;</span><br><span class="line">    alert(this);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line">window.fn();window</span><br><span class="line">! function() &#123;</span><br><span class="line">    alert(this);</span><br><span class="line">&#125;();</span><br><span class="line">var fn1 = function() &#123;</span><br><span class="line">    alert(this);</span><br><span class="line">&#125;</span><br><span class="line">fn1();</span><br></pre></td></tr></table></figure>

   - 对象中的 this 和事件处理函数中的 this 都是指向当前操作的对象(元素对象) - 应用的核心

   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    name: &#x27;zhangsan&#x27;,</span><br><span class="line">    showname: function() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.showname(); zhangsan</span><br><span class="line"></span><br><span class="line">document.onclick = function() &#123;</span><br><span class="line">    console.log(this); document</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">主动触发</span><br><span class="line">document.onclick();</span><br></pre></td></tr></table></figure>

   - 回调函数：函数作为参数给另外一个函数。回调函数内部的 this 指向 window。

   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr = [12, 3, 4, 5];</span><br><span class="line">arr.map(function() &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;);</span><br><span class="line">window.setInterval(function() &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;, 1000);</span><br><span class="line">window.setTimeout(function() &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>

   - 构造函数(类)：首字母大写，new 关键字调用。
     构造函数的 this 指向类创建出来的对象(实例对象)

   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Fn() &#123;</span><br><span class="line">     alert(this);</span><br><span class="line"> &#125;</span><br><span class="line"> Fn() window</span><br><span class="line"> new Fn(); [object Object] 指向类创建出来的对象(实例对象)</span><br><span class="line"> var f1 = new Fn(); Fn:类，构造函数   f1:实例对象</span><br><span class="line"> var f2 = new Fn(); Fn:类，构造函数   f2:实例对象</span><br></pre></td></tr></table></figure>

2. call apply bind

   1. 函数对象的属性和方法
      - 属性 - length(表示参数的长度)
        console.log(function fn(a, b, c) &#123;&#125;.length); 3
   2. 函数下面的三个方法(call/apply/bind) - 改变 this 指向。

      - 梳理指向
      - 普通函数，自执行函数，函数表达式，回调函数 - 指向 window
      - 对象方法中的函数，事件处理函数 - 指向当前的对象。
      - 构造函数 - 指向 new 出来的实例对象。
      - apply 、 call 、bind 三者都是用来改变函数的 this 对象的指向的；第一个参数都是 this 要指向的对象，也就是想指定的上下文；从第二个参数开始，就是函数的本身的参数；

   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">     a: 1</span><br><span class="line"> &#125;</span><br><span class="line"> function fn(n1, n2) &#123;</span><br><span class="line">     console.log(n1 + n2);</span><br><span class="line">     console.log(this);</span><br><span class="line"> &#125;</span><br><span class="line"> call:第一个参数都是this要指向的对象,从第二个参数开始，就是函数的本身的参数,多个逗号隔开</span><br><span class="line"> fn.call(obj, 3, 5);</span><br><span class="line">    </span><br><span class="line"> apply:第一个参数都是this要指向的对象,第二个参数是数组，数组项就是函数本身的参数。</span><br><span class="line"> fn.apply(obj, [3, 5]);</span><br><span class="line">    </span><br><span class="line"> bind:第一个参数都是this要指向的对象,从第二个参数开始，就是函数的本身的参数,多个逗号隔开,返回函数体,需要再次触发。</span><br><span class="line"> fn.bind(obj, 3, 5)();</span><br></pre></td></tr></table></figure>

   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">应用：</span><br><span class="line">给5个li元素添加点击事件，延迟2s将li里面的内容全部变成222222222222222222</span><br><span class="line"> var aLi = document.querySelectorAll(&#x27;ul li&#x27;);</span><br><span class="line"> for (var i = 0; i &lt; aLi.length; i++) &#123;</span><br><span class="line">     aLi[i].onclick = function() &#123;</span><br><span class="line">         this:当前点击的li</span><br><span class="line">         window.setTimeout(function() &#123;</span><br><span class="line">             this:window</span><br><span class="line">             this.innerHTML = &#x27;2222222222222222222222222&#x27;;</span><br><span class="line">         &#125;.bind(this), 2000); 此种情况必须使用bind，call和apply都不行。</span><br><span class="line">     &#125;;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">将正确的this的存储下来</span><br><span class="line">var aLi = document.querySelectorAll(&#x27;ul li&#x27;);</span><br><span class="line">for (var i = 0; i &lt; aLi.length; i++) &#123;</span><br><span class="line">    aLi[i].onclick = function() &#123;</span><br><span class="line">        this:当前点击的li</span><br><span class="line">        var _this = this; 将正确的this的存储下来</span><br><span class="line">        window.setTimeout(function() &#123;</span><br><span class="line">            this:window</span><br><span class="line">            _this.innerHTML = &#x27;2222222222222222222222222&#x27;;</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> 构造函数的this指向类创建出来的对象(实例对象)</span><br><span class="line">function Fn() &#123;</span><br><span class="line">    alert(this);</span><br><span class="line">&#125;</span><br><span class="line">Fn() window</span><br><span class="line">new Fn(); [object Object] 指向类创建出来的对象(实例对象)</span><br><span class="line">var f1 = new Fn(); Fn:类，构造函数   f1:实例对象</span><br><span class="line">var f2 = new Fn(); Fn:类，构造函数   f2:实例对象</span><br></pre></td></tr></table></figure>

3. JSON
4. json 数据

- 概念：
  JSON 是一种轻量级的数据交换格式。称之为 json 对象(最终转换成对象进行处理)。
  简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。

- 特点：
  json:是一种轻量级的数据交换格式，不是 js 独有的。
  json 组成： 简单值 + &#39;对象&#39; + &#39;数组&#39;
  json 里面字符串需要添加双引号。
  json 没有 var 关键字, 没有分号(;) 等 js 相关的语法。

2. JSON 的静态方法：非常重要

   JSON.parse()： 将 json 格式的字符串转换成数组对象或者自定义对象格式， 具有 json 检测功能。
   eval():eval 不安全，里面的代码有可能会执行。eval 的性能不及 JSON.parse,eval 解析两次。使用较少。

   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var data = &#x27;&#123;&quot;names&quot;: [&quot;zhangsan&quot;, &quot;lisi&quot;],&quot;title&quot;: &quot;这里是标题&quot;,&quot;price&quot;: 200,&quot;url&quot;: &quot;https:img.alicdn.com/bao/uploaded/i2/30402319/O1CN011Rl7oM1T093vmCPUu_!!0-item_pic.jpg_200x200q90.jpg_.webp&quot;&#125;&#x27;;</span><br><span class="line"></span><br><span class="line">var names = &#x27;[&quot;zhangsan&quot;, &quot;lisi&quot;,&quot;wangwu&quot;,&#x27;zhaoliu&quot;]&#x27;;</span><br><span class="line">console.log(JSON.parse(names));</span><br><span class="line">console.log(eval(&#x27;(&#x27; + names + &#x27;)&#x27;));</span><br><span class="line">var namearr = JSON.parse(names);</span><br><span class="line">var str = &#x27;&#x27;;</span><br><span class="line">namearr.forEach(function(value) &#123;</span><br><span class="line">    str += &#x27;&lt;li&gt;&#x27; + value + &#x27;&lt;/li&gt;&#x27;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">document.body.innerHTML = str;</span><br><span class="line"></span><br><span class="line">var str = &quot;[&#x27;zhangsan&#x27;,&#x27;lisi&#x27;,&#x27;wangwu&#x27;]&quot;; 不是json格式，json里面字符串需要添加双引号</span><br><span class="line">console.log(JSON.parse(str));</span><br><span class="line">console.log(eval(&#x27;(&#x27; + str + &#x27;)&#x27;));[&quot;zhangsan&quot;, &quot;lisi&quot;, &quot;wangwu&quot;]</span><br></pre></td></tr></table></figure>

3. JSON.stringify()： 将对象转换成 json 格式的字符串。
   对象的值都是统一的[object Object]

   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2,</span><br><span class="line">    c: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    d: 1,</span><br><span class="line">    e: 2,</span><br><span class="line">    f: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(obj); 输出对象的格式</span><br><span class="line">alert(obj); 输出对象的值 [object Object]</span><br><span class="line">alert(obj1); 输出对象的值 [object Object]</span><br><span class="line">console.log(JSON.stringify(obj)); &#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3&#125;  JSON格式的字符串</span><br><span class="line">console.log(JSON.parse(JSON.stringify(obj))); &#123;a: 1, b: 2, c: 3&#125;</span><br></pre></td></tr></table></figure>

   注意：对象如果进行传输或者存储，一定将对象转换成字符串格式，进行存储，数组可以忽略 - 重要 Ajax 数据进行转化的时候

   var arr = [&#39;zhangsan&#39;, &#39;lisi&#39;];
   alert(arr);
   var arr1 = [&#39;wangwu&#39;, &#39;lisi&#39;];
   alert(arr1);

   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

4. let 和 const

   1. 变量和常量。
      1.let 概念：
      ES6 新增了 let 命令，用来声明变量。它的用法类似于 var，但是所声明的变量，只在 let 命令所在的代码块内有效。
      代码块:&#123;&#125;括起来的代码。
      if()&#123;&#125; switch()&#123;&#125; for()&#123;&#125; while()&#123;&#125; function()&#123;&#125;
      全局变量：函数外面的变量。(函数内部的变量声明时候没有 var 关键字)
      局部变量：函数内部的变量。
      块作用域：声明的变量只在代码块内有效。

   2. let 特点：
      即 let 所声明的变量就“ 绑定” 这个区域， 不再受外部的影响。

   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 1; i &lt;= 10; i++) &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">console.log(i); 11</span><br><span class="line"></span><br><span class="line">for (let j = 1; j &lt;= 10; j++) &#123;</span><br><span class="line">    console.log(j);</span><br><span class="line">&#125;</span><br><span class="line">console.log(j); ReferenceError: j is not defined  外面无法访问。</span><br><span class="line"></span><br><span class="line">var aLi = document.querySelectorAll(&#x27;ul li&#x27;);</span><br><span class="line">for (var i = 0; i &lt; aLi.length; i++) &#123;</span><br><span class="line">   aLi[i].onclick = function() &#123;</span><br><span class="line">       console.log(i); 输出的是循环最后一次值。点击的时候，循环已经结束了。</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (let i = 0; i &lt; aLi.length; i++) &#123;</span><br><span class="line">    aLi[i].onclick = function() &#123;</span><br><span class="line">        console.log(i); 即let所声明的变量就“ 绑定” 这个区域， 不再受外部的影响  i就是索引</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

   3. Let 声明的变量不存在变量提升(前置访问 undefined 不存在了)，变量声明之前不能使用。

   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(a); undefined</span><br><span class="line">var a = 10;</span><br><span class="line">console.log(a); 10</span><br><span class="line"></span><br><span class="line">console.log(a); 报错，不存在变量提升(暂时性死区)</span><br><span class="line">let a = 10;</span><br><span class="line">console.log(a); 10</span><br></pre></td></tr></table></figure>

   4. let 不允许在相同作用域内，重复声明同一个变量。

   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">var a = 20;</span><br><span class="line">var a = 30;</span><br><span class="line">console.log(a);覆盖</span><br><span class="line">let b = 10;声明变量b</span><br><span class="line">let b = 20;声明变量b</span><br><span class="line">console.log(b);  SyntaxError: Identifier &#x27;b&#x27; has already been declared 报错</span><br><span class="line"></span><br><span class="line">let c = 30; 声明变量c</span><br><span class="line">c = 300; 改变变量c的值</span><br><span class="line">console.log(c); 300</span><br></pre></td></tr></table></figure>

   5. ES6 允许块级作用域的任意嵌套，外层无法读取内层作用域的变量，反之可以,let 和 var 都是这样的。
   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  let a = 10;</span><br><span class="line">  console.log(b);报错，无法获取，内到外的关系</span><br><span class="line">  &#123;</span><br><span class="line">      console.log(a); 10</span><br><span class="line">      let b = 20;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
   6. 其他的情况 let 和 var 一样的使用。 定义多个变量，松散类型，值可以改变，写入内存这些都是一样的。
   7. 常量：const 声明一个只读的常量。一旦声明，常量的值就不能改变。
   8. 常量简单使用场景
      能够使用常量尽量使用常量(值不会发生变量)
      获取元素对象
      函数的封装
      考虑不变的值......
      const aLi = document.querySelectorAll(&#39;ul li&#39;);
      const PI = 3.14;
      PI = 3.1415926;报错
   9. 常量也不能重复声明，具有块作用域。
   10. 应用

   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.onclick = function(ev) &#123;</span><br><span class="line">     let ev = ev || window.event; 这里报错，ev已经被使用了。</span><br><span class="line">     var ev = ev || window.event; ok</span><br><span class="line">    let e = ev || window.event; ok</span><br><span class="line">    console.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

5. 变量的解构赋值

   1. 变量的解构赋值 - 快速的给变量赋值
      传统的赋值方式
      <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let arr = [100, 200, 300, 400];</span><br><span class="line">let a = arr[0];</span><br><span class="line">let b = arr[1];</span><br><span class="line">let c = arr[2];</span><br><span class="line">let d = arr[3];</span><br><span class="line">console.log(a, b, c, d);100 200 300 400</span><br></pre></td></tr></table></figure>
   2. 数组的解构赋值

   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let arr = [100, 200, 300, 400];</span><br><span class="line">let [a, b, c, d] = arr;</span><br><span class="line">console.log(a, b, c, d);</span><br><span class="line"></span><br><span class="line">let [a, b, c, d] = [1000, 2000, 3000, 4000];</span><br><span class="line">console.log(a, b, c, d);</span><br><span class="line">统一两边格式</span><br><span class="line">let [a, b, [c, d, [e, f, [h, i]]]] = [1, 2, [3, 4, [5, 6, [7, 8]]]];</span><br><span class="line">console.log(a, b, c, d, e, f, h, i);</span><br><span class="line"></span><br><span class="line">没有配置的输出undefined，定义了变量没有初始化</span><br><span class="line">let [a, b, c, d] = [1, 2, 3];</span><br><span class="line">console.log(a, b, c, d); 1 2 3 undefined</span><br><span class="line"></span><br><span class="line">多余的值直接删掉。</span><br><span class="line">let [name, age, sex] = [&#x27;zhangsan&#x27;, 100, &#x27;男&#x27;, &#x27;hello&#x27;];</span><br></pre></td></tr></table></figure>

   3. 数组解构赋值的应用。

   - 交换两个值。
     <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">var b = 5;</span><br><span class="line">var [a, b] = [b, a];</span><br><span class="line">console.log(a, b); 5 10</span><br></pre></td></tr></table></figure>

   4. 函数输出多个结果。
      封装函数，输出数字数组里面的最大值，最小值，length 属性。

   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr = [12, 3, 56, 78, 5, 999, 62];</span><br><span class="line">function getValue(arr) &#123;</span><br><span class="line">    arr.sort(function(a, b) &#123;</span><br><span class="line">        return a - b;</span><br><span class="line">    &#125;);</span><br><span class="line">    return [arr[arr.length - 1], arr[0], arr.length];</span><br><span class="line">&#125;</span><br><span class="line">let [maxvalue, minvalue, len] = getValue(arr);</span><br><span class="line">console.log(maxvalue, minvalue, len);</span><br></pre></td></tr></table></figure>

   5. 对象的解构赋值。

   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> let obj = &#123;</span><br><span class="line">     name: &#x27;zhangsan&#x27;,</span><br><span class="line">     age: 100,</span><br><span class="line">     sex: &#x27;男&#x27;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">变量名和属性名一致。</span><br><span class="line"> let &#123;</span><br><span class="line">     age,</span><br><span class="line">     name,</span><br><span class="line">     sex</span><br><span class="line"> &#125; = obj;</span><br><span class="line"></span><br><span class="line"> console.log(name, age, sex);</span><br><span class="line"></span><br><span class="line"> let &#123;</span><br><span class="line">     c</span><br><span class="line"> &#125; = &#123;</span><br><span class="line">     a: 1,</span><br><span class="line">     b: 2,</span><br><span class="line">     c: 3</span><br><span class="line"> &#125;;</span><br><span class="line"> console.log(c);3</span><br><span class="line"></span><br><span class="line">如果需要修改变量名，通过正常的赋值语法实现</span><br><span class="line"> let &#123;</span><br><span class="line">     a: d, 修改名称</span><br><span class="line">     b,</span><br><span class="line">     c</span><br><span class="line"> &#125; = &#123;</span><br><span class="line">     a: 1,</span><br><span class="line">     b: 2,</span><br><span class="line">     c: 3</span><br><span class="line"> &#125;;</span><br><span class="line"> console.log(d); 1</span><br><span class="line"></span><br><span class="line"> let &#123;</span><br><span class="line">     name: xingming, 修改名称，得到值的是后者。</span><br><span class="line">     age,</span><br><span class="line">     sex</span><br><span class="line"> &#125; = &#123;</span><br><span class="line">     name: &#x27;zhangsan&#x27;,</span><br><span class="line">     age: 100,</span><br><span class="line">     sex: &#x27;男&#x27;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> console.log(xingming); zhangsan</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">6. 扩展运算符 ...</span><br><span class="line"> 1. 扩展运算符用三个点号表示，功能是把数组或类数组对象展开成一系列用逗号隔开的值</span><br><span class="line">    let arr = [1, 2, 3, 4, 5];</span><br><span class="line">    console.log(arr);</span><br><span class="line">    console.log(...arr); 1 2 3 4 5</span><br><span class="line"> 2. 数组的合并</span><br></pre></td></tr></table></figure>

     let arr1 = [1, 2, 3];
     let arr2 = [4, 5, 6];
     let arr3 = [7, 8, 9];
     console.log(arr1.concat(arr2, arr3));  [1, 2, 3, 4, 5, 6, 7, 8, 9]
     console.log([...arr1, ...arr2, ...arr3]);  [1, 2, 3, 4, 5, 6, 7, 8, 9]
     <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3.  求数组的最大值。最小值。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    let arr = [34, 5, 6, 234, 1, 5, 6, 7];
    console.log(Math.max(arr)); NaN
    console.log(Math.max(34, 5, 6, 234, 1, 5, 6, 7));
    console.log(Math.max(...arr));
    console.log(Math.min(...arr));
    console.log(Math.max.apply(this, arr)); 234  第一个参数随意设置，第二个参数是数组，数组项的值就是函数本身的参数。
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4.  引用传递赋值。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    let arr1 = [1, 2, 3];
    let arr2 = [...arr1];
    arr2.push(4);
    console.log(arr1);
    console.log(arr2);
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5.  类数组转换成真正的数组。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
     let aLi = document.querySelectorAll(&#39;ul li&#39;); 类数组
     aLi = [...aLi];
     aLi.push(document.body); 这里没有此方法,是类数组。
     console.log(aLi);
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6.  字符串扩展</span><br><span class="line"></span><br><span class="line">    1.  模板字符串(template string)是增强版的字符串，用反引号(`)标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量函数等($&#123;&#125;) - 非常重要。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    let name = &#39;zhangsan&#39;;
    let str = &#39;&lt;li&gt;&#39; + name + &#39;&lt;/li&gt;&#39;;
    document.body.innerHTML = str;

    let str = &#39;&#39;;
    let arr = [1111, 2222, 3333, 4444, 5555]
    for (let i = 0; i &lt; 5; i++) &#123;
        str += &#39;&lt;div class=&quot;box&quot;&gt;&#39; +
            &#39;&lt;ul&gt;&#39; +
            &#39; &lt;li&gt;&#39; +
            &#39; &lt;a href=&quot;#&quot;&gt;&#39; + arr[i] + &#39;&lt;/a&gt;&#39; +
            &#39;&lt;/li&gt;&#39; +
            &#39;&lt;/ul&gt;&#39; +
            &#39;&lt;/div&gt;&#39;
    &#125;
    document.body.innerHTML = str;

    渲染的核心
    let str = &#39;&#39;;
    let arr = [1111, 2222, 3333, 4444, 5555];
    for (let i = 0; i &lt; 5; i++) &#123;
        str += `
            &lt;div class=&quot;box&quot;&gt;
                &lt;ul&gt;
                    &lt;li&gt;
                        &lt;a href=&quot;#&quot;&gt;$&#123;arr[i]&#125;&lt;/a&gt;
                    &lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
        `;
    &#125;
    document.body.innerHTML = str;

    let obj = &#123;
        name: &#39;zhangsan&#39;,
        age: 100,
        sex: &#39;男&#39;,
        show: function() &#123;
             return &#39;我的姓名是&#39; + this.name + &#39;,我今年&#39; + this.age + &#39;岁,我是&#39; + this.sex + &#39;的&#39;;
            return `我的姓名是$&#123;this.name&#125;,我今年$&#123;this.age&#125;岁,我是$&#123;this.sex&#125;的`;
        &#125;
    &#125;

    console.log(obj.show());
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2.  新增数组方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      let str = &#39;hello&#39;;
      repeat(n)方法返回一个新字符串，表示将原字符串重复n次。
      console.log(str.repeat(5));
      includes()：返回布尔值，表示是否找到了参数字符串 - 数组也有此方法。
      console.log(str.includes(&#39;e&#39;));
      console.log(str.includes(&#39;f&#39;));
      startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。
      console.log(str.startsWith(&#39;hel&#39;)); true
      console.log(str.startsWith(&#39;he5&#39;)); false
      endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。
      console.log(str.endsWith(&#39;hel&#39;)); false
      console.log(str.endsWith(&#39;o&#39;)); true
      console.log(str.endsWith(&#39;lo&#39;)); true
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
8. 构造函数 -类
1. 构造函数
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const Fn = function() &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let f1 = new Fn(); Fn:构造函数     f1:实例对象</span><br><span class="line"></span><br><span class="line">2.类 - class</span><br><span class="line"></span><br><span class="line">class Fn1 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let f2 = new Fn1(); Fn1:类     f2:实例对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(typeof Fn); function</span><br><span class="line">console.log(typeof Fn1); function</span><br><span class="line">3.语法糖</span><br><span class="line">指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会</span><br></pre></td></tr></table></figure>

9. Symbol 基本类型
1. Symbol--表示独一无二的值，它是 js 中的第七种数据类型，属于基本类型.

   基本类型：number/string/boolean/null/undefined/Symbol
   引用类型：object

1. 意图：对象的属性自定义的，相同会覆盖。Symbol 定义对象的属性。

   Symbol():首字母大写。
   Symbol 函数前不能使用 new,否则会报错，原因在于 symbol 是一个原始类型的值，不是对象。

   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let s1 = Symbol(&#x27;lisi&#x27;);</span><br><span class="line">let s2 = Symbol(&#x27;wangwu&#x27;);</span><br><span class="line">console.log(s1 == s2);</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">    name: &#x27;zhangsan&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj[s1] = &#x27;lisi&#x27;;</span><br><span class="line">obj[s2] = &#x27;wangwu&#x27;;</span><br><span class="line">obj[Symbol(&#x27;lisi&#x27;)] = &#x27;lisi11111111&#x27;;</span><br><span class="line"></span><br><span class="line">console.log(obj);</span><br><span class="line">console.log(obj[s1]);</span><br><span class="line">console.log(obj[Symbol(&#x27;lisi&#x27;)]);  undefined  不会相等。</span><br><span class="line">console.log(Symbol(&#x27;lisi&#x27;) == Symbol(&#x27;lisi&#x27;));  false  描述的内容相同仅仅表示的是描述，不代表其他的意义</span><br></pre></td></tr></table></figure>

弊端：带有 Symbol 的属性不能被 for...in 遍历出来，其他的可以
Object.getOwnPropertySymbols(obj)方法获取一个对象所有的 symbol 属性。
console.log(Object.getOwnPropertySymbols(obj));

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">10. set和map</span><br><span class="line">1. Set(array)和Map(object)结构</span><br><span class="line">  - 数据结构：数组,自定义的对象  es6新增(Set结构,Map结构)</span><br><span class="line">  - 为什么增加两种结构</span><br><span class="line">2. Set结构</span><br><span class="line">  ES6提供了数据结构Set. 它类似于数组，但是成员的值都是唯一的，没有重复的值。</span><br><span class="line">  Set 本身是一个构造函数，用来生成 Set 数据结构，数组作为参数。</span><br></pre></td></tr></table></figure>

     let s1 = new Set([&#39;applie&#39;, &#39;zhangsan&#39;, 100, 200, 300, &#39;applie&#39;, &#39;zhangsan&#39;, 100, 200, 300]);
     console.log(s1); &#123;&#39;applie&#39;, &#39;zhangsan&#39;, 100, 200, 300&#125;
    
     数组去重 - 扩展运算符依然值set数据结构
     let arr = [&#39;applie&#39;, &#39;zhangsan&#39;, 100, 200, 300, &#39;applie&#39;, &#39;zhangsan&#39;, 100, 200, 300];
     console.log([...new Set(arr)]); [&quot;applie&quot;, &quot;zhangsan&quot;, 100, 200, 300]
    
     Set结构的属性和方法
     let s1 = new Set([&#39;zhangsan&#39;, &#39;lisi&#39;]); s1:set对象
     长度属性：size
     console.log(s1.size); 2
     add():添加一个数据，返回Set结构本身，允许进行链式操作
     s1.add(&#39;wangwu&#39;).add(&#39;apple&#39;).add(&#39;orange&#39;);
     delete(value) 删除指定数据，返回一个布尔值，表示删除是否成功。
     s1.delete(&#39;zhangsan&#39;);
     has(value) 判断该值是否为Set的成员，返回一个布尔值。
     console.log(s1.has(&#39;orange&#39;)); true
     console.log(s1.has(&#39;pear&#39;)); false
     clear() 清除所有的数据， 没有返回值。
     s1.clear();
     forEach()： 使用回调函数遍历每个成员
     s1.forEach((value, index, set) =&gt; &#123;
         console.log(value, index, set);
     &#125;);
     console.log(s1);
     <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">11. map 结构</span><br><span class="line">    - JavaScript 的对象（Object）,只能用字符串当作键。这给它的使用带来了很大的限制。ES6 提供了 Map 数据结构。它类似于对象，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</span><br><span class="line">    - 参数类似于二维数组。</span><br></pre></td></tr></table></figure>
     let obj = &#123;
        a: 1,
        b: 2,
        c: 3
     &#125;;
     let m1 = new Map([
        [true, 1],
        [false, 2],
        [&#123;&#125;, 3],
        [function() &#123;&#125;, 4],
        [undefined, 5],
        [null, 6]
     ]);
     console.log(m1.size); 6
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. map.set(key,value) :设置键名 key 对应的键值 value,然后返回整个 map 结构，如果 key 已经有值，则键值会被更新，否则就生成该键，可以链式操作。</span><br></pre></td></tr></table></figure>
     m1.set([], 7).set(&#39;name&#39;, &#39;zhangsan&#39;).set(1, 8);
     map.get(key) get方法读取key对应的键值，如果找不到key，返回undefined
     console.log(m1.get(1)); 8
     console.log(m1.get(null));6
     console.log(m1.get(undefined));5
     console.log(m1.get([]));undefined   console.log([]==[]);false
     map.delete(key) 删除某个键，返回true.如果删除失败，返回false.
     console.log(m1.delete(null));
     console.log(m1.delete([]));
     map.has(key) 方法返回一个布尔值，表示某个键是否在当前map对象之中。
     console.log(m1.has(&#39;name&#39;)); true
     map.clear() 清除所有数据，没有返回值
     m1.clear();
     map.entries() 返回键值对的遍历器
     console.log(m1.entries());
     map.forEach()   使用回调函数遍历每个成员。
     m1.forEach((value, key) =&gt; &#123;
         console.log(key, value);
     &#125;);
     console.log(m1);
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">12. Generators 生成器函数</span><br><span class="line"></span><br><span class="line">    1. 具体</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    普通函数 √
    函数表达式 √
    自执行函数 √
    事件处理函数 √
    回调函数 √
    箭头函数 √
    构造函数 √
    JavaScript是单线程的，只有一个主线程，一次只能执行一个任务。
    同步和异步
    同步：阻塞模式，后一个任务等到前一个任务执行完成。(顺序执行) - 主线程
    alert(a);
    alert(&#39;hehe&#39;);

    console.log(1);
    console.log(2);
    console.log(3);
    console.log(4);

    异步：非阻塞模式，将任务先放入对列，等待主线程的任务执行完成，执行队列的任务。
    定时器是异步的。
    console.log(1); 同步

    setTimeout(() =&gt; &#123; 异步
        console.log(2);
    &#125;, 20);

    setTimeout(() =&gt; &#123; 异步
        console.log(3);
    &#125;, 0);

    console.log(4); 同步
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    2. Generators 生成器函数 - 解决异步顺序问题</span><br><span class="line">       Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</span><br><span class="line">       Generator 函数是一个状态机，封装了多个内部状态。</span><br><span class="line">       但是有两个特征。</span><br><span class="line">       一是，function 关键字与函数名之间有一个星号；</span><br><span class="line">       二是，函数体内部使用 yield（产出）表达式，定义不同的内部状态.</span><br><span class="line"></span><br><span class="line">    function\* fn() &#123;</span><br><span class="line">    yield &#x27;第一件事件&#x27;;</span><br><span class="line">    yield &#x27;第二件事件&#x27;;</span><br><span class="line">    yield &#x27;第三件事件&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    let gen = fn(); gen:Generator 函数返回遍历器对象  </span><br><span class="line">    就会返回一个有着 value 和 done 两个属性的对象。value 属性表示当前的内部状态的值，是 yield 表达式后面那个表达式的值；done 属性是一个布尔值，表示是否遍历结束</span><br><span class="line">    console.log(gen.next()); &#123;value: &quot;第一件事件&quot;, done: false&#125;</span><br><span class="line">    console.log(gen.next()); &#123;value: &quot;第二件事件&quot;, done: false&#125;</span><br><span class="line">    console.log(gen.next()); &#123;value: &quot;第三件事件&quot;, done: true&#125;</span><br><span class="line"></span><br><span class="line">13. iterator 接口</span><br><span class="line">14. 遍历器（Iterator）它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</span><br><span class="line">15. ES6 创造了一种新的遍历命令 for...of 循环，Iterator 接口主要供 for...of 消费。</span><br><span class="line">16. 一个数据结构只要部署了 Symbol.iterator 属性，就被视为具有 iterator 接口</span><br><span class="line">17. for...of 是目前最优秀的遍历方式。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    let str = &#39;hello&#39;;

    for (let value of str) &#123; value:值
        console.log(value);
    &#125;

    let arr = [&#39;zhangsan&#39;, &#39;lisi&#39;, &#39;wangwu&#39;];

    for (let v of arr) &#123;
        console.log(v);
    &#125;

    let obj = &#123;
        a: 1,
        b: 2,
        c: 3
    &#125;;

    for (let key of obj) &#123;
        console.log(key); 报错：obj is not iterable
    &#125;

    console.log(str[Symbol.iterator]);
    console.log(arr[Symbol.iterator]);
    console.log(obj[Symbol.iterator]);  undefined 对象不可以使用for...of.
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 前后端交互</span><br><span class="line"></span><br><span class="line">1. 前端将数据传输给后端 - form 表单</span><br><span class="line"></span><br><span class="line">   注意：前端无法直接操作数据库，依靠后端进行连接操作。</span><br><span class="line">   注意：只要涉及到后端，必须在服务器中访问。 1.前端通过表单传输值给后端：form + action + method(默认值是 get) + name + submit</span><br><span class="line"></span><br><span class="line">   - action:接收值的页面(后端页面)</span><br><span class="line">   - method:提交方式 post/get</span><br><span class="line">     get 将传输的数据显示在地址栏上面，get 方式提交数据不安全，而且长度有限。</span><br><span class="line">     post 通过设置请求头进行传输，数据不会显示在地址栏，比 get 方式安全，长度比 get 大(4k,可以配置)。</span><br><span class="line">     get 有缓存不安全 POST 没有缓存</span><br><span class="line">   - name:表单的名称，后端的页面能够直接识别此名称。</span><br><span class="line">   - submit:具有跳转的能力。</span><br><span class="line"></span><br><span class="line">2. ajax 概述</span><br><span class="line"></span><br><span class="line">   - AJAX 即&quot;Asynchronous Javascript And XML&quot; (异步 JavaScript 和 XML)，是指一种创建交互式网页应用的网页开发技术。</span><br><span class="line">   - 同步和异步：</span><br><span class="line">     javascript 语言是一门“单线程”(主线程)的语言,，javascript 就像一条流水线.</span><br><span class="line">     同步和异步的差别就在于这条流水线上各个流程的执行顺序不同。</span><br><span class="line">   - 同步：阻塞模式,同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</span><br><span class="line">     for (;;) &#123;&#125;</span><br><span class="line">     alert(&#x27;hehe&#x27;);</span><br><span class="line">   - 异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;的任务，只有等主线程任务执行完毕，&quot;任务队列&quot;开始通知主线程，请求执行任务，该任务才会进入主线程执行。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
     setTimeout(() =&gt; &#123; 异步，队列
         for (;;) &#123;&#125;
     &#125;, 0);
     alert(&#39;hehe&#39;); 同步
     <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     3. xml:可扩展的标记语言。</span><br><span class="line">        特点：</span><br><span class="line">        自由命名标签，但是注意单双标签格式，单标签添加&lt;book /&gt; &lt;name&gt;&lt;/name&gt;</span><br><span class="line">        xml 文件一定需要一个根目录。</span><br><span class="line">        xml 文件必须要有声明。</span><br><span class="line">     4. ajax 获取数据。</span><br><span class="line"></span><br><span class="line">   - get 和 post 都可以获取数据。</span><br><span class="line">   - ajax 传输数据  </span><br><span class="line">     1.get 方式通过?和&amp;符号进行传输</span><br><span class="line">     2.post 通过 send 发送数据，设置请求头。</span><br><span class="line"></span><br><span class="line">     5. get 和 post 区别</span><br><span class="line"></span><br><span class="line">   - 语义化：get 获取 post 传输</span><br><span class="line">   - 安全性：get 不安全 post 安全</span><br><span class="line">   - 数据长度：get 通过地址栏仅能够传输 2000 多个字符，post 理论是没有限制。(自由配置)</span><br><span class="line">   - 缓存问题：get 有缓存，post 没有缓存。 ctrl+h 进行快速清除缓存。</span><br><span class="line">   - 传输数据格式：get 方式通过?和&amp;符号进行传输 post 通过 send 发送数据，设置请求头</span><br><span class="line"></span><br><span class="line"># http 状态码</span><br><span class="line"></span><br><span class="line">1. HTTP 状态码（英语：HTTP Status Code）是用以表示网页服务器超文本传输协议响应状态的 3 位数字代码。</span><br><span class="line">   1 消息</span><br><span class="line">   2 成功</span><br><span class="line">   200 OK 请求已成功，请求所希望的响应头或数据体将随此响应返回。出现此状态码是表示正常状态。</span><br><span class="line">   3 重定向</span><br><span class="line">   304 Not Modified 如果客户端发送了一个带条件的 GET 请求且该请求已被允许， 而文档的内容并没有改变.</span><br><span class="line">   4 请求错误</span><br><span class="line">   404 Not Found 请求失败，请求所希望得到的资源未被在服务器上发现接口地址。</span><br><span class="line">   5 服务器错误</span><br><span class="line">   500 Internal Server Error 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理</span><br><span class="line">   503 Service Unavailable 由于临时的服务器维护或者过载，服务器当前无法处理请求。</span><br><span class="line">   200 OK 服务器成功处理了请求（这个是我们见到最多的）</span><br><span class="line">   204 No Content 请求成功处理，没有实体的主体返回</span><br><span class="line">   206 Partial Content GET 范围请求已成功处理</span><br><span class="line">   301/302 Moved Permanently（重定向）请求的 URL 已移走。Response 中应该包含一个 Location URL, 说明资源现在所处的位置</span><br><span class="line">   303 See Other 临时重定向，期望使用 GET 定向获取</span><br><span class="line">   304 Not Modified 发送的附带条件请求未满足</span><br><span class="line">   307 Temporary Redirect 临时重定向，POST 不会变成 GET</span><br><span class="line">   400 Bad Request 请求报文语法错误或参数错误</span><br><span class="line">   401 Unauthorized 需要通过 HTTP 认证，或认证失败</span><br><span class="line">   403 Forbidden 请求资源被拒绝</span><br><span class="line">   404 Not Found(页面丢失)未找到资源</span><br><span class="line">   500 Internal Server Error 服务器故障或 Web 应用故障</span><br><span class="line">   501 Internal Server Error 服务器遇到一个错误，使其无法对请求提供服务</span><br><span class="line">   503 Service Unavailable 服务器超负载或停机维护</span><br><span class="line">2. 跨域和解决跨域</span><br><span class="line"></span><br><span class="line">   - 为什么会产生跨域(跨域名访问会被阻止)</span><br><span class="line"></span><br><span class="line">   域名：访问网站的一个地址，自由注册的，按年收费，必须是没有被其他机构使用的。因为 ip 地址不好记忆，为了网站更好的推广，所以很多公司花大钱购买。</span><br><span class="line">   同源策略：阻止从一个域名上加载的脚本获取或操作另一个域名上的文档属性。 阻止一个域名操作另一个域名的</span><br><span class="line">   也就是说，受到请求的 URL 的域名必须与当前 Web 页面的域名相同。</span><br><span class="line">   同源策略是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。</span><br><span class="line"></span><br><span class="line">3. 什么情况下会产生跨域。</span><br><span class="line"></span><br><span class="line">   - 域名不同</span><br><span class="line">   - 端口不同</span><br><span class="line">   - 协议不同(http/https)</span><br><span class="line">   - 域名和域名对应的 ip 地址 (localhost 和 127.0.0.1 产生跨域) √</span><br><span class="line">   - 一级域名和二级域名，子域名和主域名产生跨域</span><br><span class="line">   - 同一域名，不同文件夹.</span><br><span class="line">   - 域名和域名对应 Ip</span><br><span class="line"></span><br><span class="line">4. 如何解决跨越问题。</span><br><span class="line">   - 了解后端代理 - 后端不存在跨越 - 后端获取数据给本公司的前端。</span><br><span class="line">   - 了解 cors 解决跨域 - 跨域资源共享,它允许浏览器向跨域源服务器发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。</span><br><span class="line">     需要服务器(提供接口的源码里面)添加下面两句话。</span><br><span class="line">     header(&#x27;Access-Control-Allow-Origin:\*&#x27;);</span><br><span class="line">     header(&#x27;Access-Control-Allow-Method:POST,GET&#x27;);</span><br><span class="line">   - 前端重点关注的 jsonp 解决跨域。</span><br><span class="line">   - nginx - 三阶段学习的反向代理。(也可以使用第三方模块)。</span><br><span class="line"></span><br><span class="line"># 回调函数 callback</span><br><span class="line"></span><br><span class="line">1.  回调函数的概述 函数作参数，传递给另外一个函数。</span><br></pre></td></tr></table></figure>
    let arr = [1, 2, 3, 4, 5];
    console.log(a
    rr.map(function(v) &#123;
    return v;
    &#125;));
         window.setInterval(function() &#123;
             console.log(&#39;定时器&#39;);
         &#125;, 1000);
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2.  回调函数一般可以采用箭头函数进行简写。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    let arr = [1, 2, 3, 4, 5];
    console.log(arr.map((v) =&gt; &#123;
        return v;
    &#125;));

    window.setInterval(() =&gt; &#123;
        console.log(&#39;定时器&#39;);
    &#125;, 1000);
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    3.回调函数+异步代码(定时器,ajax,事件)</span><br><span class="line">    function fnA() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function fnB() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fnA();</span><br><span class="line">    fnB();</span><br><span class="line">    利用回调函数实现异步代码顺序问题。</span><br><span class="line">    function fnA(fnB) &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    fnB();</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function fnB() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">    fnA(fnB);</span><br><span class="line"></span><br><span class="line">    上面的写法不合理，不是最优的</span><br><span class="line">    function fnA(fnB) &#123; fnB 是一个回调函数</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    fnB &amp;&amp; typeof fnB === &#x27;function&#x27; &amp;&amp; fnB(); 回调函数必须做的判断。</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fnA(function() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    fnA();</span><br><span class="line">    fnA(123);</span><br><span class="line"></span><br><span class="line">3.  传一个对象</span><br><span class="line">    function fn(obj) &#123; obj 是对象</span><br><span class="line">    let data = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2,</span><br><span class="line">    c: 3</span><br><span class="line">    &#125;;</span><br><span class="line">    obj.show(data);</span><br><span class="line">    obj.show &amp;&amp; typeof obj.show === &#x27;function&#x27; &amp;&amp; obj.show(data);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let obj = &#123;</span><br><span class="line">    show: function(d) &#123;</span><br><span class="line">    console.log(d); &#123;a: 1, b: 2, c: 3&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fn(obj);</span><br><span class="line"></span><br><span class="line">    ***</span><br><span class="line"></span><br><span class="line">    function fn(callback) &#123; callback 是函数</span><br><span class="line">    let data = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2,</span><br><span class="line">    c: 3</span><br><span class="line">    &#125;;</span><br><span class="line">    callback(data);</span><br><span class="line">    callback &amp;&amp; typeof callback === &#x27;function&#x27; &amp;&amp; callback(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn(function(d) &#123;</span><br><span class="line">    console.log(d);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"># Promiese -es6</span><br><span class="line"></span><br><span class="line">一.promise - 承诺的意思。 1.概念：Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。</span><br><span class="line">2.Promise 对象有以下两个特点。</span><br><span class="line">Promise 对象代表一个异步操作，有三种状态：pending(进行中),fulfilled(resolve 已成功)和 rejected(已失败)</span><br><span class="line">Promise 对象的状态改变,只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生.</span><br><span class="line">一旦状态设定，就不会再变。</span><br><span class="line"></span><br><span class="line">    3.操作promise - 类</span><br><span class="line">    3.1.新建promise实例对象。</span><br><span class="line">    let pro = new Promise(function(resolve, reject) &#123;</span><br><span class="line">         resolve: 从pending变为fulfilled,</span><br><span class="line">         reject: pending变为rejected</span><br><span class="line">         resolve和reject两个参数其实是两个函数。 必须添加括号调用</span><br><span class="line">         开始自由设定状态。</span><br><span class="line">         console.log(&#x27;starting&#x27;);</span><br><span class="line">        resolve(&#x27;这是resolve传输的&#x27;); 成功</span><br><span class="line">        reject(); 失败</span><br><span class="line">        console.log(&#x27;jieshu&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    3.2.promise实例对象下面的两个方法</span><br><span class="line">     Promise.prototype.then: 如果上面的状态设置为resolve，执行then里面的代码,resolve的参数是函数。</span><br><span class="line">    </span><br><span class="line">     Promise.prototype.catch:如果上面的状态设置为reject，执行catch里面的代码,reject的参数是函数。</span><br><span class="line">     Promise.prototype.finally:finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作 - es2018</span><br><span class="line">    </span><br><span class="line">    采用链式的写法。</span><br><span class="line">    pro.then(function(value) &#123;</span><br><span class="line">        console.log(value);</span><br><span class="line">    &#125;).catch(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;catch....ending&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    callback写法</span><br><span class="line">     function fnA(fnB) &#123; fnB是一个回调函数</span><br><span class="line">         setTimeout(() =&gt; &#123;</span><br><span class="line">             console.log(1);</span><br><span class="line">             fnB &amp;&amp; typeof fnB === &#x27;function&#x27; &amp;&amp; fnB(); 回调函数必须做的判断。</span><br><span class="line">         &#125;, 2000)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     fnA(function() &#123;</span><br><span class="line">         setTimeout(() =&gt; &#123;</span><br><span class="line">             console.log(2);</span><br><span class="line">         &#125;, 1000)</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    promise写法</span><br><span class="line">     function fnA() &#123;</span><br><span class="line">         let promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">             setTimeout(() =&gt; &#123;</span><br><span class="line">                 console.log(1);</span><br><span class="line">                 resolve(&#x27;hello&#x27;); resolve是函数，里面可以传递参数，resolve里面的参数传给then里面函数。</span><br><span class="line">             &#125;, 2000)</span><br><span class="line">         &#125;);</span><br><span class="line">         return promise;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     fnA().then((data) =&gt; &#123;</span><br><span class="line">         setTimeout(() =&gt; &#123;</span><br><span class="line">             console.log(2);</span><br><span class="line">             console.log(data); hello</span><br><span class="line">         &#125;, 1000);</span><br><span class="line">     &#125;).then(() =&gt; &#123;</span><br><span class="line">         console.log(&#x27;3&#x27;);</span><br><span class="line">     &#125;).then(() =&gt; &#123;</span><br><span class="line">         console.log(&#x27;4&#x27;);</span><br><span class="line">     &#125;).then(() =&gt; &#123;</span><br><span class="line">         console.log(&#x27;5&#x27;);</span><br><span class="line">     &#125;).finally(() =&gt; &#123;</span><br><span class="line">         console.log(&#x27;finally&#x27;);</span><br><span class="line">     &#125;)</span><br><span class="line">    1.Promise.all()： 用于将多个 Promise 实例， 包装成一个新的 Promise 实例，接受一个数组作为参数，只有数组里面的每个状态都变成resolve， 则新的 Promise 实例状态才会变成resolve.</span><br><span class="line">    let p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        resolve(&#x27;第一个promise&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    let p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        reject(&#x27;第二个promise&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    let p3 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        resolve(&#x27;第三个promise&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    let newpromise = Promise.all([p1, p2, p3]);</span><br><span class="line">    newpromise.then((value) =&gt; &#123;</span><br><span class="line">        console.log(&#x27;then,成功&#x27;, value);  或者value data = [&quot;第一个promise&quot;, &quot;第二个promise&quot;, &quot;第三个promise&quot;]</span><br><span class="line">    &#125;).catch(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;catch,失败&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    2.Promise.race()： 方法同样是将多个 Promise 实例， 包装成一个新的 Promise 实例， 接受一个数组作为参数， 只要其中有一个实例率先改变状态， 则整个的状态就跟着改变。</span><br><span class="line">     let p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">         setTimeout(() =&gt; &#123;</span><br><span class="line">             resolve(&#x27;第一个promise&#x27;);</span><br><span class="line">         &#125;, 1000)</span><br><span class="line">    </span><br><span class="line">     &#125;);</span><br><span class="line">     let p2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">         setTimeout(() =&gt; &#123;</span><br><span class="line">             reject(&#x27;第一个promise&#x27;);</span><br><span class="line">         &#125;, 200)</span><br><span class="line">     &#125;);</span><br><span class="line">     let p3 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">         setTimeout(() =&gt; &#123;</span><br><span class="line">             resolve(&#x27;第一个promise&#x27;);</span><br><span class="line">         &#125;, 3000)</span><br><span class="line">     &#125;);</span><br><span class="line">     let newpromise = Promise.race([p1, p2, p3]);</span><br><span class="line">     newpromise.then((data) =&gt; &#123;</span><br><span class="line">         console.log(&#x27;then,成功&#x27;);</span><br><span class="line">     &#125;).catch(() =&gt; &#123;</span><br><span class="line">         console.log(&#x27;catch,失败&#x27;);</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line"># Day 24_cookie+localStorage</span><br><span class="line"></span><br><span class="line">1.本地存储的概念：</span><br><span class="line">在 HTML5 中，新加入了一个 localStorage 特性，这个特性主要是用来作为本地存储来使用的，localStorage 中一般浏览器支持的是 5M 大小，这个在不同的浏览器中 localStorage 会有所不同。</span><br><span class="line"></span><br><span class="line">    2.本地存储的特点：</span><br><span class="line">    localStorage永久存储，除非手动删除。</span><br><span class="line">    localStorage只有在高版本的浏览器中才支持的</span><br><span class="line">    localStorage的值类型限定为string类型(JSON.stringify)。</span><br><span class="line">    localStorage如果存储内容多的话会消耗内存空间，会导致页面变卡。</span><br><span class="line">    localStorage不同的浏览器不能相互进行访问存储的数据。</span><br><span class="line">    </span><br><span class="line">    3.本地存储存取删</span><br><span class="line">       1.localStorage的写入有三种方法</span><br><span class="line">     目前所有的浏览器中都会把localStorage的值类型限定为string类型,永久存储，除非手动删除</span><br><span class="line">     键值对key:value</span><br><span class="line">     window.localStorage.key=value</span><br><span class="line">     window.localStorage[key]=value</span><br><span class="line">     window.localStorage.setItem(key,value) - 最优的</span><br><span class="line">    </span><br><span class="line">     2.存储字符串</span><br><span class="line">    localStorage.name = &#x27;张三&#x27;;</span><br><span class="line">    localStorage[&#x27;age&#x27;] = 100;</span><br><span class="line">    localStorage.setItem(&#x27;sex&#x27;, &#x27;男&#x27;);</span><br><span class="line">    </span><br><span class="line">    3.存储数组和对象。</span><br><span class="line">    let arr = [&#x27;zhangsan&#x27;, &#x27;lisi&#x27;, &#x27;wangwu&#x27;];</span><br><span class="line">    let obj = &#123;</span><br><span class="line">        a: 1,</span><br><span class="line">        b: 2,</span><br><span class="line">        c: 3</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    localStorage.setItem(&#x27;data_arr&#x27;, arr);</span><br><span class="line">    localStorage.setItem(&#x27;data_obj&#x27;, JSON.stringify(obj));</span><br><span class="line">      localStorage的读取 - 通过key获取对应的值,如果key值,不存在输出null</span><br><span class="line">     window.localStorage.key</span><br><span class="line">     window.localStorage[key]</span><br><span class="line">     window.localStorage.getItem(key) - 最优</span><br><span class="line">    </span><br><span class="line">     console.log(localStorage.name);</span><br><span class="line">     console.log(localStorage[&#x27;data_obj&#x27;]); &#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3&#125;</span><br><span class="line">     console.log(JSON.parse(localStorage[&#x27;data_obj&#x27;]));</span><br><span class="line">     console.log(localStorage.getItem(&#x27;data_arr&#x27;)); zhangsan,lisi,wangwu</span><br><span class="line">     console.log(localStorage.getItem(&#x27;data_arr&#x27;).split(&#x27;,&#x27;)); [&quot;zhangsan&quot;, &quot;lisi&quot;, &quot;wangwu&quot;]</span><br><span class="line">      localStorage的删除</span><br><span class="line">     1、将localStorage的所有内容清除.</span><br><span class="line">     window.localStorage.clear();</span><br><span class="line">    </span><br><span class="line">     2、将localStorage中的某个键值对删除</span><br><span class="line">     window.localStorage.removeItem(&quot;a&quot;);</span><br><span class="line">    </span><br><span class="line">     console.log(localStorage.getItem(&#x27;name&#x27;)); 张三</span><br><span class="line">     window.localStorage.removeItem(&quot;name&quot;);</span><br><span class="line">     console.log(localStorage.getItem(&#x27;name&#x27;)); null  如果删除了返回的是null</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     window.localStorage.clear();</span><br><span class="line">      sessionStorage</span><br><span class="line">    sessionStorage和localStorage其他的特点是一样的，唯一的区别是localStorage是永久的，sessionStorage是临时的，会话结束就消失了，不存在设置时间。</span><br><span class="line">    </span><br><span class="line">     sessionStorage.setItem(&#x27;name&#x27;, &#x27;zhangsan&#x27;);</span><br><span class="line">     一.cookie的概述</span><br><span class="line">    1.cookie的概念：</span><br><span class="line">    Cookie又叫[会话跟踪技术]是由[Web服务器]保存在用户浏览器上的小文本文件，它可以包含相关用户的信息。无论何时用户链接到服务器，Web站点都可以访问Cookie信息。</span><br><span class="line">    </span><br><span class="line">    2.web服务器 - http/https</span><br><span class="line">     两台计算机在进行通信时，必须使用的通信协议。</span><br><span class="line">     HTTP协议:超文本传输协议是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准TCP。 所有的WWW文件都必须遵守这个标准。 客户端发起一个到服务器上指定端口（ 默认端口为80） 的HTTP请求。</span><br><span class="line">     HTTPS 协议:是以安全为目标的 HTTP 通道， 在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性。 HTTPS 在HTTP 的基础下加入SSL层， HTTPS的安全基础是SSL， 因此加密的详细内容就需要 SSL。</span><br><span class="line">    </span><br><span class="line">    3.cookie的特点</span><br><span class="line">    3.1.禁用cookie后，无法正常注册登陆。</span><br><span class="line">    3.2.cookie是与浏览器相关的，不同浏览器之间所保存的cookie也是不能互相访问的；</span><br><span class="line">    3.3.cookie可以被删除。因为每个cookie都是硬盘上的一个文件；</span><br><span class="line">    3.4.cookie安全性不够高-xss攻击</span><br><span class="line">    </span><br><span class="line">    4.对比和localStorage区别</span><br><span class="line">    cookie仅支持4kb,localStorage支持5MB</span><br><span class="line">    cookie自由设定过期时间,localStorage是永久的。</span><br><span class="line">    localStorage是html5新增的，有兼容问题。</span><br><span class="line">    localStorage本地存储，cookie服务器存储。</span><br><span class="line">      cookie的存取删</span><br><span class="line">    1.cookie的存储</span><br><span class="line">    1.1.cookie存储 - 没有过期时间的，会话结束即消失(关闭浏览器就消失)</span><br><span class="line">     document.cookie = &#x27;xingming=zhangsan&#x27;; 存储字符串，name-&gt;value形式  name值相同，会覆盖。</span><br><span class="line">    </span><br><span class="line">    1.2.cookie存储 - 添加过期时间。</span><br><span class="line">    expires:过期时间(保存的时间)</span><br><span class="line">     let d = new Date(); 创建日期对象。</span><br><span class="line">     d.setDate(d.getDate() + 10); 设置日期，自动进位,10天后的日期。</span><br><span class="line">     document.cookie = &#x27;age=100;expires=&#x27; + d;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    1.3.cookie存储 - 路径问题 - path:/  表示存储在根目录下面。</span><br><span class="line">     不同目录存储的cookie不能互相访问。两个文件夹里面分别存储的cookie，不能互相访问。</span><br><span class="line">     console.log(document.cookie); xingming=zhangsan; age=100</span><br><span class="line">    </span><br><span class="line">     let d = new Date(); 创建日期对象。</span><br><span class="line">     let arr = [1, 2, 3, 4, 5];</span><br><span class="line">     d.setDate(d.getDate() + 10); 设置日期，自动进位,10天后的日期。</span><br><span class="line">     document.cookie = `arrdata=$&#123;arr&#125;;path=/;expires=$&#123;d&#125;`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    1.4.cookie存储 - 中文问题(中文最好编码)</span><br><span class="line">     encodeURIComponent:将中文，特殊字符进行编码。</span><br><span class="line">     decodeURIComponent:将中文，特殊字符进行解码。</span><br><span class="line">    </span><br><span class="line">     let d = new Date(); 创建日期对象。</span><br><span class="line">     d.setDate(d.getDate() + 10); 设置日期，自动进位,10天后的日期。设置未来消失时间</span><br><span class="line">     document.cookie = `name=$&#123;decodeURIComponent(&#x27;最帅席佳杰&#x27;)&#125;;path=/;expires=$&#123;d&#125;`;</span><br><span class="line">     document.cookie = `sex=$&#123;encodeURIComponent(&#x27;18cm&#x27;)&#125;;path=/;expires=$&#123;d&#125;&#125;`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    封装函数实现cookie存储</span><br><span class="line">    function setcookie(name, value, days) &#123; days存储的天数</span><br><span class="line">        let d = new Date(); 创建日期对象。</span><br><span class="line">        d.setDate(d.getDate() + days); 设置日期，自动进位,10天后的日期。</span><br><span class="line">        document.cookie = `$&#123;name&#125;=$&#123;encodeURIComponent(value)&#125;;path=/;expires=$&#123;d&#125;`;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     setcookie(&#x27;xijiajie&#x27;, &#x27;xijiajie18cm&#x27;, 5);</span><br><span class="line">    对象存储。</span><br><span class="line">     let obj = &#123;</span><br><span class="line">         a: 1,</span><br><span class="line">         b: 2,</span><br><span class="line">         c: 3</span><br><span class="line">     &#125;;</span><br><span class="line">     console.log(JSON.stringify(obj));   &#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3&#125; 转换成json格式的字符串</span><br><span class="line">     setcookie(&#x27;obj_data&#x27;, JSON.stringify(obj), 7); 	&#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3&#125;</span><br><span class="line">    </span><br><span class="line">    setcookie(&#x27;n1&#x27;, 100, 7);</span><br><span class="line">    setcookie(&#x27;n2&#x27;, 200, 7);</span><br><span class="line">    setcookie(&#x27;n3&#x27;, 300, 7);</span><br><span class="line">    setcookie(&#x27;n4&#x27;, &#x27;结束&#x27;, 7);</span><br><span class="line">    </span><br><span class="line">     2.获取cookie - 封装</span><br><span class="line">    console.log(decodeURIComponent(document.cookie)); n1=100; n2=200; n3=300; n4=结束</span><br><span class="line">    function getcookie(name) &#123; name = n1.n2.n3.n4</span><br><span class="line">    </span><br><span class="line">        let arr = decodeURIComponent(document.cookie).split(&#x27;; &#x27;); 字符串利用方法变成数组注意有个空格 因为cookie上面有空格</span><br><span class="line">        console.log(arr); [&quot;n1=100&quot;, &quot;n2=200&quot;, &quot;n3=300&quot;, &quot;n4=结束&quot;]</span><br><span class="line">        for (let value of arr) &#123;</span><br><span class="line">            let newarr = value.split(&#x27;=&#x27;); 拆分成四个数组 [&quot;n1&quot;, &quot;100&quot;]  [&quot;n2&quot;, &quot;200&quot;] [&quot;n3&quot;, &quot;300&quot;] [&quot;n4&quot;, &quot;结束&quot;]</span><br><span class="line">            console.log(arr); 输出四个数组</span><br><span class="line">            console.log(value); n1=100 n2=200 n3=300 n4=结束</span><br><span class="line">            console.log(newarr);</span><br><span class="line">            if (newarr[0] === name) &#123; 如果这四个数组的第0项是name的话.</span><br><span class="line">                return newarr[1] return返回的值给调用的结果</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    getcookie(&#x27;n1&#x27;);</span><br><span class="line">     getcookie(&#x27;n2&#x27;);</span><br><span class="line">     getcookie(&#x27;n3&#x27;);</span><br><span class="line">     getcookie(&#x27;n4&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     console.log(getcookie(&#x27;n1&#x27;)); 100</span><br><span class="line">     console.log(getcookie(&#x27;n4&#x27;)); &#x27;结束&#x27;</span><br><span class="line">    </span><br><span class="line">     function getcookie(name) &#123;</span><br><span class="line">         let arr = decodeURIComponent(document.cookie).split(&#x27;; &#x27;);</span><br><span class="line">         for (let value of arr) &#123;</span><br><span class="line">             let newarr = value.split(&#x27;=&#x27;);</span><br><span class="line">             if (newarr[0] === name) &#123;</span><br><span class="line">                 return newarr[1]</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     3.删除 - 通过设置cookie配合过期时间实现 直接安排一个-1</span><br><span class="line">     设置相同的name值(key值)会覆盖</span><br><span class="line">     function delcookie(name) &#123;</span><br><span class="line">         setcookie(name, &#x27;&#x27;, -1);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     delcookie(&#x27;n2&#x27;);</span><br><span class="line">     delcookie(&#x27;n3&#x27;);</span><br><span class="line">     delcookie(&#x27;n4&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    命名空间:利用名称的不同解决一些基本的冲突。弊端：名称太长。</span><br><span class="line">     let zhangsan = &#123;&#125;;</span><br><span class="line">     zhangsan.item1 = &#123;&#125;;</span><br><span class="line">     zhangsan.item1.queue = &#123;&#125;;</span><br><span class="line">     zhangsan.item1.queue.tool = &#123;</span><br><span class="line">         set: function() &#123;</span><br><span class="line">             alert(&#x27;set&#x27;)</span><br><span class="line">         &#125;,</span><br><span class="line">         get: function() &#123;</span><br><span class="line">             alert(&#x27;get&#x27;)</span><br><span class="line">         &#125;,</span><br><span class="line">         remove: function() &#123;</span><br><span class="line">             alert(&#x27;remove&#x27;)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"># Day 26\_闭包和继承</span><br><span class="line"></span><br><span class="line">一.变量的作用域:就是指变量的有效范围 1.全局作用域：作用于整个文档。 2.局部作用域：作用于函数内部。 3.块级作用域：作用于代码块内。</span><br><span class="line"></span><br><span class="line">    二.变量的生存周期</span><br><span class="line">    生存周期对于全局变量是永久的，除非我们主动销毁这个全局变量。(将变量设置为null,等待垃圾回收机制)</span><br><span class="line">    而对于在函数内用 var 关键字声明的局部变量来说，当退出函数时，它们都会随着函数调用的结束而被销毁。</span><br><span class="line">    总结:全局变量一直存在，少用，函数内部的变量用完即销毁，可以用。</span><br><span class="line">    </span><br><span class="line">    三.闭包的概念</span><br><span class="line">    1.闭包就是能够读取其他函数内部变量的函数。</span><br><span class="line">    定义在一个函数内部的函数- 函数嵌套函数。</span><br><span class="line">     function fn() &#123;</span><br><span class="line">         var num = 10;</span><br><span class="line">    </span><br><span class="line">         function fn1() &#123;</span><br><span class="line">             console.log(num); 10 函数内部的变量，是给函数内部的函数使用。</span><br><span class="line">         &#125;</span><br><span class="line">         fn1();</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     fn();</span><br><span class="line">    </span><br><span class="line">     console.log(num); 报错：num is not define</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    2.闭包的结构 - 自执行函数 ( )</span><br><span class="line">     ! function() &#123;</span><br><span class="line">         var num = 10;</span><br><span class="line">    </span><br><span class="line">         function fn1() &#123;</span><br><span class="line">             console.log(num); 10 函数内部的变量，是给函数内部的函数使用。</span><br><span class="line">         &#125;</span><br><span class="line">         fn1();</span><br><span class="line">     &#125;();</span><br><span class="line">    </span><br><span class="line">     ! function() &#123;</span><br><span class="line">         var num = 10;</span><br><span class="line">    </span><br><span class="line">         function fn1() &#123;</span><br><span class="line">             console.log(num); 10 函数内部的变量，是给函数内部的函数使用。</span><br><span class="line">         &#125;</span><br><span class="line">         fn1();</span><br><span class="line">     &#125;();</span><br><span class="line">    </span><br><span class="line">    3.通过闭包的写法，函数外面可以获取函数内部的变量 - (将函数内部的变量通过内部函数返回出来)</span><br><span class="line">     function fn() &#123;</span><br><span class="line">         var num = 1000;</span><br><span class="line">         return function() &#123;</span><br><span class="line">             return ++num;</span><br><span class="line">         &#125;;</span><br><span class="line">     &#125;</span><br><span class="line">     var num1 = fn();</span><br><span class="line">     console.log(num1()); 1000</span><br><span class="line">    </span><br><span class="line">    4.闭包的结构会使函数内部的变量一直存在,影响性能，垃圾回收机制都没办法回收(浏览器关闭之前)。</span><br><span class="line">    这也是闭包的弊端。</span><br><span class="line">    解决方式将变量的值设为null.</span><br><span class="line">    function fn() &#123;</span><br><span class="line">        var num = 10;</span><br><span class="line">        return function() &#123;</span><br><span class="line">            return ++num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     console.log(fn()); return返回值是一个函数时,将这个值 也就是函数体给调用者</span><br><span class="line">     var f = fn(); function() &#123; console.log(num);&#125;</span><br><span class="line">     f(); 11</span><br><span class="line">     f(); 12</span><br><span class="line">     f(); 13</span><br><span class="line">     f(); 14</span><br><span class="line">     f(); 15</span><br><span class="line">    </span><br><span class="line">    四.闭包结构的特点：</span><br><span class="line">    1.没有全局变量。</span><br><span class="line">    2.闭包的写法，可以解决多人协作的冲突问题。(每一个结构都是独立的)</span><br><span class="line">    3.闭包会使函数内部的变量一直存在(延长变量的作用域),垃圾回收机制都没办法回收，影响性能。</span><br><span class="line">    4.函数外面可以获取函数内部的变量(将函数内部的变量通过内部函数返回出来)</span><br><span class="line">    5.闭包使用不当，会产生内存泄漏</span><br><span class="line">    当变量不再使用，会有垃圾回收机制进行回收。如果出现变量不再使用，而垃圾回收机制无法回收。可能形成内存泄漏。</span><br><span class="line">    </span><br><span class="line">    垃圾回收机制</span><br><span class="line">    1.标记清除方式</span><br><span class="line">    工作原理：当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。</span><br><span class="line">    </span><br><span class="line">    2.引用计数方式</span><br><span class="line">    工作原理：跟踪记录每个值被引用的次数。如果引用次数为0，就被回收。</span><br><span class="line">    </span><br><span class="line">    在执行click的函数的时候，会有一个作用域链，这个作用域链是一个对象列表，这组对象定义了代码作用域中的变量。</span><br><span class="line">     当我们alert(i)的时候，会去从内到外的去寻找变量i。这个时候这个函数的作用域链上有5个对象，这时循环已经结束了，i此时的值为5.所以点击任何一个li，弹出的都是5，而不是我们想要的索引值</span><br><span class="line">     const aLi = document.querySelectorAll(&#x27;li&#x27;);</span><br><span class="line">     for (var i = 0; i &lt; aLi.length; i++) &#123;</span><br><span class="line">         aLi[i].onclick = function() &#123;可以参考事件处理函数也是异步的，for循环是同步的要等同步执行完成.</span><br><span class="line">             alert(i); 这里的i是循环的最后一次值。一旦有了点击事件，意味着循环结束了。</span><br><span class="line">         &#125;;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     const aLi = document.querySelectorAll(&#x27;li&#x27;);</span><br><span class="line">     for (let i = 0; i &lt; aLi.length; i++) &#123;</span><br><span class="line">         aLi[i].onclick = function() &#123;</span><br><span class="line">             alert(i); i循环的值,let声明的变量绑定在块区域里面。</span><br><span class="line">         &#125;;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    闭包的写法</span><br><span class="line">     const aLi = document.querySelectorAll(&#x27;li&#x27;);</span><br><span class="line">     for (var i = 0; i &lt; aLi.length; i++) &#123;</span><br><span class="line">         i:0-4</span><br><span class="line">         ! function(i) &#123; 形参 var i</span><br><span class="line">             aLi[i].onclick = function() &#123;</span><br><span class="line">                 alert(i); 0-4</span><br><span class="line">             &#125;;</span><br><span class="line">         &#125;(i); i:实参0-4</span><br><span class="line">    </span><br><span class="line">     &#125;</span><br><span class="line">    一.闭包的用途</span><br><span class="line">    1.js代码结构的一种写法 - 避免冲突。</span><br><span class="line">    2.闭包保存循环变量的值</span><br><span class="line">     3.避免全局变量的污染--闭包里面的变量都是局部的--利用闭包的写法进行开发</span><br><span class="line">    </span><br><span class="line">    4.函数的防抖和节流</span><br><span class="line"></span><br><span class="line"># 防抖和节流</span><br><span class="line"></span><br><span class="line">函数的防抖和节流</span><br><span class="line">解决函数执行的次数 - 利用定时器延迟。</span><br><span class="line"></span><br><span class="line">2.函数的节流</span><br><span class="line">​ 函数节流（throttle）：指定时间间隔内，若事件被多次触发，只会执行一次</span><br><span class="line">​ const oInput = document.querySelector(&#x27;input&#x27;);</span><br><span class="line">​ oInput.oninput = throttle(fn, 2000); 函数体</span><br><span class="line">​  </span><br><span class="line">​ function fn() &#123;</span><br><span class="line">​ console.log(&#x27;我被触发了&#x27;);</span><br><span class="line">​ &#125;</span><br><span class="line">​ 根据题目的意思，大于 2000 毫秒执行一次，通过时间差。</span><br><span class="line">​ function throttle(fn, delay) &#123;</span><br><span class="line">​ let startTime = 0; 初始时间</span><br><span class="line">​ return function() &#123;</span><br><span class="line">​ let currentTime = new Date().getTime(); 获取当前时间的毫秒数 1970.1.1 离当前时间的毫秒数</span><br><span class="line">​ console.log(currentTime - startTime);</span><br><span class="line">​ if (currentTime - startTime &gt; delay) &#123; 第一次的事件时间和第二次事件的时间&gt;2000，触发事件</span><br><span class="line">​ fn.apply(this, arguments); 触发事件 不断计算之后才触发</span><br><span class="line">​ startTime = currentTime; 当前的时间赋值给上一次的时间</span><br><span class="line">​ &#125;</span><br><span class="line">​ &#125;</span><br><span class="line">​ &#125;</span><br><span class="line"></span><br><span class="line"># 面向对象</span><br><span class="line"></span><br><span class="line">一.面向对象的特点</span><br><span class="line">封装 - √</span><br><span class="line">继承 - √</span><br><span class="line">多态</span><br><span class="line"></span><br><span class="line">    二.面向对象和面向过程的区别</span><br><span class="line">    1.面向过程：顺序。</span><br><span class="line">    2.面向对象：拆分,大项目拆分成小项目。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    三.面向对象的两种写法</span><br><span class="line">    1.构造函数+原型(prototype)</span><br><span class="line">    2.class开发 - constructor - 构造函数</span><br><span class="line">    </span><br><span class="line">    四.面向对象的注意问题</span><br><span class="line">    1.this指向 - 箭头函数</span><br><span class="line">    2.属性和方法 - 避免全局变量</span><br><span class="line">    3.new运算符 - 创建空对象给了this,将属性和方法绑定在this上面,隐式返回this</span><br><span class="line"></span><br><span class="line">#  原型链继承</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  一.面向对象的继承
    概念：子类继承父类，但是不能影响父类。

     原型继承：原型链继承:将父类的实例给子类的原型Student.prototype=new Person(),将子类的构造函数改成父类的构造函数
    二.面向对象的继承
    1.混合继承
    混合继承：构造函数+原型继承
    1.1.构造函数的继  承：构造函数首字母大写，new运算符调用。构造函数里面的属性和方法都是私有的.
    构造函数里面属性和方法的继承通过call或者apply。
 2.class继承
     class的继承采用两个关键字：extends  super
     extends关键字：
     Class 可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。

     super关键字：
     子类必须在constructor方法中调用super方法，否则新建实例时会报错。 这是因为子类自己的this对象,必须先通过父类的构造函数完成塑造。
     super关键字既可以当作函数使用， 也可以当作对象使用。
     第一种情况， super作为函数调用时， 代表父类的构造函数。
     第二种情况， super作为对象时， 在普通方法中， 指向父类的原型对象；




    function Person(name, age, sex) &#123;
        this.name = name;
        this.age = age;
        this.sex = sex;
         this.show = function() &#123;
             return this.name + this.age + this.sex;
         &#125;
    &#125;




     let p1 = new Person(&#39;zhangsan&#39;, 100, &#39;男&#39;);
     console.log(p1.name);
     console.log(p1.age);
     console.log(p1.sex);
     console.log(p1.show());

    function Student(name, age, sex, grade) &#123;
         其他的东西继承父类的。
         Person.call(this, name, age, sex);
        Person.apply(this, arguments); Person.apply(this,[name,age,sex])
        this.grade = grade;
    &#125;

     1.2.原型的继承：每一个函数都有一个原型属性，原型上面的属性和方法是公有的。
     原型是对象，对象间直接拷贝继承。
    Person.prototype.show = function() &#123;
        return this.name + this.age + this.sex;
    &#125;

     Person.prototype = &#123;
         show: function() &#123;
             return this.name + this.age + this.sex;
         &#125;
     &#125;
     原型继承 - 拷贝继承
     Student.prototype = Person.prototype;对象间采用=进行赋值,变成引用传递,不合适
     for (let i in Person.prototype) &#123; 浅拷贝，一一赋值,写法比较啰嗦
         Student.prototype[i] = Person.prototype[i];
     &#125;

     Object.assign(Student.prototype, Person.prototype); 比较简洁
     原型继承 - 原型链继承
     原型继承：原型链继承:将父类的实例给子类的原型Student.prototype=new Person(),将子类的构造函数改成父类的构造函数



     let obj = &#123;
         a: 1,
         b: 2,
         c: 3
     &#125;;
     let obj1 = &#123;&#125;;
     for (let i in obj) &#123; 浅拷贝，一一赋值
         obj1[i] = obj[i];
     &#125;
     console.log(obj1);


    Student.prototype= new Person() ƒ Person(name, age, sex) &#123;
         this.name = name;
         this.age = age;
         this.sex = sex;
         this.show = function() &#123;
             return this.name + this.age + this.sex;
         /…
    Student.prototype.constructor = Student ; 将子类的构造函数改变过来   Student 函数名就是函数体


    let s1 = new Student(&#39;李四&#39;, 250, &#39;女&#39;, &#39;h5_2010&#39;);
    console.log(s1.name); 继承的
    console.log(s1.grade); 自己的
    console.log(s1.show()); 继承的
    console.log(s1.constructor)
    2.class继承
     class的继承采用两个关键字：extends  super
     extends关键字：
     Class 可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。

     super关键字：
     子类必须在constructor方法中调用super方法，否则新建实例时会报错。 这是因为子类自己的this对象,必须先通过父类的构造函数完成塑造。
     super关键字既可以当作函数使用， 也可以当作对象使用。
     第一种情况， super作为函数调用时， 代表父类的构造函数。
     第二种情况， super作为对象时， 在普通方法中， 指向父类的原型对象；

     class Person &#123;
         constructor(name, age, sex) &#123;
             this.name = name;
             this.age = age;
             this.sex = sex;
         &#125;
         show() &#123;
             return this.name + this.age + this.sex;
         &#125;
     &#125;

     class Student extends Person &#123; 子类继承父类
         constructor(name, age, sex, grade) &#123;
             super(name, age, sex); 表示继承类里面的属性和方法。 - 当做函数使用
             子类没有this，this来自于父类，必须先继承才有this可用。先有super
             this.grade = grade;
         &#125;
         show() &#123; 如果子类也拥有和父类一样的方法，子类方法优先
             return super.show() + this.grade; 这里的super当对象使用
         &#125;
     &#125;

     let s1 = new Student(&#39;wangwu&#39;, 360, &#39;不男不女&#39;, &#39;h5_2010班级&#39;);
     console.log(s1.name); 继承的
     console.log(s1.grade); 自己的
     console.log(s1.show()); 继承的



    梳理继承
    1.混合继承：构造函数(call/apply)+原型(拷贝继承)
    2.class继承：extends + super(super放到构造函数里面，super既是函数又是对象)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 闭包和继承的复习</span><br><span class="line"></span><br><span class="line">```0</span><br><span class="line">    一.闭包</span><br><span class="line">    1.闭包的概念：闭包就是能够读取其他函数内部变量的函数.</span><br><span class="line"></span><br><span class="line">    2.闭包的特点</span><br><span class="line">    2.1.希望一个变量长期存储在内存中（延长变量作用域）。</span><br><span class="line">    2.2.避免全局的污染，私有成员（函数内部的变量）的存在。</span><br><span class="line">    2.3.函数外面获取函数内部的变量(局部变量)。</span><br><span class="line">    2.4.弊端：闭包使得内部的变量一直存在(浏览器垃圾回收机制失效，内存泄漏)，变量常驻内存，增加内存使用量--手动销毁，设为null。</span><br><span class="line"></span><br><span class="line">    3.闭包的应用</span><br><span class="line">    3.0.延迟变量的作用域。</span><br><span class="line">    3.1.自执行的匿名函数保存循环变量.(循环和定时器，循环和事件处理函数)</span><br><span class="line">    3.2.js代码的一种写法 - 避免全局变量的污染</span><br><span class="line">    注意：不是说一种业务逻辑一个闭包结构,一个文件或者不同的开发人员一个闭包结构。</span><br><span class="line">    3.3.函数的防抖和节流。</span><br><span class="line">    减少函数的执行次数</span><br><span class="line">    防抖:当事件被触发一段时间后再执行回调，如果在这段时间内事件又被触发，则重新计时.</span><br><span class="line">    节流:指定时间间隔内，若事件被多次触发，只会执行一次.</span><br><span class="line">     const search = document.querySelector(&#x27;#search&#x27;);</span><br><span class="line"></span><br><span class="line">     function fn(e) &#123; 这个函数一开始执行频率很高，减少一些，封装一个函数来执行fn函数达到减少执行次数的目的。</span><br><span class="line">          console.log(&#x27;事件触发了&#x27;);</span><br><span class="line">          console.log(this); 这里指向了当前操作的元素 input</span><br><span class="line">         console.log(e); 正常情况这里无法直接获取事件对象，通过事件处理函数(debounce返回值)传参。</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     function debounce(fn) &#123;</span><br><span class="line">         let timer = null;</span><br><span class="line">         return function() &#123; 事件处理函数,无法确认事件处理函数有多少参数的时候。</span><br><span class="line">             clearInterval(timer);</span><br><span class="line">             timer = setTimeout(() =&gt; &#123;</span><br><span class="line">                  this:父级的this，父级的this指向当前的操作的元素对象</span><br><span class="line">                 fn.apply(this, arguments);   call也能，但是call第二个参数开始是函数本身的参数，这里不知道函数本身的参数</span><br><span class="line">     apply第二个参数是数组，数组项就是函数本身的参数。</span><br><span class="line">             &#125;, 1000);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     search.oninput = debounce(fn); debounce结果是函数体  封装debounce函数</span><br><span class="line">     search.oninput = fn;</span><br><span class="line">     function abc() &#123;</span><br><span class="line">         console.log(arguments.length); 22</span><br><span class="line">         console.log(arguments[0]); 100</span><br><span class="line">     &#125;</span><br><span class="line">     abc(100, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 41, 2, 3, 41, 2, 3, 4);</span><br><span class="line">     function abc() &#123;</span><br><span class="line">         console.log(arguments.length);</span><br><span class="line">     &#125;</span><br><span class="line">     abc();普通调用 长度0</span><br><span class="line">     document.onclick = abc; 事件下调用，长度1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    4.面向对象的继承 实例对象通过构造函数进行创建，原型对象是有了构造函数就会产生的。</span><br><span class="line">    prototype:每一个函数都有的，公有的属性和方法，this指向实例对象。</span><br><span class="line">    __proto__:每一个对象都有的，函数也是对象。对象依靠此属性进行原型链上面的方法和属性的调用。(隐式属性)</span><br><span class="line">    对象使用属性和方法，先找自身构造函数里面 - &gt; 构造函数的原型 - &gt; Object.prototype -&gt;  null</span><br><span class="line"></span><br><span class="line">    4.1.混合继承(构造函数继承+原型(prototype)继承)</span><br><span class="line">    构造函数继承 - call/apply - 继承属性和方法</span><br><span class="line">    原型继承 - (拷贝继承-Object.assign()、原型链继承:将父类的实例给子类的原型Student.prototype=new Person())</span><br><span class="line"></span><br><span class="line">    4.2.class继承 - extends super(继承的情况下，子类的this必须来自于父类)</span><br><span class="line"></span><br><span class="line">    5.原型链</span><br><span class="line">    概念：实例对象通过__proto__与原型(prototype)之间的连接，叫做原型链。__proto__( 隐式连接 )</span><br><span class="line">    原型链的查找过程：作为一个对象，当你访问其中的一个属性或方法的时候，如果这个对象中没有这个方法或属性，那么Javascript引擎将会访问这个对象的属性(__proto__)指向上一个对象prototype，并在那个对象中查找指定的方法或属性，如果不能找到，那就会继续通过那个对象的属性(__proto__)指向的对象进行向上查找Object.prototype，直到这个链表结束。(null)</span><br><span class="line"></span><br><span class="line">    6.面向对象其他验证方法</span><br><span class="line">     1.hasOwnProperty() : 看是不是对象自身下面的属性(构造函数里面的，而非继承的)， 只在属性存在于实例中时才返回 true。</span><br><span class="line">    const Fn = function() &#123;</span><br><span class="line">        this.a = 1;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Fn.prototype.b = 2;</span><br><span class="line">    Object.prototype.c = 3;</span><br><span class="line"></span><br><span class="line">    let f1 = new Fn();</span><br><span class="line">     console.log(f1.a);</span><br><span class="line">     console.log(f1.b);</span><br><span class="line">     console.log(f1.c);</span><br><span class="line"></span><br><span class="line">     console.log(f1.hasOwnProperty(&#x27;a&#x27;)); true</span><br><span class="line">     console.log(f1.hasOwnProperty(&#x27;b&#x27;)); false 继承的</span><br><span class="line">     console.log(f1.hasOwnProperty(&#x27;c&#x27;)); false 继承的</span><br><span class="line"></span><br><span class="line">     2.toString() :系统对象下面都是自带的 , 系统对象都有toString(),自己写的对象都是通过原型链找Object下面的，可以把对象转成字符串，可以做进制转换或者类型的判断。</span><br><span class="line">     let num = 5;</span><br><span class="line">     console.log(num.toString());</span><br><span class="line">     console.log(num.toString(2)); 101</span><br><span class="line">     console.log(Object.prototype.toString.call(undefined)); [object Undefined]  最好的数据类型检测</span><br><span class="line">    注意：系统对象下面都有一个toString方法。自定义的对象继承自于Object.prototype</span><br><span class="line"></span><br><span class="line">     3.constructor：实例对象的构造函数  (实例对象.constructor)</span><br><span class="line">    console.log(f1.constructor);</span><br><span class="line">    console.log(Fn.prototype.constructor); 构造函数的原型也拥有constructor</span><br><span class="line"></span><br><span class="line">     4.instanceof：判断一个对象是否是一个构造函数（类）的实例。</span><br><span class="line">    console.log(Function instanceof Object); true</span><br><span class="line">    console.log(Object instanceof Function); true</span><br></pre></td></tr></table></figure>

# todo 拷贝 state

1.  浅拷贝(解构，Object.assign() ,Object.create()) 和 深拷贝(递归拷贝，loadsh,JSON 序列化)
2.  const newState = JSON.parse(JSON.stringify(previousState))
3.  不能拷贝方法

## this 指向

1.this 指向。 谁调用，指向谁。
this 的概念：this 是 Javascript 语言的一个关键字。它代表函数运行时,自动生成的一个内部对象,只能在函数内部使用。随着函数使用场合的不同,this 的值会发生变化。但是有一个总的原则,那就是 this 指的是调用函数的那个对象。 - this 是自动生成的对象 - 回调函数内部的 this 指向 window。 - 对象中的 this 和事件处理函数中的 this 都是指向当前操作的对象(元素对象) - 应用的核心 例如 document.onclick=function&#123;alert(this)&#125;; - 普通函数，自执行函数，函数表达式，回调函数 - 指向 window - 对象方法中的函数，事件处理函数 - 指向当前的对象。 - 函数内部指向 window 构造元素使用 new 运算符，会产生实例对象，this 会绑定在实例对象上 - 箭头函数里面的 this 来自于父级。而且不会改变。 - 在严格模式下，this 是 undefined. - 将正确的 this 的存储下来 可以改变 this 的指向 - call() apply() bind()改变 this 的指向的区别 - 第一个参数都是 this 要指向的对象 call 第二个参数开始是函数的本身 apply 第二个参数是数组 bind 第二个参数是函数本身的参数 - 新增严格模式下：禁止 this 关键字指向全局对象(window),指向 undefined。



## 左侧固定，右侧自适应布局

1.flex，最便捷的方法，flex-grow 可自由伸张，缺点：低版本 IE 不支持

2.float+margin-left，左侧宽度需固定

/_左浮动固定宽度,右边 margin-left_/

## 接到一个项目工作的流程,规划开发

- 项目立项，需求分析，设计研发，测试，内测，上线

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先产品经理他会提出需求，然后大家一起来开个会就看这个项目能不能进行立项，然后包括产品经理，然后还有交互，然后还有ui，然后再加上测试，然后就前后端，然后一起开个会，如果确定了说这个项目能立项，然后就开始进行，然后产品经理就开始写需求。产品文档写好之后，交给他的下一个环节，下一个环节是交互，就是要开始做一些大体的流程，比如说页面的跳转，然后这个页面它的功能都给他差不多实现出来。</span><br><span class="line">然后，把整个逻辑跑通之后，大体比如说哪个区域需要设计成什么样子的都告诉交互，下一环节就是UI，然后UI去把页面的细节去补充好，就是相当于是我们看到的一个整体的一个网站，然后最后UI这边结束之后，就所有人一起来评选一个。进行一个需求评审，然后在一起看他的稿子，包括逻辑跳转有没有问题，就前后端那些都要参与的，确定说这个需求可以过，然后这个时候给到了前端，然后前后端是通过需求文档，然后看看这个功能哪一部分需要做什么，然后怎么做通过需求文档来沟通，包括一些数据的交换。</span><br><span class="line">在前后端工作的时候，一拿到产品经理写的需求文档，就可以开始找组件了，因为大概就已经知道需要做什么功能了，就不用等到所有的稿子给到才做，不然时间来不及。然后前后端这边做做完了，做完之后给到测试，然后测试的话他做好。就说跑完程序说没有问题啊，这个时候就进行灰度测试，找一小部分用户，我们来看看效果，看它的使用情况，然后如果要是效果好的话，我们就进行上线</span><br></pre></td></tr></table></figure>

## 懒加载-按需加载

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用react-virtualized</span><br><span class="line">只加载可见区域的组件</span><br><span class="line">react-virtualized将我们的滚动场景区分为了viewport内的局部滚动和基于viewport的滚动, viewport内的局部滚动相当于在页面中开辟了一个独立的滚动区域，属于内部滚动,基于viewport的滚动则把滚动作为了window滚动的一部分(对于移动端而言，这种更为常见). 基于此计算出当前所需要显示的组件.</span><br><span class="line">API的使用</span><br><span class="line">. List</span><br><span class="line">AutoSizer、CellMeasurer跟List(自适应宽高)</span><br><span class="line">InfiniteLoader跟List(滚动加载)</span><br></pre></td></tr></table></figure>

## ant G2

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">G2 是一套基于图形语法理论的可视化底层引擎，以数据驱动，提供图形语法与交互语法，具有高度的易用性和扩展性。</span><br><span class="line">使用Canvas 和 SVG 构建出各种各样的可交互的统计图表。</span><br><span class="line">条形图</span><br><span class="line">-销量分布 Top10</span><br><span class="line">曲线图</span><br><span class="line">-每月收益</span><br><span class="line">饼图</span><br><span class="line">-用户性别比</span><br></pre></td></tr></table></figure>

## EXCEL 表格导入导出

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.数据导入用的插件是：SheetJS js-xlsx；</span><br><span class="line">2.xlsx-oc --save</span><br></pre></td></tr></table></figure>

## module,chunk,bundle

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们直接写出来的是 module，webpack 处理时是 chunk，最后生成浏览器可以直接运行的 bundle。</span><br></pre></td></tr></table></figure>

## 前端新技术

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TypeScript接管前端</span><br><span class="line">最近的每次交谈都听起来好像TS正在接管前端开发。据报道，有80％的开发人员承认他们想在下一个项目中使用或学习TypeScript。尽管有缺点，但TS代码更易于理解，实现更快，产生的错误更少。</span><br><span class="line">JAMStack</span><br><span class="line">JAM是JavaScript、API和Markup的简称，前面第一个字母缩写，而JAMstack是JavaScript、API和Markup构建的技术堆栈，是一种基于客户端JavaScript，可重用API和预构建Markup的现代Web开发架构。</span><br><span class="line"></span><br><span class="line">最近的vite比较火，而且发布了2.0版本，vue的作者也是在极力推荐,vite的缺点在于目前的生态不够webpack成熟</span><br><span class="line">webpack打包原理</span><br><span class="line">1.先逐级递归识别依赖，构建依赖图谱</span><br><span class="line">2.将代码转化成AST抽象语法树</span><br><span class="line">3.在AST阶段中去处理代码</span><br><span class="line">4.把AST抽象语法树变成浏览器可以识别的代码， 然后输出</span><br><span class="line">重点:这里需要递归识别依赖，构建依赖图谱。图谱对象就是类似下面这种</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

## 前端优化

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">       - 在DOM元素过多的情况下，浏览器渲染会很慢，非常影响用户体验。</span><br><span class="line">       因此我们会经常采用虚拟滚动、分页、上拉加载更多等不同的方式来进行优化，这些方式的思想都是一样的，都是只渲染可见区域，等用户需要时再加载更多的内容。而以上的方式无论哪种，都需要写大量的js或者css逻辑去实现。</span><br><span class="line">       而现在，我们多了一种方式—— content-visibility。只需要一行CSS代码，就可以实现可见网页只加载可见区域内容，使网页的渲染性能得到数倍的提升！ content-visibility是一个css属性，它控制一个元素是否呈现其内容，能让用户潜在地控制元素的呈现。用户可以使用它跳过元素的呈现(包括布局和绘制)，直到用户需要为止，让页面的初始渲染得到极大的提升。</span><br><span class="line">       visible: 默认值。对布局和呈现不会产生什么影响。</span><br><span class="line">       hidden: 元素跳过其内容的呈现。用户代理功能（例如，在页面中查找，按Tab键顺序导航等）不可访问已跳过的内容，也不能选择或聚焦。类似于对其内容设置了display: none属性。</span><br><span class="line">       auto: 对于用户可见区域的元素，浏览器会正常渲染其内容；对于不可见区域的元素，浏览器会暂时跳过其内容的呈现，等到其处于用户可见区域时，浏览器在渲染其内</span><br><span class="line">s</span><br><span class="line">       1.雪碧图</span><br><span class="line"></span><br><span class="line">       2.使用字体图标来代替图片 - 自定义字体 @font-face&#123;&#125;</span><br><span class="line"></span><br><span class="line">       3.使用webp格式的图片,它具有更优的图像数据压缩算法，能带来更小的图片体积，同等画面质量下，体积比jpg、png少了25%以上.</span><br><span class="line">       jpg/png/gif 性能低于.webp格式(webp格式的图片一定要在网页中预览)。</span><br><span class="line"></span><br><span class="line">       4.压缩优化 - gulp/webpack - 讲授</span><br><span class="line">       HTML压缩</span><br><span class="line">       CSS压缩</span><br><span class="line">       JS压缩</span><br><span class="line">       图片压缩</span><br><span class="line"></span><br><span class="line">       5.优化网络连接</span><br><span class="line">       CDN全称是Content Delivery Network，即内容分发网络，它能够实时地根据网络流量和各节点的连接、负载状</span><br><span class="line">       况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就</span><br><span class="line">       近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度</span><br><span class="line"></span><br><span class="line">       6.优化资源加载</span><br><span class="line">       6.1.J文件放在body底部,采用外部链接。</span><br><span class="line">       6.2.如果想把js文件放入head区域，可以实现</span><br><span class="line">       &lt;script src=&quot;&quot; defer async=&quot;true&quot;&gt;&lt;/script&gt;</span><br><span class="line">       异步script标签</span><br><span class="line">       defer: 异步加载，在HTML解析完成后执行。defer的实际效果与将代码放在body底部类似 - 兼容ie。</span><br><span class="line">       async: 异步加载，加载完成后立即执行。</span><br><span class="line"></span><br><span class="line">       7.资源懒加载与资源预加载 - 图片懒加载技术 - jquery.lazyload.js - 讲授</span><br><span class="line">       将图片资源延迟加载，等到资源进入可视区进行加载，一次性的，指的是只有第一次加载时才执行，一旦加载完成没有此效果。</span><br><span class="line"></span><br><span class="line">       8.事件代理(事件委托)</span><br><span class="line">       事件代理是指将事件监听器注册在父级元素上，由于子元素的事件会通过事件冒泡的方式向上传播到父节点，因此，可以由父节点的监听函数统一处理多个子元素的事件</span><br><span class="line">       利用事件代理，可以减少内存使用，提高性能及降低代码复杂度。</span><br><span class="line"></span><br><span class="line">       9.防抖和节流</span><br><span class="line">       使用函数节流（throttle）或函数去抖（debounce），限制某一个方法的频繁触发。</span><br><span class="line"></span><br><span class="line">       10.及时清理环境</span><br><span class="line">       及时消除对象引用，清除定时器，清除事件监听器，创建最小作用域变量，可以及时回收内存。</span><br><span class="line">       11. 减少http请求</span><br></pre></td></tr></table></figure>

## 项目打包上线

1.在 React 项目的主文件夹下 npm run build

2.启动静态服务器 serve -s build

3.前后端联调 将`build`文件夹下的所有文件放在后端文件中即可

4. Vue 1、在项目文件夹下运行 npm run build
   2、我们会发现在原来的项目文件夹中多出了一个 dist 文件夹，这个文件夹就是我们要放到线上的内 容
   我们把这个 dist 文件夹给到后端的工作人员，后端的工作人员，后端的工作人员就会把这个文件挂载到后端服务器上
   现在我们把 dist 文件夹里的内容放在 htdocs 文件夹中

## 设计模式

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.js里面的设计来自于后端 - java</span><br><span class="line">2.通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</span><br><span class="line">3.发布 — 订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。 在 JavaScript开发中， 我们一般用事件模型来替代传统的发布—订阅模式。</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.message = []; <span class="comment">//记录事件记事本。</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">type, fn</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//事件绑定，添加事件  type:事件类型(买菜,买车,买房) fn:事件处理函数</span></span><br><span class="line">    <span class="comment">// this.message[&#x27;买菜&#x27;] = [function()&#123;买白菜&#125;,function()&#123;青菜&#125;...]</span></span><br><span class="line">    <span class="comment">// this.message[&#x27;买车&#x27;] = [function()&#123;买宝马&#125;,function()&#123;奔驰&#125;...]</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.message[type]) &#123;</span><br><span class="line">      <span class="comment">//如果当前的事件不存在,新建这个事件</span></span><br><span class="line">      <span class="built_in">this</span>.message[type] = [fn];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//存在，直接添加</span></span><br><span class="line">      <span class="built_in">this</span>.message[type].push(fn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">emit</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//触发事件</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.message[type]) <span class="keyword">return</span>; <span class="comment">//if语句如果里面只有一行代码，可以省略花括号。</span></span><br><span class="line">    <span class="built_in">this</span>.message[type].forEach(<span class="function">(<span class="params">value</span>) =&gt;</span> value());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">type, fn</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//删除事件 type:事件类型(买菜,买车,买房) fn:事件处理函数</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.message[type]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.message[type].length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> buyevent = <span class="built_in">this</span>.message[type][i]; <span class="comment">//要处理的每个事件</span></span><br><span class="line">      <span class="keyword">if</span> (fn === buyevent) &#123;</span><br><span class="line">        <span class="built_in">this</span>.message[type].splice(i, <span class="number">1</span>); <span class="comment">//改变原数组</span></span><br><span class="line">        i--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buy = <span class="keyword">new</span> Observer();</span><br><span class="line">buy.on(<span class="string">&quot;buycai&quot;</span>, fn1); <span class="comment">//添加</span></span><br><span class="line">buy.on(<span class="string">&quot;buycai&quot;</span>, fn2);</span><br><span class="line">buy.on(<span class="string">&quot;buycai&quot;</span>, fn3);</span><br><span class="line"></span><br><span class="line">buy.on(<span class="string">&quot;buycar&quot;</span>, fn4);</span><br><span class="line">buy.on(<span class="string">&quot;buycar&quot;</span>, fn5);</span><br><span class="line">buy.on(<span class="string">&quot;buycar&quot;</span>, fn6);</span><br><span class="line"></span><br><span class="line">buy.remove(<span class="string">&quot;buycai&quot;</span>, fn2); <span class="comment">//删除</span></span><br><span class="line">buy.remove(<span class="string">&quot;buycar&quot;</span>, fn5);</span><br><span class="line"></span><br><span class="line">buy.emit(<span class="string">&quot;buycai&quot;</span>); <span class="comment">//执行</span></span><br><span class="line">buy.emit(<span class="string">&quot;buycar&quot;</span>); <span class="comment">//执行</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;买白菜&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;买青菜&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;买花菜&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;买宝马&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn5</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;买奔驰&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn6</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;买奥迪&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## JS 类和构造函数

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">类：定义某一事物的抽象特点</span><br><span class="line">js的话，没有类这个概念，只是将构造函数理解成类。2015年es6出来后才真正的产生了类的概念，但是类实质上也是构造函数的语法糖。</span><br><span class="line">构造函数：其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例对象，并且this变量会绑定在实例对象上。</span><br><span class="line"></span><br><span class="line">构造函数的基本特点：首字母大写, new运算符实例化对象。 构造函数里面的核心是属性和方法</span><br><span class="line">属性和方法都会绑定在实例对象上面，实例对象可以使用。前提就是所有的属性和方法绑定在this上面，this代表的就是实例对象。</span><br><span class="line"> new 操作符调用函数的时候，函数内部发生以下变化：</span><br><span class="line"> 1创建一个空对象，并且 this 变量引用该对象。</span><br><span class="line"> 2属性和方法被加入到 this 引用的对象中。</span><br><span class="line"> 3并且最后隐式的返回 this （创建也是隐式）。</span><br></pre></td></tr></table></figure>

## JS 中的 Class

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">js利用Class实现面向对象思想</span><br><span class="line">1.混合开发：构造函数+原型。   根据构造函数改写.</span><br><span class="line">2.constructor属性：获取实例对象的构造函数(类),constructor本意就是构造函数。</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">//Person:类</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//构造函数：属性</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">show</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="built_in">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">show1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="built_in">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Person(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.show());</span><br><span class="line"><span class="built_in">console</span>.log(p1.constructor);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person); <span class="comment">//function</span></span><br></pre></td></tr></table></figure>

## Ajax,jsonp,axios 跨域原理和场景

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"> 使用场景： 请求的提交是为了页面数据的显示，这时候用户一般不希望看到页面的刷新，是使用AJAX的一个最佳时候。</span><br><span class="line"> 传统的表单提交，在文本框输入内容后，点击按钮，后台处理完毕后，页面刷新，再回头检查是否刷新结果正确。使用Ajax，在点击 sunmit按钮后，立刻进行异步处理，并在页面上快速显示了更新后的结果，这里没有整个页面刷新的问题</span><br><span class="line">原理 ：浏览器 1.发生某个事件时，会创建XMLHttpRequest对象 发送HttpRequest</span><br><span class="line">发送到Inernet</span><br><span class="line">服务器 2.服务器会处理HttpRequest 创建响应并将数据返回浏览器 发送Inernet</span><br><span class="line">浏览器 3.使用JS处理被返回的数据 更新页面内容</span><br><span class="line">ajax是异步的JAVASCRIPT和XML 四部曲</span><br><span class="line">let ajax = new XMLHttpRequest();</span><br><span class="line">第二步.open(请求方式,接口地址,是否异步)：打开通信的接口。</span><br><span class="line">   ajax.open(&#x27;get&#x27;, &#x27;http://localhost/JS2010/week05/Day%2022_ajax+jsonp/php/taobaoapi.php&#x27;, true);</span><br><span class="line">第三步.send():发送解析 - 这一步过程很繁琐。</span><br><span class="line"> 0：请求初始化（还没有调用 open()）。</span><br><span class="line">    // 1：请求已经建立，但是还没有发送（还没有调用 send()）。</span><br><span class="line">    // 2：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。</span><br><span class="line">    // 3：请求在处理中；通常响应中已有部分数据可用，但是服务器还没有完成响应的生成。</span><br><span class="line">    // 4：响应已完成；您可以获取并使用服务器的响应了。</span><br><span class="line">    // ajax.readyState:获取就绪状态码(上面的5个步骤前面的编号0-4)</span><br><span class="line">4.第四步.通过onreadystatechange事件监听就绪状态码的编号。</span><br><span class="line"> if (ajax.readyState === 4) &#123; //解析完成，可以获取数据。</span><br><span class="line"> Json.parse去格式化数据，数组对象</span><br><span class="line"> 模版字符串去拼接渲染</span><br><span class="line"></span><br><span class="line">##JSonp 请求的原理</span><br><span class="line">input 搜索框 oninput添加事件 追加script属性</span><br><span class="line">jsonp,即json+padding,动态创建script标签,利用script标签的src属性可以获取任何域下的js脚本,通过这个特性(也可以说漏洞),服</span><br><span class="line">务器端不在返货json格式,而是返回一段调用，某个函数的js代码，在src中进行了调用，这样实现了跨域.</span><br><span class="line"></span><br><span class="line">- ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。</span><br><span class="line">- 前端script添加一个跨域的url，后端也会对这个url做出一些设置，实际的请求是后端执行的，后端再把访问该url返回的数据拼接返回到callback函数中，前端通过callback获取数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## axios</span><br><span class="line">Axios 的本质是通过原生ajax,axios是基于HTTP客户端的promise,用于浏览器和nodeJS.</span><br><span class="line">axios的特性:</span><br><span class="line"></span><br><span class="line">1.从浏览器发送ajax请求</span><br><span class="line">2.从nodeJS发送HTTP请求</span><br><span class="line">3.支持promise Api</span><br><span class="line">4.请求和相应的拦截</span><br><span class="line">5.转换请求和响应数据</span><br><span class="line">6.取消请求</span><br><span class="line">7.json数据自动转换</span><br><span class="line">8.客户端支持防止XSRF</span><br><span class="line"></span><br><span class="line">ajax请求就是一个发送请求不需要跳转页面的js技术,请求模板如下:</span><br><span class="line"></span><br><span class="line">var xhr = new XMLHttpRequest()//new一个HTTP请求</span><br><span class="line">xhr.open(&#x27;get&#x27;,&#x27;url&#x27;)</span><br><span class="line">//设置请求头 get方法不用设置</span><br><span class="line">xhr.setRequestHeader(&#x27;content-Type&#x27;,&#x27;application/x-www-form-urlencoded&#x27;)</span><br><span class="line">xhr.send()//发送请求</span><br><span class="line">xhr.onreadystatechange = function()&#123;</span><br><span class="line">  if(xhr.readystate==4 &amp;&amp; xhr.status == 200)&#123;</span><br><span class="line">    console.log(xhr.responseText)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## 移动端适配

1.第一种方法：viewport 适配 原理：通过设置 `initial-scale` , 将所有设备布局视口的宽度调整为设计图的宽度.

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取meta节点</span></span><br><span class="line"><span class="keyword">var</span> metaNode = <span class="built_in">document</span>.querySelector(<span class="string">&quot;meta[name=viewport]&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义设计稿宽度为375</span></span><br><span class="line"><span class="keyword">var</span> designWidth = <span class="number">375</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算当前屏幕的宽度与设计稿比例</span></span><br><span class="line"><span class="keyword">var</span> scale = <span class="built_in">document</span>.documentElement.clientWidth / designWidth;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过设置meta元素中content的initial-scale值达到移动端适配</span></span><br><span class="line">meta.content =</span><br><span class="line">  <span class="string">&quot;initial-scale=&quot;</span> +</span><br><span class="line">  scale +</span><br><span class="line">  <span class="string">&quot;,minimum-scale=&quot;</span> +</span><br><span class="line">  scale +</span><br><span class="line">  <span class="string">&quot;,maximum-scale=&quot;</span> +</span><br><span class="line">  scale +</span><br><span class="line">  <span class="string">&quot;,user-scalable=no&quot;</span>;</span><br><span class="line">blog.csdn.net / weixin_37632943 / article / details / <span class="number">95471535</span>;</span><br></pre></td></tr></table></figure>

2.第二种方法：借助 media 实现 rem 适配 :**rem**：CSS 的长度单位， 根元素字体大小的倍数，只有根元素字体大小有关； html 中的根元素即 html 元素。

大部分浏览器的默认字体大小都是 16px，所以 1rem = 16px；

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">长度单位都是用 rem 设置</span><br><span class="line">当屏幕尺寸改变时，只需要修改 html 元素的 font-size 即可实现等比适配</span><br><span class="line">我们在制作页面的时候，只考虑跟设计稿相同的屏幕尺寸即可，其他尺寸屏幕自动适配</span><br><span class="line">//对屏幕大小划分了html不同的font-size</span><br><span class="line">@media screen and (min-width: 320px) &#123;html&#123;font-size:50px;&#125;&#125;</span><br><span class="line">@media screen and (min-width: 360px) &#123;html&#123;font-size:56.25px;&#125;&#125;</span><br><span class="line">@media screen and (min-width: 375px) &#123;html&#123;font-size:58.59375px;&#125;&#125;</span><br><span class="line">@media screen and (min-width: 400px) &#123;html&#123;font-size:62.5px;&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

3.第三种方法：JS 配合修改配合 rem 适配

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> designWidth = <span class="number">375</span>;  		<span class="comment">// 设计稿宽度</span></span><br><span class="line"><span class="keyword">var</span> remPx = <span class="number">100</span>;               <span class="comment">// 在屏幕宽度375px，的时候，设置根元素字体大小 100px</span></span><br><span class="line"><span class="keyword">var</span> scale = <span class="built_in">window</span>.innerWidth / designWidth； <span class="comment">//计算当前屏幕的宽度与设计稿比例</span></span><br><span class="line"><span class="comment">// 根据屏幕宽度 动态计算根元素的 字体大小</span></span><br><span class="line"><span class="built_in">document</span>.documentElement.style.fontSize = scale*remPx + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line"></span><br><span class="line">这里我们计算当前屏幕的宽度与设计稿比后用比例scale乘上<span class="number">100</span>，是因为rem都是基于font-size值设置的，<span class="number">100</span>便于计算，值可以为任意数，比如<span class="number">10</span>，但是Chrome中最小为<span class="number">12</span>，所以这里选择用<span class="number">100</span>；</span><br><span class="line"></span><br><span class="line">比如某个元素，设计稿设计宽度为 640px， 我们需要在css中设置 width: <span class="number">6.</span>4rem</span><br><span class="line">比如某个元素，设计稿设计字体大小是 16px， 我们需要在css中设置 font-size:<span class="number">0.</span>16rem</span><br><span class="line"></span><br></pre></td></tr></table></figure>

##　 websocket

websocket 是一种网络通信协议，是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通信的协议，这个对比着 http 协议来说，http 协议是一种无状态的、无连接的、单向的应用层协议，通信请求只能由客户端发起，服务端对请求做出应答处理。

http 协议无法实现服务器主动向客户端发起消息，Websocket 连接允许客户端和服务器之间进行全双工通信，以便任一方都可以通过建立的连接将数据推送到另一端。WebSocket 只需要建立一次连接，就可以一直保持连接状态。

## JS 为金额增加千分位逗号分割符

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">将数字转换为字符串</span><br><span class="line">如果存在小数点，使用substr等方法截取包含小数点后的字符</span><br><span class="line">使用substring等方法截取0到小数点位置的字符，并通过split使字符串变为数组</span><br><span class="line">遍历数组，当index为3的倍数时，使用splice向当前下标后增加‘，’逗号</span><br><span class="line">最后通过join将数组转为字符串并拼接上面截取小数点后的字符</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">output</span>(<span class="params">n</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 将数字转换位字符串</span></span><br><span class="line">      <span class="keyword">let</span> num = n.toString()</span><br><span class="line">      <span class="comment">// 如果存在小数点，截取小数点及其后面的字符</span></span><br><span class="line">      <span class="keyword">let</span> after = num.indexOf(<span class="string">&#x27;.&#x27;</span>) &gt; <span class="number">0</span> ? num.substr(num.indexOf(<span class="string">&#x27;.&#x27;</span>)) : <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="comment">// 如果存在小数点，使用substring截取小数点前的字符，再通过split给字符串转换为数组</span></span><br><span class="line">      <span class="keyword">let</span> numArr =</span><br><span class="line">        num.indexOf(<span class="string">&#x27;.&#x27;</span>) &gt; <span class="number">0</span></span><br><span class="line">          ? num.substring(<span class="number">0</span>, num.indexOf(<span class="string">&#x27;.&#x27;</span>)).split(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">          : num.split(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      numArr.forEach(<span class="function">(<span class="params">i, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 剔除第一位的整除或者长度为3的倍数的情况，每当取到3位则在当前下标后插入一个&#x27;，&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          index !== <span class="number">0</span> &amp;&amp;</span><br><span class="line">          index !== numArr.length - <span class="number">1</span> &amp;&amp;</span><br><span class="line">          (index + <span class="number">1</span>) % <span class="number">3</span> === <span class="number">0</span></span><br><span class="line">        ) &#123;</span><br><span class="line">          numArr.splice(index + <span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// 再将数组转换为字符串，拼接上上面的小数点后面的字符</span></span><br><span class="line">      <span class="keyword">return</span> numArr.join(<span class="string">&#x27;&#x27;</span>) + after</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

##　 BigDecimal

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal为不可变、任意精度的有符号十进制数。值unscaledValue * 10-scale，其中unscaledValue（非标度值）为任意精度整数，scale（标度）为32位整型（可负）。</span><br><span class="line">计算器要求20位精确度且支持超大数，double类型（最多支持16位有效数字且最大值仅支持10^308次方）不够用，可用BigDecimal承载数据进行运算。</span><br><span class="line">BigDecimal支持任意精度和长度浮点数运算，运算时最好设各操作数小数精确度。特别除法需设保留几位小数，没设小数精确度则结果精确度等同操作数中最低精确度致结果不正确。</span><br><span class="line">加</span><br><span class="line">add（BigDecima）</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">减</span><br><span class="line">subtract（BigDecimal）</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">乘</span><br><span class="line">multiply（BigDecimal）</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">除</span><br><span class="line">divide（BigDecimal）</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">乘方</span><br><span class="line">pow（BigDecimal）</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">绝对值</span><br><span class="line">abs（）</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">取反</span><br><span class="line">negate（）</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">对比</span><br><span class="line">compareTo（BigDecimal）</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">小数点精确度</span><br><span class="line">setScale（int）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

# 对 React 框架的看法、理解、优势劣势

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  组件复用,每一个小的功能都可以封装成一个组件,代码更加模块化，可复用，好维护</span><br><span class="line">  兼容性好，虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API</span><br><span class="line">  JSX语法(JavaScriptXML)，可以将数据直接镶嵌在html中，也可以处理一些逻辑</span><br><span class="line">  好，使用虚拟DOM和diff算法，可以避免一些没必要的渲染</span><br><span class="line">  单向数据流，数据流动方向可以跟踪，流动单一，追查问题的时候很快捷。</span><br><span class="line">1 采用Virtual DOM</span><br><span class="line">	它并不直接对DOM进行操作，引入了一个叫做虚拟DOM的概念，安插在javascript逻辑和实际的DOM之间，性能好   </span><br><span class="line">2 跨浏览器兼容：</span><br><span class="line">	虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没问题的。</span><br><span class="line">3、一切都是组件：</span><br><span class="line">	代码更加模块化，重用代码更容易，可维护性高</span><br><span class="line">4、单向数据流：</span><br><span class="line">	redux实现是一个用于在JavaScript应用中创建单向数据层的架构，它随着React视图库的开发而被Facebook概念化。 </span><br><span class="line">5、同构、纯粹的javascript ：</span><br><span class="line">	因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化。</span><br><span class="line">6、兼容性好：</span><br><span class="line">	比如使用RequireJS来加载和打包，而Browserify和Webpack适用于构建大型应用。它们使得那些艰难的任务不再让人望而生畏。   </span><br><span class="line">7、JSX语法：</span><br><span class="line">	为了更加便利的模拟DOM结构，我们使用了JSX语法，可以让我们在JS中编译DOM结构</span><br><span class="line">8、函数式编程：</span><br><span class="line">	JS的最大特点就是函数式编程，在React中，函数式编程可谓式无处不见</span><br><span class="line">缺点： </span><br><span class="line">1、不适合单独做一个完整的框架：react是视图层框架MVC，大型项目想要一套完整的框架的话，也许还需要引入Flux和route相关的东西</span><br></pre></td></tr></table></figure>

#

# react 特点和优势

\***\*(1)  虚拟 DOM\*\***

我们以前操作 dom 的方式是通过 document.getElementById()的方式，这样的过程实际上是先去读取 html 的 dom 结构，将结构转换成变量，再进行操作。而 reactjs 定义了一套变量形式的 dom 模型，一切操作和换算直接在变量中，这样减少了操作真实 dom，性能真实相当的高，和主流 MVC 框架有本质的区别，并不和 dom 打交道

\***\*(2)  组件系统\*\***

react 最核心的思想是将页面中任何一个区域或者元素都可以看做一个组件  component

那么什么是组件呢？

组件指的就是同时包含了 html、css、js、image 元素的聚合体

使用 react 开发的核心就是将页面拆分成若干个组件，并且 react 一个组件中同时耦合了 css、js、image，这种模式整个颠覆了过去的传统的方式

\***\*(3)  单向数据流\*\***

其实 reactjs 的核心内容就是数据绑定，所谓数据绑定指的是只要将一些服务端的数据和前端页面绑定好，开发者只关注实现业务就行了

\***\*(4) JSX   语法\*\***

在 vue 中，我们使用 render 函数来构建组件的 dom 结构性能较高，因为省去了查找和编译模板的过程，但是在 render 中利用 createElement 创建结构的时候代码可读性较低，较为复杂，此时可以利用 jsx 语法来在 render 中创建 dom，解决这个问题，但是前提是需要使用工具来编译 jsx

## render

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">支持返回这五类:</span><br><span class="line">React elements, 数组, Fragments, Portal, String/numbers, boolean/null, 基础数据类型</span><br></pre></td></tr></table></figure>

react 的 render 之后做了什么：调用 React.createElement 来创建元素，创建出来的元素被当作参数和指定的 DOM container 一起传进 ReactDOM.render. 接下来会调用一些内部方法, 接着调用了 instantiateReactComponent, 这个函数根据 element 的类型实例化对应的 component. 当 element 的类型为:

- string 时, 说明是文本, 创建 ReactDOMTextComponent;
- ReactElement 时, 说明是 react 元素, 进一步判断 element.type 的类型, 当为

string 时, 为 DOM 原生节点, 创建 ReactDOMComponent;

函数或类时, 为 react 组件, 创建 ReactCompositeComponent

### 开启批量更新以应对可能的 setState

## setState，渲染一次，Fiber

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">React16启用了全新的架构，叫做Fiber，其最大的使命是解决大型React项目的性能问题</span><br><span class="line">react在进行组件渲染时，从setState开始到渲染完成整个过程是同步的。如果需要渲染的组件比较庞大，js执行会占据主线程时间较长，会导致页面响应度变差，使得react在动画、手势等应用中效果比较差。	</span><br><span class="line">React Fiber调度器，把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会。</span><br><span class="line"></span><br><span class="line">Fiber 是如何工作的</span><br><span class="line">ReactDOM.render() 和 setState 的时候开始创建更新。</span><br><span class="line">将创建的更新加入任务队列，等待调度。</span><br><span class="line">在 requestIdleCallback 空闲时执行任务。</span><br><span class="line">从根节点开始遍历 Fiber Node，并且构建 WokeInProgress Tree。</span><br><span class="line">生成 effectList。</span><br><span class="line">根据 EffectList 更新 DOM。</span><br></pre></td></tr></table></figure>

## 新的生命周期函数-Fiber

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">由于异步渲染的改动，componentWillMount, componentWillReceiveProps,componentWillUpdate 三个函数将被废弃。</span><br><span class="line">废弃原因</span><br><span class="line">diff算法更新，使用Fiber</span><br><span class="line">由于这是一个很大的改变会影响很多现有的组件，所以需要慢慢的去改。</span><br><span class="line">目前react 16 只是会报warning，在react 17就只能在前面加UNSAFE_的前缀来使用</span><br></pre></td></tr></table></figure>

## 虚拟 DOM

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">虚拟DOM是为了解决浏览器性能问题而设计的</span><br><span class="line">虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法 避免了没有必要的 dom 操作，从而提高性能</span><br><span class="line">当数据发生变化，比如setState时，会引起组件重新渲染dom</span><br><span class="line">虚拟dom会根据diff算法比较新的dom和老的dom的差异</span><br><span class="line">把有差异的地方更新到真实的DOM上</span><br><span class="line">缺点：无法进行极致优化： </span><br><span class="line">虽然虚拟 DOM + 合理的优化，首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。</span><br><span class="line">1. 区分Real DOM和Virtual DOM</span><br><span class="line">Real DOM</span><br><span class="line">更新缓慢。</span><br><span class="line">可以直接更新 HTML。</span><br><span class="line">如果元素更新，则创建新DOM。</span><br><span class="line">DOM操作代价很高。</span><br><span class="line">消耗的内存较多。</span><br><span class="line">Virtual DOM</span><br><span class="line">更新更快。</span><br><span class="line">无法直接更新 HTML。</span><br><span class="line">如果元素更新，则更新 JSX 。</span><br><span class="line">DOM 操作非常简单。</span><br><span class="line">很少的内存消耗。</span><br></pre></td></tr></table></figure>

## diff 算法

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">数据改变，虚拟DOM也会改变</span><br><span class="line">重新渲染所有的dom影响性能，diff算法可以只渲染改变的部分</span><br><span class="line">两个虚拟dom树如果完全比较，时间复杂度是O(n^3),Diff算法把树形结构按照层级分解，只比较同级元素。时间复杂度是O(n)</span><br><span class="line">*比较它们的key，进行增加，删除，替换，换位等操作</span><br><span class="line">*React中可以使用shouldComponentUpdate生命周期函数提高 diff 的性能</span><br><span class="line">作用: 计算出Virtual DOM中真 正变化的部分，并只针对该部分进行原生DOM操作，而非重新渲染整个页面</span><br><span class="line">1.diff算法是什么</span><br><span class="line">	Diff算法是用于比较两个新旧虚拟dom树的差异的，比较完之后会得到一个差异对象，我们称之为patch补丁对象</span><br><span class="line">	比较后会出现四种情况：</span><br><span class="line">		1、此节点是否被移除 -&gt; 添加新的节点</span><br><span class="line">		2、属性是否被改变 -&gt; 旧属性改为新属性</span><br><span class="line">		3、文本内容被改变 -&gt; 旧内容改为新内容</span><br><span class="line">		4、节点要被整个替换 -&gt; 结构完全不相同 移除整个替换</span><br><span class="line">2.diff算法运行结束后，返回是什么</span><br><span class="line"> 返回一个key</span><br><span class="line"> </span><br><span class="line"> 优点：</span><br><span class="line">保证性能下限：</span><br><span class="line">	框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</span><br><span class="line">无需手动操作 DOM：</span><br><span class="line">	我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</span><br><span class="line">跨平台：</span><br><span class="line">	虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</span><br><span class="line"></span><br><span class="line">缺点:</span><br><span class="line">无法进行极致优化：</span><br><span class="line">虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。</span><br></pre></td></tr></table></figure>

## keys 的作用

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">key是react用于追踪哪些列表被修改、被添加或者被移出的辅助标识。</span><br><span class="line">在开发过程中，我们需要保证某些元素在同级的元素中key是具有唯一性的特性，在react Diff算法中React会借助元素的key值来判断该元素是新创建的还是移动而来的元素，从而减少元素的不必要的重复渲染。此外，我们还需要借助key值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。</span><br><span class="line">react根据key来决定是销毁重新创建组件还是更新组件，原则是：</span><br><span class="line">  key相同，组件有所变化，react会只更新组件对应变化的属性。</span><br><span class="line">  key不同，组件会销毁之前的组件，将整个组件重新渲染。</span><br><span class="line">key相同，组件有所变化，react会只更新组件对应变化的属性,没有变化则不更新。</span><br><span class="line">key不同，组件会销毁之前的组件（有状态组件的componentWillMount会执行），将整个组件重新渲染(有状态组件的constructor和componentWillUnMount都会执行)。</span><br></pre></td></tr></table></figure>

## Diff  的瓶颈以及  React  的应对

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">由于 diff 操作本身会带来性能上的损耗，在 React 文档中提到过，即使最先进的算法中，将前后两棵树完全比对的算法复杂度为`O(n3)`，其中 n 为树中元素的数量。</span><br><span class="line">如果 React 使用了该算法，那么仅仅一千个元素的页面所需要执行的计算量就是十亿的量级，这无疑是无法接受的。</span><br><span class="line">为了降低算法的复杂度，React 的 diff 会预设三个限制：</span><br><span class="line">只对同级元素进行 diff 比对。如果一个元素节点在前后两次更新中跨越了层级，那么 React 不会尝试复用它</span><br><span class="line">两个不同类型的元素会产生出不同的树。如果元素由 div 变成 p，React 会销毁 div 及其子孙节点，并新建 p 及其子孙节点</span><br><span class="line">开发者可以通过 key 来暗示哪些子元素在不同的渲染下能保持稳定</span><br></pre></td></tr></table></figure>

# react 原理

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1. setState  </span><br><span class="line">	setState在合成事件和钩子函数中是异步的 </span><br><span class="line">	在原生事件和setTimeout中是同步的</span><br><span class="line">	第一个参数可以是对象或者函数  是更新state   </span><br><span class="line">	第二个参数获取最新的state,副作用操作    dom操作事件触发声明  数据获取</span><br><span class="line">2. JSX语法的转化</span><br><span class="line">	JSX 仅仅是 createElement() 方法的语法糖（简化语法）</span><br><span class="line">	JSX 语法被 @babel/preset-react 插件编译为 createElement() 方法</span><br><span class="line">	react.createElement()</span><br><span class="line">	React 元素：是一个对象，用来描述你希望在屏幕上看到的内容</span><br><span class="line">3. 组件更新机制</span><br><span class="line">	setState() 的两个作用： 1. 修改 state 2. 更新组件（UI）</span><br><span class="line">	过程：父组件重新渲染时，也会重新渲染子组件。但只会渲染当前组件子树（当前组件及其所有子组件）   </span><br><span class="line">4. 组件性能优化</span><br><span class="line">	减轻 state：只存储跟组件渲染相关的数据</span><br><span class="line">	避免不必要的重新渲染 : shouldComponentUpdate(nextProps, nextState)    </span><br><span class="line">	通过返回值决定该组件是否重新渲染，返回 true 表示重新渲染，false 表示不重新渲染   起到优化作用</span><br><span class="line">5. 纯组件 PureComponent</span><br><span class="line">	PureComponent 内部自动实现了 shouldComponentUpdate 钩子，不需要手动比较 </span><br><span class="line">	纯组件内部通过分别 对比 前后两次 props 和 state 的值，来决定是否重新渲染组件 </span><br><span class="line">	纯组件内部的对比是 shallow compare（浅层对比）</span><br><span class="line">6. 虚拟 DOM 和 Diff 算法</span><br><span class="line">	数据改变视图更新</span><br><span class="line">	初次渲染时，React 会根据初始state（Model），创建一个虚拟 DOM 对象（树）。</span><br><span class="line">	根据虚拟 DOM 生成真正的 DOM，渲染到页面中。</span><br><span class="line">	当数据变化后（setState()，重新根据新的数据，创建新的虚拟DOM对象（树）。</span><br><span class="line">	与上一次得到的虚拟 DOM 对象，使用 Diff 算法 对比（找不同），生成patch补丁对象,得到需要更新的内容。</span><br><span class="line">	最终，</span><br><span class="line">React 只将变化的内容更新（patch）到 DOM 中，重新渲染到页面。</span><br></pre></td></tr></table></figure>

# 生命周期

![图片](https://uploader.shimo.im/f/7g8GbfHpPxY0kHR1.png!thumbnail?fileGuid=vCVWGWQvCcQQrHGh)

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">16版本：</span><br><span class="line">初始阶段:</span><br><span class="line">constructor</span><br><span class="line">    定义state</span><br><span class="line">componentWillMount(这个钩子函数在将来会被弃用)</span><br><span class="line">    为挂载做准备工作</span><br><span class="line">render</span><br><span class="line">    解析 this.state 和 this.props</span><br><span class="line">    将jsx型的虚拟dom渲染为对象类型的虚拟dom</span><br><span class="line">    render 中不允许使用 this.setState() 如何你使用了，就会栈溢出</span><br><span class="line">componentDidMount</span><br><span class="line">    表示组件挂载结束</span><br><span class="line">    虚拟dom -&gt; Real dom</span><br><span class="line">    可以获取真实dom</span><br><span class="line">    数据请求 -&gt; 赋值给state</span><br><span class="line">    第三方库实例化/DOM操作</span><br><span class="line">更新阶段:</span><br><span class="line">componentWillReceiveProps(在17版本中被弃用)</span><br><span class="line">    这个钩子实际作用是判断组件身上的props是否发生改变</span><br><span class="line"></span><br><span class="line">shouldComponentUpdate，我们需要做浅对比的话就直接用Purecomponent 深对比的话就是用这个生命周期、</span><br><span class="line">    可以决组件是否要更新渲染 return true/false</span><br><span class="line">    接收新旧状态，用于作对比（浅对比）</span><br><span class="line">    一般需要我们手动作深对比</span><br><span class="line">    这个钩子函数是React组件性能优化的一种方式</span><br><span class="line">    react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候。不过调用this.forceUpdate会跳过此步骤。</span><br><span class="line"></span><br><span class="line">componentWillUpdate</span><br><span class="line">    表示组件更新前的准备</span><br><span class="line">    这个钩子函数在未来版本被弃用</span><br><span class="line">render</span><br><span class="line">    和初始化阶段的作用一致</span><br><span class="line">componentDidUpdate</span><br><span class="line">    对Real dom 作操作</span><br><span class="line">    注意：父组件数据更新，子组件会重新运行render，反之不行</span><br><span class="line">    每次都要运行子组件render，会造成react性能浪费</span><br><span class="line">    粗略解决方案：</span><br><span class="line">        在shouldComponentUpdate中，可判断哪些数据改变从而来控制return true/false</span><br><span class="line">        继而决定是否需要更新render渲染</span><br><span class="line">    更好的解决方案：</span><br><span class="line">    1.引用PureComponent，让类组件继承（extends）PureComponent</span><br><span class="line">      如：class App extends  PureComponent&#123;&#125;</span><br><span class="line">    2.引用memo，让函数组件写在memo（）里 如：const memoApp =memo（function App() &#123;&#125;）</span><br><span class="line">    3.除了memo之外，更细致的是函数组件中还可以用useCallback（方法）和useMemo（对象和数组）两个钩子阻止组件render</span><br><span class="line">销毁阶段:</span><br><span class="line">componentWillUnmount</span><br><span class="line">    销毁组件</span><br><span class="line">    清除无用实例和事件，定时器</span><br><span class="line">错误捕获:</span><br><span class="line">    componentDidCatch</span><br><span class="line">    用户捕获子组件throw的错误，然后显示回退UI</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">17版本：</span><br><span class="line">相对于16版本 少3多2</span><br><span class="line">少了componentWillMount，componentWillReceiveProps，componentWillUpdate 3个钩子函数</span><br><span class="line">   (斯塔得可)  (迪外的)</span><br><span class="line">多了static getDerivedStateFromProps钩子函数                           (破外服)</span><br><span class="line">    一个静态方法，所以不能在这个函数里面使用this，这个函数有两个参数nextProps和prevState，这个函数会返回一个对象用来更新当前的state对象，如果不需要更新可以返回null。</span><br><span class="line">    简单说就是，可以增加一次state状态</span><br><span class="line">      (斯那坡秀的)</span><br><span class="line">多了getSnapshotBeforeUpdate钩子函数</span><br><span class="line">    快照</span><br><span class="line">    这个函数有一个返回值，会作为第三个参数传递给componentDidUpdate钩子</span><br><span class="line"></span><br><span class="line">getDerivedStateFromProps</span><br><span class="line">static getDerivedStateFromProps(props, state)在调用render方法之前调用，</span><br><span class="line">无论是在初始安装还是后续更新。它应返回一个对象来更新状态，或者返回null以不更新任何内容。</span><br><span class="line"></span><br><span class="line">根据props更新state</span><br><span class="line">这个生命周期可用于替代componentWillReceiveProps</span><br><span class="line"></span><br><span class="line">getSnapshotBeforeUpdate()</span><br><span class="line">getSnapshotBeforeUpdate(prevProps, prevState)在最近呈现的输出被提交到例如DOM之前调用。它使组件可以在可能更改之前从DOM捕获一些信息（例如滚动位置）。此生命周期返回的任何值都将作为参数传递给componentDidUpdate()。</span><br><span class="line"></span><br><span class="line">lazy、suspense</span><br><span class="line">lazy需要跟Suspence配合使用。</span><br><span class="line">lazy实际上是帮助我们实现代码分割的功能。</span><br><span class="line"></span><br><span class="line">由于有些内容，并不一定要在首屏展示，所以这些资源没有必要一开始就要去获取，那么这些资源就可以动态获取。</span><br><span class="line">这样的话，相当于把不需要首屏展示的代码分割出来，减少首屏代码的体积，提升性能。</span><br><span class="line"></span><br><span class="line">Suspence 很像Error Boundary，不同的是Error Boundary是用来捕获错误，显示相应的callback组件。而Suspence是用来捕获还没有加载好的组件，并暂停渲染，显示相应的ca</span><br></pre></td></tr></table></figure>

## 新版生命周期 17 版

挂载阶段：

1、constructor

定义 state

2、getDerivedStateFromProps 钩子函数

一个静态方法，所以不能在这个函数里面使用 this，这个函数有两个参数 nextProps 和 prevState，这个函数会返回一个对象用来更新当前的 state 对象，如果不需要更新可以返回 null。

简单说就是，可以增加一次 state 状态

（static getDerivedStateFromProps(props, state)在调用 render 方法之前调用，

无论是在初始安装还是后续更新。它应返回一个对象来更新状态，或者返回 null 以不更新任何内容。

根据 props 更新 state

这个生命周期可用于替代 componentWillReceiveProps）

3、render

解析 this.state 和 this.props

将 jsx 型的虚拟 dom 渲染为对象类型的虚拟 dom

render 中不允许使用 this.setState() 如果你使用了，就会栈溢出

4、componentDidMount

表示组件挂载结束

虚拟 dom -&gt; Real dom

可以获取真实 dom

数据请求 -&gt; 赋值给 state

第三方库实例化/DOM 操作

更新阶段：

1、getDerivedStateFromProps 和上面方法一样。

2、shouldComponentUpdate

可以决组件是否要更新渲染 return true/false

接收新旧状态，用于作对比（浅对比）

一般需要我们手动作深对比

这个钩子函数是 React 组件性能优化的一种方式

（（Purecomponent 深对比的话就是用这个生命周期、

可以决组件是否要更新渲染 return true/false

接收新旧状态，用于作对比（浅对比）

一般需要我们手动作深对比

这个钩子函数是 React 组件性能优化的一种方式）

（react 性能优化非常重要的一环。组件接受新的 state 或者 props 时调用，我们可以设置在此对比前后两个 props 和 state 是否相同，如果相同则返回 false 阻止更新，因为相同的属性状态一定会生成相同的 dom 树，这样就不需要创造新的 dom 树和旧的 dom 树进行 diff 算法对比，节省大量性能，尤其是在 dom 结构复杂的时候。不过调用 this.forceUpdate 会跳过此步骤。））

3、render 和上面方法一样

4、getSnapshotBeforeUpdate()

getSnapshotBeforeUpdate(prevProps, prevState)在最近呈现的输出被提交到例如 DOM 之前调用。它使组件可以在可能更改之前从 DOM 捕获一些信息（例如滚动位置）。此生命周期返回的任何值都将作为参数传递给 componentDidUpdate()。

5、componentDidUpdate 钩子

对 Real dom 作操作

注意：父组件数据更新，子组件会重新运行 render，反之不行

每次都要运行子组件 render，会造成 react 性能浪费

粗略解决方案：

在 shouldComponentUpdate 中，可判断哪些数据改变从而来控制 return true/false

继而决定是否需要更新 render 渲染

（（更好的解决方案：

1.引用 PureComponent，让类组件继承（extends）PureComponent

如：class App extends  PureComponent&#123;&#125;

2.引用 memo，让函数组件写在 memo（）里 如：const memoApp =memo（function App() &#123;&#125;）

3.除了 memo 之外，更细致的是函数组件中还可以用 useCallback（方法）和 useMemo（对象和数组）两个钩子阻止组件 render））

销毁阶段：：componentWillUnmount

销毁组件

清除无用实例和事件，定时

问题：

## render 里面能不能请求数据，或者说改变数据？

不能，因为他会重新渲染，然后形成一个死循环。

componentWillReceiveProps，componentWillUpdate，componentWillUnmount 之间也不能做这个数据请求，也会造成死循环。



## 组件销毁

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount</span><br><span class="line">定义state  flag:false 作为开关</span><br><span class="line">定义方法 if判断是否为1,改变state    flag:true</span><br><span class="line">将方法绑定组件上  可以用三目或者短路原则&amp;&amp;控制组件的显示隐藏</span><br></pre></td></tr></table></figure>

# props 和 state 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">属性vs状态</span><br><span class="line">相似点：都是纯js对象，都会触发render更新，都具有确定性（状态/属性相同，结果相同）</span><br><span class="line">不同点：</span><br><span class="line">属性能从父组件获取，状态不能</span><br><span class="line">属性可以由父组件修改，状态不能</span><br><span class="line">属性能在内部设置默认值，状态也可以</span><br><span class="line">属性不在组件内部修改，状态要改</span><br><span class="line">属性能设置子组件初始值，状态不可以</span><br><span class="line">属性可以修改子组件的值，状态不可以</span><br><span class="line">state 的主要作用是用于组件保存、控制、修改自己的可变状态。state 在组件内部初始化，可以被组件自身修改，而外部不能访问也不能修改。你可以认为 state 是一个局部的、只能被组件自身控制的数据源。state 中状态可以通过 this.setState方法进行更新，setState 会导致组件的重新渲染。</span><br><span class="line">props 的主要作用是让使用该组件的父组件可以传入参数来配置该组件。它是外部传进来的配置参数，组件内部无法控制也无法修改。除非外部组件主动传入新的 props，否则组件的 props 永远保持不变。</span><br></pre></td></tr></table></figure>

如果搞不清 state 和 props 的使用场景，记住一个简单的规则：尽量少地用 state，多用 props。

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">props是父组件传递给子组件的数据流，无法直接修改，它是只读的。</span><br><span class="line">start表示的是组件自身的状态，主要用于组件更新控制，如果想重新渲染，使用setState修改</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">props是一个从外部传进组件的参数，由于React具有单向数据流，所以它的主要作用是从父组件向子组件传递数据，它是不可改变的。如果想要改变它，只能通过外部组件传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。</span><br><span class="line">props除了可以传字符串、数字，还可以传数组，对象、甚至是回调函数。</span><br><span class="line">state是组件自己管理数据，控制自己的状态，值是可以改变的;props是外部传入的数据参数，不可变</span><br><span class="line">setState可以接受一个函数，函数的前两个参数，一个是以前的状态，一个是马上要改变的状态，新的</span><br></pre></td></tr></table></figure>

# 类组件和函数组件区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.类组件中可以使用局部状态state和生命周期</span><br><span class="line">2.函数组件中无法使用state,也无法使用的组件的生命周期</span><br><span class="line">3.函数组件都是展示型组件,接收props,渲染DOM</span><br><span class="line">4.函数组件中没有this</span><br></pre></td></tr></table></figure>

## 类组件优化

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate和PureComponent，这两个的解决思路是通过比较减少重新render的次数，主要是解决父组件更新而子组件也更新的情况。</span><br></pre></td></tr></table></figure>

## 函数组件优化

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.减少渲染次数()</span><br><span class="line">  默认情况下，只要父组件的状态变了，子组件也会重新渲染。</span><br><span class="line">  使用React.memo，将函数组件传递给memo之后，就会返回一个新的组件，如果memo接受到的属性不变，则不会重新渲染。类似于类组件里面的 PureComponent，这是可以减少重新 render 的次数的。 React.memo(组件)</span><br><span class="line">2.使用hook缓存</span><br><span class="line">useCallback</span><br><span class="line">  用来缓存函数，返回值为一个记忆函数，这个记忆函数仅在某个依赖改变时才会更新。去避免非必要的渲染。</span><br><span class="line">3.useMemo</span><br><span class="line">  缓存计算的值，减少计算的量。</span><br><span class="line">（（（useMemo 的第一个参数就是一个函数，这个函数返回的值会被缓存起来，同时这个值会作为 useMemo 的返回值，第二个参数是一个数组依赖，如果数组里面的值有变化，那么就会重新去执行第一个参数里面的函数，并将函数返回的值缓存起来并作为 useMemo 的返回值 ）））.</span><br></pre></td></tr></table></figure>

# 组件通信

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">1.父组件向子组件通信</span><br><span class="line">React数据流动是单向的</span><br><span class="line">父组件通过props自定义属性，向子组件传递需要的信息</span><br><span class="line">子组件直接使用props调用</span><br><span class="line">2.子组件向父组件通信</span><br><span class="line">父组件将一个函数作为 props 传递给子组件</span><br><span class="line">子组件内调用该回调函数，便可以向父组件通信。</span><br><span class="line">//  父组件定义状态、用来保存子组件数据的函数</span><br><span class="line">//  子组件触发函数传参</span><br><span class="line">3.非嵌套组件间通信</span><br><span class="line">非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</span><br><span class="line">    1.利用二者共同父组件的 context 对象进行通信</span><br><span class="line">    2.使用自定义事件的方式</span><br><span class="line">    3.采用组件间共同的父级来进行中转</span><br><span class="line">4.跨组件通信</span><br><span class="line">父组件向子组件的子组件通信，向更深层的子组件通信。</span><br><span class="line">中间组件层层传递 props</span><br><span class="line">使用 context 对象</span><br><span class="line">5.使用 context 对象:</span><br><span class="line">    context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。</span><br><span class="line">    父组件使用createContext().Provider包裹子组件，使用value传递状态</span><br><span class="line">    子组件在createContext().Consumer组件内，直接使用状态</span><br><span class="line">使用 context 也很简单，需要满足两个条件：</span><br><span class="line">    上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</span><br><span class="line">    子组件要声明自己需要使用 context</span><br><span class="line">5.redux</span><br><span class="line">首先由view dispatch拦截action，然后执行对应reducer并更新到store中，最终views会根据store数据的改变执行界面的刷新渲染操作。</span><br><span class="line">    通过创建一个store实例createStore,接收一个rootReducer和中间件执行函数</span><br><span class="line">    创建分块的数据rootReducer,通过combineReducers打造rootReducer,里面放分块的数据</span><br><span class="line">    在组件中通过高阶组件connect函数,接收store里的数据,把ActionCreators里的方法绑定到组件身上,</span><br><span class="line">      并且可以发送动作action给reducer</span><br><span class="line">    在reductor中根据action中的type动作类型,判断动作修改数据</span><br></pre></td></tr></table></figure>

## 组件按需加载

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">（实现方式，需要的依赖）懒加载</span><br><span class="line">1、vue异步组件技术</span><br><span class="line">    vue-router配置路由，使用vue的异步组件技术，可以实现按需加载。</span><br><span class="line">    但是，这种情况下一个组件生成一个js文件。</span><br><span class="line">2.import()</span><br><span class="line">3.webpack提供的require.ensure()</span><br><span class="line">4.第三方库比如react-loadable</span><br><span class="line">5.lazyload-loader</span><br></pre></td></tr></table></figure>

## 组件销毁

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount</span><br><span class="line">定义state  flag:false   作为开关   定义方法if判断是否为1,改变state    flag:true</span><br><span class="line">将方法绑定组件上  可以用三目或者短路原则&amp;&amp;控制组件的显示隐藏</span><br></pre></td></tr></table></figure>

## React PureComponent 和 Component 区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">React.Component需要自己实现shouldComponentUpdate()</span><br><span class="line">React.PureComponent通过props和state的比较来实现shouldComponentUpdate()</span><br><span class="line">React.PureComponent 通过prop和state的浅对比来实现 shouldComponentUpate()。</span><br><span class="line">  如果React组件的 render() 函数在给定相同的props和state下渲染为相同的结果，可以使用 React.PureComponent 来提升性能。</span><br><span class="line"></span><br><span class="line">PureComponent的作用：</span><br><span class="line">    PureComponent 其实是在内部帮我们简单实现了一下shouldComponentUpdate的功能，以便提供组件的性能；这里的简单指是：对prop和state做浅比较，若浅比较结果相同，则该组件以及其子组件不做render；否则，render。</span><br><span class="line">​</span><br><span class="line">使用PureComponent注意事项：</span><br><span class="line">    PureComponent主要针对prop和state为基本数据类型，如bool、string、number；</span><br><span class="line">    对于数组和对象等引用类型，则要引用不同，才会渲染；如果引用相同，则PureComponent浅比较返回结果相同，不做render；</span><br><span class="line">    PureComponent 中不建议再另外重写shouldComponentUpdate方法，否则会报warning信息：</span><br><span class="line">    PureComponent的最好作为展示组件，如果prop和state每次都会变，PureComponent做浅比较也会影响性能，可以考虑直接用Component；</span><br><span class="line"></span><br><span class="line">如果定义了shouldComponentUpdate()，无论组件是否是PureComponent，都会执行shouldComponentUpdate()结果来判断是否update。</span><br><span class="line">如果组件未实现shouldComponentUpdate(),则判断该组件是否是PureComponent，如果是的话，会对新旧props、state进行比较，一旦新旧不一致，就会触发update</span><br><span class="line">React.PureComponent优点:不需要开发者自己实现shouldComponentUpdate，就可以进行简单的判断来提升性能</span><br><span class="line">React.PureComponent缺点：可能会因深层的数据不一致而产生错误的否定判断，从而shouldComponentUpdate结果返回false，界面得不到</span><br></pre></td></tr></table></figure>

# 高阶组件 HOC（higher-order components）

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1.名词解释/作用</span><br><span class="line">    使函数复用，可以通过给组件传递方法来复用高阶组件中的函数方法。</span><br><span class="line">特点</span><br><span class="line">    高阶组件是一个函数</span><br><span class="line">    高阶组件接收一个组件作为参数进行使用，且需要在render函数中return返回这个组件</span><br><span class="line">目的：复用组件,将多个组件都要使用的类似逻辑放在同一个地方进行处理，可以提高代码的复用性和灵活性。</span><br><span class="line">2.常用高阶组件4个</span><br><span class="line">    React.memo()</span><br><span class="line">    connect()</span><br><span class="line">    provider()</span><br><span class="line">    withRouter()</span><br><span class="line"></span><br><span class="line">     -withRouter(组件)包裹组件</span><br><span class="line">目的：使用其可让组件内所有元素拥有this.props.history/location/match等属性；</span><br><span class="line"></span><br><span class="line">3.有自己封装过吗</span><br><span class="line">react高阶组件的两种方式：属性代理、反向继承</span><br><span class="line">1、基于属性代理：操作组件的props</span><br><span class="line">2、基于反向继承：用于拦截生命周期、state、渲染过程</span><br><span class="line">管理权限实现</span><br><span class="line">    利用高阶组件的 条件渲染 特性可以对页面进行权限控制，权限控制一般分为两个维度：页面级别 和 页面元素级别</span><br><span class="line">数据列表渲染</span><br><span class="line">    高阶组件内请求数据，将数据返回给组件</span><br></pre></td></tr></table></figure>

## 父组件更新，子组件会执行哪些生命周期

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render后的生命周期都会执行，快照getSnapshotBeforeUpdate，componentDidMount         DidUpdate      unMount</span><br></pre></td></tr></table></figure>

## React 组件中怎么做事件代理？它的原理是什么？

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">React基于Virtual DOM实现了一个SyntheticEvent(合成事件层)，定义的事件处理器会接收到一个合成事件对象的实例，它符合W3C标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上</span><br><span class="line">在React底层，主要对合成事件做了：事件委派和自动绑定</span><br><span class="line">事件委派：React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数</span><br><span class="line">自动绑定：React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件</span><br></pre></td></tr></table></figure>

# setState 概述,同步异步

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在react中调用setState后会将当前传入的值与已存在的状态合并</span><br><span class="line">可以写一个对象，或者写一个回调</span><br><span class="line">setState()函数接受两个参数，一个是一个对象，就是设置的状态，还有一个是一个回调函数，函数的参数即为 state 的前一个状态以及 props，是在设置状态成功之后执行的，所以我们可以通过回掉拿到最新的state值</span><br><span class="line">1. 同步/异步原理</span><br><span class="line">    setState在合成事件和钩子函数中是异步的</span><br><span class="line">    在原生事件和setTimeout中是同步</span><br><span class="line">2. 两个参数及用法</span><br><span class="line">    第一个参数可以是对象或者函数，用来更新state</span><br><span class="line">    第二个参数用来获取最新的state，可以做dom操作，数据请求，第三方库实例化</span><br><span class="line">* setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。</span><br><span class="line">* 如果对同一个值进行多次 setState，setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。</span><br></pre></td></tr></table></figure>

## 调用  setState  之后发生了什么

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在代码中调用 setState 函数之后，React 会将传入的参数与之前的状态进行合并，然后触发调和过程（Reconciliation），根据新的树和老的树之间的差异对界面进行最小化重新渲染。通过 diff 算法，React 能够精确制导哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</span><br></pre></td></tr></table></figure>



## 为什么使用 hook

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">不用写class组件就可以用state和其他的React特性；</span><br><span class="line">可以使  函数组件  拥有  类组件的  一些  功能和特性</span><br><span class="line">比如useState、useReducer    状态定义</span><br><span class="line">比如useEffect、useLayoutEffect   生命周期功能</span><br><span class="line">比如useRef useImperativeHandle 替代了类组件的 Ref（父组件获取子组件）</span><br><span class="line">为了优化函数组件，比如useMemo、useCallback</span><br><span class="line">函数组件添加新的方法</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如useDebugValue显示自定义hook，自己添加hook类名</span><br><span class="line">自定义hooks来复用状态</span><br></pre></td></tr></table></figure>

## 自定义 hook

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">实现组件的复用</span><br><span class="line">用useEffects代替生命周期方法(代码更加简洁)</span><br><span class="line">类似于高阶组件</span><br><span class="line">有没有封装过hooks    就是一个请求数据的一个</span><br><span class="line">请求数据相关全部封装进一个js文件，把所有请求数据的方法都放进这个hooks里面 方便阅读 防止这个代码太过于冗余，</span><br><span class="line">实现方法就是</span><br><span class="line">路由判断，类似路由守卫</span><br><span class="line">时间格式转换，</span><br><span class="line">封装axios</span><br><span class="line"></span><br><span class="line">高阶组件返回的一个类组件，而自定义Hook可以返回任何东西</span><br><span class="line">高阶组件必须传递一个组件作为参数，而自定义Hook不需要</span><br><span class="line">function useFriendStatus(friendID) &#123;</span><br><span class="line">  const [isOnline, setIsOnline] = useState(null);</span><br><span class="line">  // 在开发者工具中的这个 Hook 旁边显示标签</span><br><span class="line">  // e.g. &quot;FriendStatus: Online&quot;</span><br><span class="line">  useDebugValue(isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;);</span><br><span class="line">  return isOnline;</span><br><span class="line">&#125;</span><br><span class="line">可以理解为数据的操作都在hook里进行，而外部只关心自己想要的。我只要数据列表，获取产品钩子（可能并不需要，  可通过参数变更从而触发重新获取数据）、删除产品钩子</span><br><span class="line">为了封装方法：节流；</span><br><span class="line">1.将组件中共用的逻辑放在统一的自定义hook中写</span><br><span class="line">2.自定义hook,hook名以use开头</span><br><span class="line">3.其他组件通过import引入自定义hook,就可以使用了</span><br></pre></td></tr></table></figure>

## 使用规则

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不要在循环，条件或嵌套函数中调用 Hook</span><br><span class="line">只在函数组件中使用 Hooks</span><br></pre></td></tr></table></figure>

## 常用 Hooks

### useState:

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">定义状态 修改状态</span><br><span class="line">返回一个数组，其中第一项是状态值，第二项是一个更新状态的函数。</span><br><span class="line">状态一旦改变，React 就会重新渲染组件，变量获取新的状态值。</span><br><span class="line">1.使用 useState() 进行状态管理</span><br><span class="line">	调用useState() Hook 来启用函数组件中的状态。</span><br><span class="line">	useState(initialValue)的第一个参数initialValue是状态的初始值。</span><br><span class="line">	[state, setState] = useState(initialValue)返回一个包含2个元素的数组:状态值和状态更新函数。</span><br><span class="line">	使用新值调用状态更新器函数setState(newState)更新状态。或者，可以使用一个回调setState(prev =&gt; next)来调用状态更新器，该回调将返回基于先前状态的新状态。</span><br><span class="line">	调用状态更新器后，React 确保重新渲染组件，以使新状态变为当前状态。</span><br><span class="line">2.多种状态</span><br><span class="line">	通过多次调用useState()，一个函数组件可以拥有多个状态。</span><br><span class="line">	需要注意的，要确保对useState()的多次调用在渲染之间始终保持相同的顺序。</span><br><span class="line">3.状态的延迟初始化</span><br><span class="line">	每当 React 重新渲染组件时，都会执行useState(initialState)。如果初始状态是原始值（数字，布尔值等），则不会有性能问题。</span><br><span class="line">	当初始状态需要昂贵的性能方面的操作时，可以通过为useState(computeInitialState)提供一个函数来使用状态的延迟初始化，该函数仅在初始渲染时执行一次，以获得初始状态。在以后的组件渲染中，不会再调用该函数，从而跳过昂贵的操作。</span><br><span class="line">4.调用 useState()</span><br><span class="line">在使用useState() Hook 时，必须遵循 Hook 的规则：</span><br><span class="line">1.仅顶层调用Hook:不能在循环，条件，嵌套函数等中调用useState()。在多个useState()调用中，渲染之间的调用顺序必须相同。</span><br><span class="line">2.仅从React 函数调用 Hook:必须仅在函数组件或自定义钩子内部调用useState()。</span><br></pre></td></tr></table></figure>

### useState 原理

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">let _state;                            //闭包，深拷贝</span><br><span class="line">function myUseState(initialValue) &#123;    //定义函数，传入state</span><br><span class="line">    _state = _state || initialValue;   //使用_state变量接受传入参数</span><br><span class="line">    function setState(newState) &#123;      //顶部定义setState方法</span><br><span class="line">        _state = newState;             //在setstate方法中修改state</span><br><span class="line">        render();</span><br><span class="line">    &#125;</span><br><span class="line">    return [_state, setState]          //返回变量和state方法</span><br><span class="line">&#125;</span><br><span class="line">利用闭包，就是函数里面嵌套一个内层函数，</span><br><span class="line">多个state</span><br><span class="line">let _state = [];</span><br><span class="line">  let index = 0;</span><br><span class="line">  function myUseState(initialValue) &#123;</span><br><span class="line">    const currentIndex = index;</span><br><span class="line">    console.log(&#x27;currentINdex&#x27;, currentIndex)</span><br><span class="line">    _state[currentIndex] = _state[currentIndex] || initialValue;</span><br><span class="line">    function setState(newState) &#123;</span><br><span class="line">      _state[currentIndex] = newState;</span><br><span class="line">      render();</span><br><span class="line">    &#125;</span><br><span class="line">    index += 1;</span><br><span class="line">    return [_state[currentIndex], setState]</span><br><span class="line">  &#125;</span><br><span class="line">  const render = () =&gt;  &#123;</span><br><span class="line">    index = 0;</span><br><span class="line">    ReactDOM.render(&lt;App /&gt;,  document.getElementById(&#x27;root&#x27;))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

### useEffect:

可以代替 DidMount，DidUpdate，willUnmount

我们使用 useEffect 重写了上面的例子，useEffect 第一个参数接收一个函数，可以用来做一些副作用比如异步请求，修改外部参数等行为，而第二个参数称之为 dependencies，是一个数组，如果数组中的值变化才会触发 执行 useEffect 第一个参数中的函数。返回值(如果有)则在组件销毁或者调用函数前调用。

1.比如第一个 useEffect 中，理解起来就是一旦 count 值发生改变，则修改 documen.title 值；

2.而第二个 useEffect 中传递了一个空数组[]，这种情况下只有在组件初始化或销毁的时候才会触发，用来代替 componentDidMount 和 componentWillUnmount，慎用；

unmountComponentAtNode

1. 还有另外一个情况，就是不传递第二个参数，也就是 useEffect 只接收了第一个函数参数，代表不监听任何参数变化。每次渲染 DOM 之后，都会执行 useEffect 中的函数。

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">相当于</span><br><span class="line">componentDidMount,</span><br><span class="line">componentDidUpdate,</span><br><span class="line">componentWillUnmount三个钩子的组合</span><br><span class="line">1  useEffect(() =&gt; &#123;&#125;,[])  相当于componentDidMount钩子作用</span><br><span class="line">2  useEffect(() =&gt; &#123;&#125;,[count])   相当于componentDidMount + componentDidUpdate + watch（只监听数组中数据的变化）钩子作用</span><br><span class="line">3  useEffect(() =&gt; &#123;&#125;)   不跟第二个参数，只要数据改变就触发</span><br><span class="line">4  useEffect(() =&gt; &#123; 直接写 return () =&gt; &#123; console.log(&#x27;组件被销毁了&#x27;) &#125; &#125;)  相当于componentDidMount + componentWillUnmount</span><br><span class="line">用来弥补的</span><br><span class="line">参数一：执行的回调函数；</span><br><span class="line">参数二：该useEffect在哪些state发生变化时，才重新执行；</span><br><span class="line">第二个参数是空数组的时候执行一次,相当于componentDidMount,不加的时候执行多次</span><br><span class="line">第二个参数的作用就是 仅在更改时更新，实现性能的优化</span><br><span class="line">DOM操作 第三方实例化可以做 清除无用实例和事件</span><br><span class="line">useEffect传入的回调函数本身可以有一个返回值，</span><br><span class="line">这个返回值是另外一个回调函数，来模拟componentWillUnmount</span><br></pre></td></tr></table></figure>

### 什么是 useEffect 的副作用

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在完成某件事时附带执行的事，在useEffect的基本概念中，他表明了，在dom构建完成才执行，因为主要事是dom构建，所以其被称之为副作用</span><br></pre></td></tr></table></figure>

### cleanup 函数

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">他是副作用的清除，副作用可以在组件挂载，重绘之后任意执行，所以cleanup就永远只是清除上一个</span><br></pre></td></tr></table></figure>

### useMemo 和 useEffect 区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useMemo和useEffect的执行时机是不一致的：useEffect执行的是副作用，所以一定是在渲染之后执行的，useMemo是需要有返回值的，而返回值可以直接参与渲染的，所以useMemo是在渲染期间完成的，有这样一个一前一后的区别</span><br></pre></td></tr></table></figure>

### useLayoutEffect:

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">布局副作用</span><br><span class="line">    useEffect 在浏览器渲染完成后执行</span><br><span class="line">    useLayoutEffect 在浏览器渲染前执行</span><br><span class="line">useLayoutEffect 里的任务最好影响了 Layout</span><br><span class="line">为了用户体验，优先使用 useEffect (优先渲染)</span><br></pre></td></tr></table></figure>

### useLayoutEffect 和 useEffect 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useEffect：渲染内容更新到DOM -&gt;执行操作；</span><br><span class="line">useLayoutEffect：执行操作 -&gt; 渲染内容更新到DOM；惰性</span><br></pre></td></tr></table></figure>

### useContext:

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">跨组件通信 createContext创建一个组件</span><br><span class="line">&lt;numContext.Provider value=&#123;num&#125;&gt;</span><br></pre></td></tr></table></figure>

### useDebugValue:

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自定义 hook 的标签 方便调试台查看</span><br></pre></td></tr></table></figure>

### useMemo:

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">记忆组件，当新值和旧值一样,不重新渲染页面,优化作用,类似于shouldComponentUpdate useCallBack:</span><br><span class="line">作用和 useMemo 一样</span><br><span class="line">一般用来缓存计算的值，可以减少计算的量。</span><br><span class="line">useMemo 的第一个参数就是一个函数，这个函数返回的值会被缓存起来，同时这个值会作为 useMemo 的返回值，第二个参数是一个数组依赖，如果数组里面的值有变化，那么就会重新去执行第一个参数里面的函数，并将函数返回的值缓存起来并作为 useMemo 的返回值</span><br></pre></td></tr></table></figure>

### React.memo 和 useMemo 区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memo针对的是一个组件的渲染是否重复执行</span><br><span class="line">而useMemo则定义了一段函数逻辑是否重复执行</span><br><span class="line">（memo和useMemo只是用来做性能优化）</span><br></pre></td></tr></table></figure>

### useCallback

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用来缓存函数，返回值为一个记忆函数，这个记忆函数仅在某个依赖改变时才会更新。从而避免非必要的渲染。</span><br></pre></td></tr></table></figure>

### useCallback 和 useMemo 区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 唯一的区别是：useCallback 不会执行第一个参数函数，而是将它返回给你，而 useMemo 会执行第一个函数并且将函数执行结果返回给你。所以在前面的例子中，可以返回 handleClick 来达到存储函数的目的。</span><br><span class="line">所以 useCallback 常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而 useMemo 更适合经过函数计算得到一个确定的值，比如记忆组件。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  useMemo返回的是计算的结果值，用于缓存计算后的状态</span><br><span class="line">  useCallback返回的是函数，主要用来缓存函数，因为函数式组件中的state的变化都会导致整个组件被重新刷新（即使一些函数没有必要被刷新），此时用useCallback就会将函数进行缓存，减少渲染时的性能损耗​；</span><br><span class="line">  useMemo和useCallback都会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行</span><br><span class="line">useCallback(x =&gt; console.log(x), [m]) 等价于</span><br><span class="line">useMemo( () =&gt; x =&gt; console.log(x), [m])</span><br><span class="line">共同点：只有在依赖数据发生变化后，才会重新计算结果，起到缓存的作用</span><br></pre></td></tr></table></figure>

### useMemo 和 useCallback 的使用场景

useMemo：计算结果是  return 回来的值, 主要用于 缓存计算结果的值 ，应用场景如： 需要 计算的状态

useMemo 和 useCallback 的使用场景

useMemo：计算结果是 return 回来的值, 主要用于 缓存计算结果的值 ，应用场景如： 需要 计算的状态

useCallback 计算结果是 函数, 主要用于 缓存函数，应用场景如: 需要缓存的函数，因为函数式组件每次任何一个 state 的变化 整个组件 都会被重新刷新，一些函数是没有必要被重新刷新的，此时就应该缓存起来，提高性能，和减少资源浪费。



### useRef:

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useRef 返回的值传递给组件或者 DOM 的 ref 属性，可以通过 ref.current 值访问组件或真实的 DOM 节点，组件也是可以访问到的，从而可以对 DOM 进行一些操作，比如监听事件等等。</span><br></pre></td></tr></table></figure>

### createRef 与 useRef 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">它像一个变量, 类似于 this , 它就像一个盒子, 你可以存放任何东西.</span><br><span class="line">createRef 每次渲染都会返回一个新的引用</span><br><span class="line">而 useRef 每次都会返回相同的引用。</span><br></pre></td></tr></table></figure>

### React  中  ref  的作用

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ref 是 React 提供的一种可以安全访问 DOM 元素或者某个组件实例的方式。</span><br><span class="line">在类组件中使用 `createRef()`，在函数组件中使用 `useRef` 。</span><br></pre></td></tr></table></figure>

### react 中的 ref 的 3 种方式

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">方式1: string类型绑定</span><br><span class="line">类似于vue中的ref绑定方式，可以通过this.refs.绑定的ref的名字获取到节点dom</span><br><span class="line">注意的是 这种方式已经不被最新版的react推荐使用，有可能会在未来版本中遗弃</span><br><span class="line"></span><br><span class="line">方式2: react.CreateRef()</span><br><span class="line">通过在class中使用React.createRef()方法创建一些变量，可以将这些变量绑定到标签的ref中</span><br><span class="line">那么该变量的current则指向绑定的标签dom</span><br><span class="line"></span><br><span class="line">方式3: 函数形式</span><br><span class="line">在class中声明函数，在函数中绑定ref</span><br><span class="line">使用这种方法可以将子组件暴露给父组件以使得父组件能够调用子组件的方法</span><br><span class="line">通过函数的方法绑定ref可以将整个子组件暴露给父组件</span><br><span class="line">​</span><br><span class="line">当在子组件中调用onRef函数时，正在调用从父组件传递的函数。this.props.onRef（this）这里的参数指向子组件本身，父组件接收该引用作为第一个参数：onRef = &#123;ref =&gt;（this.child = ref）&#125;然后它使用this.child保存引用。之后，可以在父组件内访问整个子组件实例，并且可以调用子组件函数。</span><br></pre></td></tr></table></figure>

### react 父组件通过 ref 获取不到子组件的解决方案

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修正this指向</span><br><span class="line">在子组件中</span><br><span class="line">this.customfunction = this.customfunction.bind(this);</span><br></pre></td></tr></table></figure>

useImperativeHandle:

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将组件中的方法放到外面使用</span><br><span class="line">搭配React.forwardRef</span><br></pre></td></tr></table></figure>

## 如果用的 hook，在组件销毁的时候怎么实现监听

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们可以使用react的Effect hook，</span><br><span class="line">Effect hook的第一个参数可以return一个函数，这样就可以在组件销毁的时候触发它：</span><br><span class="line">根据此hook组件的参数来进行判断，我们在此组件的父组件上将this.props.history传到这个组件上</span><br></pre></td></tr></table></figure>

# 路由

## 路由模式

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在使用的路由方式是BrowserRouter，也就是浏览器的路由方式，其实React还有几种路由方式：</span><br><span class="line">1、BrowserRouter：浏览器的路由方式，也就是在开发中最常使用的路由方式</span><br><span class="line">2、HashRouter：在路径前加入#号成为一个哈希值，Hash模式的好处是，再也不会因为我们刷新而找不到我们的对应路径</span><br><span class="line">3、MemoryRouter：不存储history，所有路由过程保存在内存里，不能进行前进后退，因为地址栏没有发生任何变化</span><br><span class="line">4、NativeRouter：经常配合ReactNative使用，多用于移动端</span><br><span class="line">5、StaticRouter：设置静态路由，需要和后台服务器配合设置，比如设置服务端渲染时使用</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

## react-router(路由)原理

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">react-router依赖基础 - history</span><br><span class="line">history是一个独立的第三方js库，可以用来兼容在不同浏览器、不同环境下对历史记录的管理</span><br><span class="line">老浏览器的history:</span><br><span class="line">    主要通过hash来实现，对应createHashHistory</span><br><span class="line">高版本浏览器:</span><br><span class="line">    通过html5里面的history，对应createBrowserHistory</span><br><span class="line">node环境下:                         (不弱惹)</span><br><span class="line">    主要存储在历史记录memeory里面，对应createMemoryHistory</span><br><span class="line">抽象了一个公共的文件createHistory:</span><br><span class="line">    此时的location跟浏览器原生的location是不相同的，最大的区别就在于里面多了key字段，</span><br><span class="line">    history内部通过key来进行location的操作</span><br><span class="line">原理:</span><br><span class="line">1.执行URL前进</span><br><span class="line">    createBrowserHistory: pushState、replaceState</span><br><span class="line">    createHashHistory: location.hash=*** location.replace()</span><br><span class="line">    createMemoryHistory: 在内存中进行历史记录的存储</span><br><span class="line">1.检测URL回退</span><br><span class="line">    createBrowserHistory: popstate</span><br><span class="line">    createHashHistory: hashchange</span><br><span class="line">    createMemoryHistory: 因为是在内存中操作，跟浏览器没有关系，不涉及UI层面的事情，所以可以直接进行历史信息的回退</span><br><span class="line">1.state的存储</span><br><span class="line">    为了维护state的状态，将其存储在sessionStorage里面:</span><br><span class="line">    基本原理:实现URL与UI可视化界面的同步。其中在react-router中，URL对应Location对象，而UI是由react components来决定的，这样就转变成location与components之间的同步问题。</span><br><span class="line">在react-router中最主要的component是Router、RouterContext、Link，history库起到了中间桥梁的作用</span><br><span class="line">1.Switch:表示一次只渲染一个组件</span><br><span class="line">2.Route:路由组件,用于展示一个组件  同router-view</span><br><span class="line">3.Redirect:重定向</span><br><span class="line">4.lazy + Suspense :实现路由懒加载</span><br><span class="line">5.exact:路径完全匹配</span><br><span class="line">6.fallback:组件切换时候的转场组件</span><br></pre></td></tr></table></figure>

## react-router 里的 Link 标签和 a 标签有什么区别？

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">从最终渲染的DOM来看，这两者都是链接，都是a标签，区别是： Link标签是react-router里实现路由跳转的链接，一般配合Route使用，react-router接下了其默认的链接跳转行为，区别于传统的页面跳转，Link标签的&quot;跳转&quot;行为只会触发相匹配的Route对应的页面内容更新，而不会刷新整个页面</span><br><span class="line">Link标签做的三件事情：</span><br><span class="line">• 1.有onclick那就执行onclick</span><br><span class="line">• 2.click的时候阻止a标签默认事件</span><br><span class="line">• 3.根据跳转href(即使是to)，用history(web前端路由两种方式之一，history&amp;hash)跳转，此时只是链接变了，并没有刷新页面</span><br><span class="line">而标签就是普通的超链接了，用于从当前页面跳转到href指向的里一个页面(非锚点情况)</span><br></pre></td></tr></table></figure>

## Link 和 NavLink

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Link组件用于点击链接跳转其他页面，没有路由激活</span><br><span class="line">NavLink 用于有路由激活效果的</span><br></pre></td></tr></table></figure>

## react-router-dom 和 react-router 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">写法上的区别：</span><br><span class="line">import &#123;Swtich, Route, Router, HashHistory, Link&#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line">import &#123;Switch, Route, Router&#125; from &#x27;react-router&#x27;;</span><br><span class="line">import &#123;HashHistory, Link&#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line">react-router-dom:</span><br><span class="line">加入了在浏览器运行环境下的一些功能:</span><br><span class="line">    BrowserRouter和HashRouter组件，</span><br><span class="line">    前者使用pushState和popState事件构建路由，</span><br><span class="line">    后者使用window.location.hash和hashchange事件构建路由。</span><br><span class="line">react-router-dom是依赖于react-router的，其中Switch、Route、Router、Redirect等组件是直接引入react-router中的</span><br><span class="line">react-router-dom还另外新增了Link、BrowserRouter、HashRouter组件。</span><br><span class="line">在引入react-router-dom后不需要显性引入react-router，</span><br><span class="line">react-router-dom依赖react-router，npm都会将他们安装。</span><br><span class="line">react-router3.x与react-router-dom区别</span><br><span class="line">    react-router3.x版本下路由采用集中式配置，UI组件和路由是分开的。</span><br><span class="line">    react-router4.x版本下路由路由采用分散式配置，路由嵌套在UI组件当中，</span><br><span class="line">    更加契合组件化思想（组件中的路由也应该包含在组件之中）。</span><br><span class="line">react路由模式</span><br><span class="line">我们一直在使用的路由方式是BrowserRouter，也就是浏览器的路由方式，其实React还有几种路由方式：</span><br><span class="line">                     (不弱惹)</span><br><span class="line">1、BrowserRouter：浏览器的路由方式，也就是在开发中最常使用的路由方式</span><br><span class="line">2、HashRouter：在路径前加入#号成为一个哈希值，Hash模式的好处是，再也不会因为我们刷新而找不到我们的对应路径</span><br><span class="line">3、MemoryRouter：不存储history，所有路由过程保存在内存里，不能进行前进后退，因为地址栏没有发生任何变化</span><br><span class="line">4、NativeRouter：经常配合ReactNative使用，多用于移动端</span><br><span class="line">5、StaticRouter：设置静态路由，需要和后台服务器配合设置，比如设置服务端渲染时使用</span><br><span class="line">  (斯大推克)</span><br></pre></td></tr></table></figure>

## react 路由配置

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1、引入路由包</span><br><span class="line">    npm install --save react-router</span><br><span class="line">    npm install --save react-router-dom</span><br><span class="line">    react-router：是基本的router包，里边函的内容较多，</span><br><span class="line">                  但是在网页开发中有很多用不到，现在的市面上的课程讲的基本都是这个包的教程。</span><br><span class="line">    react-router-dom：随着react生态环境的壮大，后出现的包，</span><br><span class="line">                      这个包比react-router包轻巧了很多。</span><br><span class="line">2、设置路由配置文件</span><br><span class="line">    在src目录下新建一个Router/index.js文件用于管理路由，这里需要引入一些对应的组件和路由包文件。</span><br><span class="line">        Router的history是必需的props</span><br><span class="line">        Switch表示只渲染第一个与当前地址匹配的&lt;Route&gt;</span><br><span class="line">        Route的props path为路径，component为路径对应的页面</span><br><span class="line">        exact属性表示精确匹配,比如我们有多层路由进行嵌套时，exact可以帮助我们精确匹配到你想跳转的路由。        exact的值为bool型，为true是表示严格匹配，为false时为正常匹配</span><br><span class="line">3、在入口文件引入路由配置文件</span><br><span class="line">    import RouterConfig from &#x27;./router/index.js&#x27;;</span><br><span class="line">    ReactDOM.render(&lt;RouterConfig/&gt;, document.getElementById(&#x27;root&#x27;));</span><br><span class="line">4、在各组件中使用路由</span><br><span class="line">    &lt;ul className=&quot;menu&quot;&gt;</span><br><span class="line">        &lt;li&gt;&lt;NavLink to=&#x27;/Page1&#x27;&gt;第一个页面&lt;/NavLink&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;NavLink to=&#x27;/Page2&#x27;&gt;第二个页面&lt;/NavLink&gt;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">1.Switch:表示一次只渲染一个组件</span><br><span class="line">2.Route:路由组件,用于展示一个组件  同router-view</span><br><span class="line">3.Redirect:重定向(锐得埃克特)</span><br><span class="line">4.lazy + Suspense(色斯盘丝):实现路由懒加载</span><br><span class="line">5.exact:路径完全匹配</span><br><span class="line">6.fallback:组件切换时候的转场组件</span><br></pre></td></tr></table></figure>

## 路由传参和读参

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1.params</span><br><span class="line">&lt;Route path=&#x27;/path/:name&#x27; component=&#123;Path&#125;/&gt;</span><br><span class="line">&lt;link to=&quot;/path/2&quot;&gt;xxx&lt;/Link&gt;</span><br><span class="line">this.props.history.push(&#123;pathname:&quot;/path/&quot; + name&#125;);</span><br><span class="line">读取参数用:this.props.match.params.name</span><br><span class="line">优势:刷新地址栏，参数依然存在</span><br><span class="line">缺点:只能传字符串，并且，如果传的值太多的话，url会变得长而丑陋。</span><br><span class="line">2.query</span><br><span class="line">&lt;Route path=&#x27;/query&#x27; component=&#123;Query&#125;/&gt;</span><br><span class="line">&lt;Link to=&#123;&#123; path : &#x27; /query&#x27; , query : &#123; name : &#x27;sunny&#x27; &#125;&#125;&#125;&gt;</span><br><span class="line">this.props.history.push(&#123;pathname:&quot;/query&quot;,query: &#123; name : &#x27;sunny&#x27; &#125;&#125;);</span><br><span class="line">读取参数用: this.props.location.query.name</span><br><span class="line">优势: 传参优雅，传递参数可传对象；</span><br><span class="line">缺点: 刷新地址栏，参数丢失</span><br><span class="line">3.state</span><br><span class="line">&lt;Route path=&#x27;/sort &#x27; component=&#123;Sort&#125;/&gt;</span><br><span class="line">&lt;Link to=&#123;&#123; path : &#x27; /sort &#x27; , state : &#123; name : &#x27;sunny&#x27; &#125;&#125;&#125;&gt;</span><br><span class="line">this.props.history.push(&#123;pathname:&quot;/sort &quot;,state : &#123; name : &#x27;sunny&#x27; &#125;&#125;);</span><br><span class="line">读取参数用: this.props.location.query.state</span><br><span class="line">优缺点同query</span><br><span class="line">4.search</span><br><span class="line">&lt;Route path=&#x27;/web/departManange &#x27; component=&#123;DepartManange&#125;/&gt;</span><br><span class="line">&lt;link to=&quot;web/departManange?tenantId=12121212&quot;&gt;xxx&lt;/Link&gt;</span><br><span class="line">this.props.history.push(&#123;pathname:&quot;/web/departManange?tenantId&quot; + row.tenantId&#125;);</span><br><span class="line">读取参数用: this.props.location.search</span><br><span class="line">优缺点同params</span><br></pre></td></tr></table></figure>

## react 二级路由地址改变，为何界面没更新？

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WithRouter</span><br></pre></td></tr></table></figure>

## 为何使用高阶组件 WithRouter 可以解决？

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">withRouter</span><br><span class="line">作用:把不是通过路由切换过来的组件中，将react-router 的 history、location、match 三个对象传入props对象上</span><br><span class="line"> </span><br><span class="line">默认情况下必须是经过路由匹配渲染的组件才存在this.props，才拥有路由参数，才能使用编程式导航的写法，执行this.props.history.push(&#x27;/detail&#x27;)跳转到对应路由的页面</span><br><span class="line">然而不是所有组件都直接与路由相连（通过路由跳转到此组件）的，当这些组件需要路由参数时，使用withRouter就可以给此组件传入路由参数，此时就可以使用this.props</span><br><span class="line"> </span><br><span class="line">一：如何使用withRouter：</span><br><span class="line">（1）引入</span><br><span class="line">（2）将组件 withRouter(组件) 一下</span><br><span class="line">不是通过路由跳转过来的，而是直接从浏览器中输入地址打开的，如果不使用withRouter此组件的this.props为空，没法执行props中的history、location、match等方法。</span><br></pre></td></tr></table></figure>

# redux

## 用途

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用户的使用方式复杂</span><br><span class="line">不同身份的用户有不同的使用方式（比如普通用户和管理员）</span><br><span class="line">多个用户之间可以协作</span><br><span class="line">与服务器大量交互，或者使用了WebSocket</span><br><span class="line">View要从多个来源获取数据</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">某个组件的状态需要共享</span><br><span class="line">某个状态需要在任何地方都能拿到</span><br><span class="line">一个组件需要改变全局状态</span><br><span class="line">一个组件需要改变另一个组件的状态</span><br></pre></td></tr></table></figure>

## Redux 的设计思想：

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Web 应用是一个状态机，视图与状态是一一对应的。</span><br><span class="line">所有的状态，保存在一个对象里面（唯一数据源）</span><br></pre></td></tr></table></figure>

## redux 组成

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Redux的核心由三部分组成：Store, Action, Reducer。(瑞丢瑟)</span><br><span class="line">Store: 是个对象,用来存储数据和数据管理的、更新视图</span><br><span class="line">Action: 是个对象，必须包含type这个属性，发送动作给reducer,reducer将根据这个属性值来对store进行相应的处理。一般来说，我们可以通过store.dispatch()将action传递给store</span><br><span class="line">reducer:是一个纯函数，接收旧 state 和 action，根据不同的 Action 做出不同的操作并返回新的 state</span><br></pre></td></tr></table></figure>

## Redux 流程

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">store通过reducer创建了初始状态</span><br><span class="line">view通过store.getState()获取到了store中保存的state挂载在了自己的状态上</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用户产生了操作，调用了actions的方法</span><br><span class="line">actions将action通过调用store.dispatch方法发送到了reducer中，并传入两个参数：当前的state和收到的action</span><br><span class="line">reducer接收到action并根据标识信息，比如type进行判断之后返回新的state</span><br><span class="line">store的state被reducer更改为新state的时候，store.subscribe方法里的回调函数会执行，此时就可以通知view去重新获取state，页面刷新</span><br></pre></td></tr></table></figure>

## Redux 三大原则

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">单一数据源:</span><br><span class="line">整个应用的 state 被存储在一个 Object tree 中，且只存在于唯一d Store中</span><br><span class="line">state 是只读的:</span><br><span class="line">唯一改变 state 的方法就是触发 action，action 是一个用于描述发生事件的普通对象，视图部分只需要表达想要修改的意图，所有修改都会被集中化处理。</span><br><span class="line">状态的改变通过纯函数来完成:</span><br><span class="line">Redux使用纯函数方式来执行状态的修改，Action表明了修改状态值的意图，而真正执行状态修改的则是Reducer。且Reducer必须是一个纯函数，当Reducer接收到Action时，Action并不能直接修改State的值，而是通过创建一个新的状态对象来返回修改的状态。</span><br></pre></td></tr></table></figure>

## connect

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">连接  React组件  与 Redux store。</span><br><span class="line">connect:connect函数的返回值是一个高阶组件,通过高阶组件来获取store中的数据     </span><br><span class="line">connect底层原理:是闭包</span><br><span class="line">mapStateFromProps:从countReducer中解构出num数据,用来获取数据</span><br><span class="line">mapDispatchFromProps:将ActionCreators中的方法绑定到组件上,并且发送action</span><br><span class="line">connect调用的结果是返回一个高阶组件</span><br><span class="line">connect方法利用了合并分发的原理来帮助我们完成store内容的获取</span><br><span class="line">合并： 将store中的所有数据拿到手</span><br><span class="line">分发： 将我们需要的数据派发出去</span><br><span class="line">原理 </span><br><span class="line">合并分发 ：合并的意思是：(我们项目中)redux的数据是集中在一处的</span><br><span class="line">分发的意思是：给的是所有数据中的分块的数据</span><br></pre></td></tr></table></figure>

# redux 中间件

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">在action 和 store 之间执行中间件</span><br><span class="line">applyMiddlewares():它是 Redux 的原生方法，作用是将所有中间件组成一个数组，依次执行。</span><br><span class="line">applyMiddleware顾名思义，用于调用各种中间件；</span><br><span class="line">applyMiddleware执行后，将所有入参中间件存入一个数组，并且返回一个闭包（闭包的概念不做累述）</span><br><span class="line">闭包接受一个createStore作为入参并且执行后返回下一个闭包。</span><br><span class="line">中间件</span><br><span class="line">定义：中间件类似于一个过滤器，在客户端和应用程序之间处理请求和相应，是一个对多步骤的封装</span><br><span class="line">特点：一个中间件处理完会调用给另一个中间件，APP的运行会用到一系列的中</span><br><span class="line">     (米的为尔)</span><br><span class="line">applyMiddlewares():它是 Redux 的原生方法，作用是将所有中间件组成一个数组，依次执行。</span><br><span class="line">applyMiddleware顾名思义，用于调用各种中间件；</span><br><span class="line">applyMiddleware执行后，将所有入参中间件存入一个数组，并且返回一个闭包（闭包的概念不做累述）</span><br><span class="line">闭包接受一个createStore作为入参并且执行后返回下一个闭包。</span><br><span class="line">1.use注册中间件：app.use(function(request,response,next)&#123;next()&#125;) use方法，返回一个函数，使用一次就会生成一个中间件，use内部可以对路径进行判断，完成简单的路由，next参数可以不加（next用来调用下一个中间件）</span><br><span class="line">2.set指定变量值 app.set(&#x27;gsd&#x27;,&#x27;html&#x27;) set用于指定模板文件的后缀名</span><br><span class="line">3.response对象方法 .redirect允许网址重定向 .sendFile发送文件 .render渲染</span><br><span class="line">4.request对象方法 .ip获得IP地址 .files获得文件</span><br></pre></td></tr></table></figure>

## 中间件

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">中间件就是一个函数，对store.dispatch方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。</span><br><span class="line">中间件在dispatch这一步起作用，仍然返回一个action对象，最后交给reducer处理。</span><br><span class="line">没加中间件，</span><br><span class="line">加中间件，做异步操作，触发action</span><br></pre></td></tr></table></figure>

## redux-thunk|异步 action

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">thunk的原理</span><br><span class="line">redux默认的设定是 dispatch 只能接受一个对象参数，函数和promise都是不允许的，中间件就是为了解决这个问题的</span><br><span class="line">redux-thunk流程</span><br><span class="line">  首先检查参数 action 的类型，如果是函数的话，就执行这个 action 函数，并把 dispatch, getState, extraArgument 作为参数传递进去，然后就可以在函数里编写某些异步操作了，待异步操作结束，最后通过传入dispatch，发出action通知给Store要进行状态更新，否则就调用 next 让下一个中间件继续处理 action 。</span><br><span class="line">好处</span><br><span class="line">    react-thunk 比较适合于简单的API请求的场景</span><br><span class="line">    可以进行前后端数据交互</span><br><span class="line">缺点</span><br><span class="line">    将带有数据请求的action和没有带有数据请求的action混在一起了</span><br><span class="line">    缺点解决： 弃用redux-thunk,使用redux-saga</span><br><span class="line">    redux-saga可以将异步action和普通action区别开来</span><br></pre></td></tr></table></figure>

## redux-saga|集中处理异步 action

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redux-saga可以将异步action和普通action区别开来，控制器与更优雅的异步处理</span><br><span class="line">redux-saga就是用Generator(杰呢瑞特)来处理异步。</span><br><span class="line">redux-saga是一个管理redux应用异步操作的中间件，用于代替 redux-thunk 的。它通过创建 Sagas 将所有异步操作逻辑存放在一个地方进行集中处理，以此将react中的同步操作与异步操作区分开来，以便于后期的管理与维护。</span><br><span class="line">相当于在Redux原有数据流中多了一层，通过对Action进行监听，从而捕获到监听的Action，然后可以派生一个新的任务对state进行维护（这个看项目本身的需求），通过更改的state驱动View的变更。</span><br></pre></td></tr></table></figure>

## sageAPI

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redux-saga是通过ES6中的generator实现的（babel的基础版本不包含generator语法，因此需要在使用saga的地方import ‘babel-polyfill’）。redux-saga本质是一个可以自执行的generator。</span><br><span class="line">（1）redux-saga中的Effect</span><br><span class="line">redux-saga中定义了Effect，Effect是什么呢，本质就是一个特定的函数，返回的是纯文本对象。简单理解，通过Effect函数，会返回一个字符串，saga-middleware根据这个字符串来执行真正的异步操作，可以具体表现成如下形式：</span><br><span class="line">异步操作——&gt;Effect函数——&gt;纯文本对象——&gt;saga-middleware——&gt;执行异步操作</span><br><span class="line">因为Effect的存在，方便saga测试异步操作。</span><br><span class="line">（2）Effect具体函数</span><br><span class="line">Effect函数有很多个，在redux-saga/effects提供，主要包括call，fork，put，take，takeEvery、takeLatest，select等，它们都与middleware中的操作一一对应。</span><br><span class="line">I）call 和 fork</span><br><span class="line">call和fork表示异步调用，其中call表示的是阻塞调用，fork表示的是非阻塞调用。</span><br><span class="line">II）put和select</span><br><span class="line">put对应的是middleware中的类似dispatch方法，参数是一个plain object，一般在异步调用返回结果后，接着执行put。select相当于getState，用于获取store中的相应部分的state。</span><br><span class="line">III）take、takeEvery、takeLatest</span><br><span class="line">redux-saga中如果在非阻塞调用下（fork）,那么遵循的是worker/watcher模式，通过take可以监听某个action是否被发起，此外通过take结合fork，可以实现takeEvery和takeLatest的效果。</span><br><span class="line">如果一个异步操作的action被发起多次，takeEvery会执行多次action，而takeLatest只会执行最近的一次。</span><br></pre></td></tr></table></figure>

## redux 与 react-redux 的关系

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redux是独立的应用状态管理工具。它是可以独立于react之外的。如果我们需要在react当中运用它，那么我们需要手动订阅store的状态变化，来对我们的react组件进行更新。react-reudx这个工具，就帮我们实现了这个功能，我们只需对store进行处理，react组件就会有相应的变化。</span><br><span class="line">总结</span><br><span class="line">Redux: store, action, reducer</span><br><span class="line">store: getState,dispatch,subscribe,combineReducers (克木拜恩),createStore</span><br><span class="line">react-redux:</span><br><span class="line">connect : 将store作为props注入</span><br><span class="line">provider(破外的): 使store在子孙组件的connect中能够获取到</span><br></pre></td></tr></table></figure>

## react-reudx

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. UI组件|显示页面</span><br><span class="line">   React-Redux 将所有组件分成UI组件和容器组件</span><br><span class="line">2. 容器组件|负责管理数据/复杂逻辑?</span><br><span class="line">   UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。</span><br><span class="line">3. Provider组件|容器组件获取state</span><br><span class="line">   所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。</span><br><span class="line">4. connect()|UI组件+容器组件</span><br><span class="line">   React-Redux 提供connect方法，用于从 UI 组件生成容器组件。connect的意思，就是将这两种组件连起来。</span><br></pre></td></tr></table></figure>

## redux 和 mobx(类似双向数据绑定)区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">状态管理</span><br><span class="line">  redux-sage(sei知)是redux的一个异步处理的中间件</span><br><span class="line">  mobx是数据管理库，类似于redux</span><br><span class="line">设计思想</span><br><span class="line">  redux-sage属于flux体系，函数编程式思想</span><br><span class="line">  mobx不属于flux体系，面向对象变成和响应式编程</span><br><span class="line">特点</span><br><span class="line">  redux-sage因为是中间件，更关注异步处理，通过Generator函数来将异步变为同步，使代码可读性高，结构清晰</span><br><span class="line">  mobx是更简单方便的处理数据，Store是包含了state和action。state包装成一个可悲观察的对象，action可以直接修改saate，之后通过Computed values讲依赖state的变更，输出相应的副作用，但不生成新的state</span><br><span class="line">数据可变性</span><br><span class="line">  redux-sage强调state不可变，不能直接操作state，通过action和reducer在原来的state基础上返回一个新的state达到改变state的目的</span><br><span class="line">  mobx直接在方法中更改state，痛殴格式所有使用的state都发生变化，不生成新的state</span><br><span class="line">使用场景</span><br><span class="line"></span><br><span class="line">    redux-sage解决了redux关于异步处理时的复杂度和代码冗余的问题，学习成本高</span><br><span class="line">    mobx学习成本低，但是数据流向不利于追踪</span><br></pre></td></tr></table></figure>

# flux

Flux 的流程：

1.组件获取到 store 中保存的数据挂载在自己的状态上

2.用户产生了操作，调用 actions 的方法

3.actions 接收到了用户的操作，进行一系列的逻辑代码、异步操作

4.然后 actions 会创建出对应的 action，action 带有标识性的属性

5.actions 调用 dispatcher 的 dispatch 方法将 action 传递给 dispatcher

6.dispatcher 接收到 action 并根据标识信息判断之后，调用 store 的更改数据的方法

7.store 的方法被调用后，更改状态，并触发自己的某一个事件

8.store 更改状态后事件被触发，该事件的处理程序会通知 view 去获取最新的数据

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">flux 是 react 中的类似于 vuex 的公共状态管理方案，，利用数据的单向流动的形式对公共状态进行管理。现已不推荐使用。</span><br><span class="line">flux的组成</span><br><span class="line">    View：视图层</span><br><span class="line">    Action：视图发出的消息</span><br><span class="line">    Dispatcher：派发者，用来接收Action，执行回调函数</span><br><span class="line">    Store：数据层，存放状态，一旦发生改动</span><br><span class="line">flux 在进行数据更新时，会经历以下几步：</span><br><span class="line">    用户与 View 层交互，触发 Action</span><br><span class="line">    Action 使用 dispatcher.dispatch 将Action自己的状态发送给dispatcher</span><br><span class="line">    dispatcher 通过register注册事件，再通过Action传入的类型来触发对应的 Store 回调进行更新</span><br><span class="line">    Store 里进行相应的数据更新，并触发 View 层事件使试图也同步更新</span><br><span class="line">    View层 收到信号进行更新</span><br><span class="line">redux和flux的区别</span><br><span class="line">　　1）redux是flux中的一个实现</span><br><span class="line">　　2）在redux中我们只能定义一个store，在flux中我们可以定义多个</span><br><span class="line">　　3）在redux中，store和dispatch都放到了store，结构更加清晰</span><br><span class="line">　　4）在redux中本身就内置State对象，对仓库的管理更加明确</span><br></pre></td></tr></table></figure>

## flux 和 Redux 区别

![图片](https://uploader.shimo.im/f/BMFR087s3X137a1E.PNG!thumbnail?fileGuid=vCVWGWQvCcQQrHGh)

# connect 实现原理

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">首先connect之所以会成功，是因为Provider组件：</span><br><span class="line">在原应用组件上包裹一层，使原来整个应用成为Provider的子组件</span><br><span class="line">接收Redux的store作为props，通过context对象传递给子孙组件上的connect</span><br><span class="line">那connect做了些什么呢？</span><br><span class="line">它真正连接 Redux 和 React，它包在我们的容器组件的外一层，</span><br><span class="line">它接收上面 Provider 提供的 store 里面的 state 和 dispatch，</span><br><span class="line">传给一个构造函数，返回一个对象，以属性形式传给我们的容器组件。</span><br><span class="line">关于它的源码</span><br><span class="line">connect是一个高阶函数，首先传入mapStateFromProps、mapDispatchFromProps，</span><br><span class="line">然后返回一个生产Component的函数(wrapWithConnect)，</span><br><span class="line">然后再将真正的Component作为参数传入wrapWithConnect，</span><br><span class="line">这样就生产出一个经过包裹的Connect组件，该组件具有如下特点:</span><br><span class="line">通过props.store获取祖先Component的store</span><br><span class="line">props包括stateProps、dispatchProps、parentProps,合并在一起得到nextState，作为props传给真正的Component</span><br><span class="line">componentDidMount时，添加事件this.store.subscribe(this.handleChange)，实现页面交互</span><br><span class="line">shouldComponentUpdate时判断是否有避免进行渲染，提升页面性能，并得到nextState</span><br><span class="line">componentWillUnmount时移除注册的事件this.handleChange</span><br></pre></td></tr></table></figure>

# react 合成事件

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 合成事件原理</span><br><span class="line">   如果DOM上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响。React将事件内容封装交给中间层SyntheticEvent（负责所有事件合成）</span><br><span class="line">所以当事件触发的时候，对使用统一的分发函数dispatchEvent将指定函数执行。</span><br><span class="line">2. 与原生事件的区别</span><br><span class="line">   React合成事件一套机制：React并不是将click事件直接绑定在dom上面，而是采用事件冒泡的形式冒泡到document上面，然后React将事件封装给正式的函数处理运行和处理。</span><br></pre></td></tr></table></figure>

# react 修正 this 指向

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一.行间定义事件后面使用bind绑定this</span><br><span class="line">二.在构造函数内部声明this指向</span><br></pre></td></tr></table></figure>

# react 的 class 组件,没有 class 的时候怎么写

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">React.createClass</span><br><span class="line">我们最早使用这个方法来构建一个组件“类”，它接受一个对象为参数，</span><br><span class="line">对象中必须声明一个render方法，render返回一个组件实例</span><br></pre></td></tr></table></figure>

# react 中的受控组件和非受控组件

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">受控组件</span><br><span class="line">    值受到react控制的表单元素</span><br><span class="line">    因为React中可变状态通常保存在state中，并且只能通过setState()方法来修改</span><br><span class="line">    React将state与表单元素值value绑定在一起，由state的值来控制表单元素的值</span><br><span class="line">    使用value和onChange，在onChange中使用setState方法</span><br><span class="line">    &lt;input value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">非受控组件</span><br><span class="line">    表单组件没有value prop就可以称为非受控组件</span><br><span class="line">    非受控组件是一种反模式，它的值不受组件自身的state或props控制</span><br><span class="line">    通常需要为其添加ref prop来访问渲染后的底层DOM元素</span><br><span class="line">    调用 React.createRef() 方法创建ref对象</span><br><span class="line">    将创建好的 ref 对象添加到文本框中</span><br><span class="line">    通过ref对象获取到文本框的值</span><br><span class="line">select 标签</span><br><span class="line">    通过value匹配option对应内容</span><br><span class="line">&lt;select value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125;&gt;</span><br><span class="line">  &lt;option value=&quot;grapefruit&quot;&gt;葡萄柚&lt;/option&gt;</span><br><span class="line">  &lt;option value=&quot;lime&quot;&gt;酸橙&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

# AntD 中 input 输入框三个属性怎么实现

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">onChange输入框内容改变时候回调</span><br><span class="line">value输入的内容</span><br><span class="line">defaultValue输入框默认值</span><br><span class="line">input默认值在input中绑定value</span><br><span class="line">定义一个state和input双向数据绑</span><br><span class="line">做成受控组件，定义一个事件</span><br><span class="line">改变的时候获取e.target.value</span><br></pre></td></tr></table></figure>

# SPA 单页应用和 MPA 多页应用的异同

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">单页应用（SinglePage Application，SPA）</span><br><span class="line">    指只有一个主页面的应用，一开始只需加载一次 js,css 等相关资源。所有的内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅刷新局部资源。</span><br><span class="line">​</span><br><span class="line">多页应用（MultiPage Application，MPA）</span><br><span class="line">    指有多个独立的页面的应用，每个页面必须重复加载 js,css 等相关资源。多页应用跳转，需要整页资源刷新。</span><br></pre></td></tr></table></figure>

|                  | SPA                                                                 | MPA                                                                |
| :--------------- | :------------------------------------------------------------------ | :----------------------------------------------------------------- |
| 结构             | 一个主页面 + 许多模块的组件                                         | 许多完整的页面                                                     |
| 体验             | 页面切换快，体验佳；当初次加载文件过多时，需要做相关的调优          | 页面切换慢，网速慢的时候，体验尤其不好&lt;br&gt;                         |
| 资源文件         | 组件公用的资源只需要加载一次                                        | 每个页面都要自己加载公用的资源&lt;br&gt;                                 |
| 适用场景         | 对体验度和流畅度有较高要求的应用，不利于 SEO（可借助 SSR 优化 SEO） | 适用于对 SEO 要求较高的应用                                        |
| 过渡动画         | VUE 提供了 transition 的封装组件，容易实现                          | 很难实现&lt;br&gt;                                                       |
| 路由模式         | 可以使用 hash ，也可以使用 history                                  | 普通链接跳转&lt;br&gt;                                                   |
| 内容更新         | 相关组件的切换，即局部更新                                          | 整体 HTML 的切换，费钱（重复 HTTP 请求）&lt;br&gt;                       |
| 数据传递         | 因为单页面，使用全局变量就好（Vuex）                                | cookie 、localStorage 等缓存方案，URL 参数，调用接口保存等&lt;br&gt;     |
| 相关成本         | 前期开发成本较高，后期维护较为容易                                  | 前期开发成本低，后期维护就比较麻烦，因为可能一个功能需要改很多地方 |
| 单页应用实现核心 | 前端路由：改变视图的同时不会向后端发出请求。&lt;br&gt;&lt;br&gt;                |                                                                    |

# SPA 应用首屏加载速度慢的优化方法??

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">webpack 优化 抽离css 模块化抽取 代码压缩</span><br><span class="line">1.将公用的JS库通过script标签外部引入，减小 app.bundel 的大小，让浏览器并行下载资源文件，提高下载速度；</span><br><span class="line">2.在配置 路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的js文件；</span><br><span class="line">3.加一个首屏loading图，提升用户体验；</span><br></pre></td></tr></table></figure>

# react Native

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">React Native(内特服)能在手机上创建原生应用，React在这方面处于领先位置。使用JavaScript, CSS和HTML创建原生移动应用，这是一个重要的革新。Vue社区与阿里合作开发Vue版的React Native——Weex也很不错，但仍处于开发状态且并没经过实际项目的验证。</span><br><span class="line">既拥有Native的用户体验、又保留React的开发效率</span><br><span class="line">React Native与React.js的主要区别还是JSX,它使用XML标记的方式去直接声明界面，将HTML直接嵌入到JavaScript代码中</span><br></pre></td></tr></table></figure>

# 时间复杂度和空间复杂度

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度：是指执行当前算法所消耗的时间；</span><br><span class="line">空间复杂度：是指执行当前算法需要占用多少内存空间</span><br><span class="line">常见的量级有：常数阶O(1)，对数阶O(logN)，线性阶O(n)，线性对数阶O(nlogN)，平方阶O(n²)，立方阶O(n³)，K次方阶O(n^k)，指数阶(2^n)</span><br></pre></td></tr></table></figure>

# hash 和 history

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">最直观的区别是hash模式在url显示中有#，使用的是onhashchange事件；history模式没有#，利用的是history API实现效果，hash传参依靠url，history还可以存放于特定的对象中</span><br><span class="line">提升</span><br><span class="line">hash原本是用作锚点的，但是用作这里的话，锚点的功能会失效，history的pushstate方法参数可以添加任意一个类型的参数，甚至可以是一个对象，但是hash只能将一个字符串作为参</span><br><span class="line">数，并且pushstate还可以设置额外的title属性后续使用，但是history很怕页面刷新，一刷新会像后端发送请求，如果没有响应页面就会404</span><br></pre></td></tr></table></figure>

# DVA 与 CRA 相比的优点

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dva:</span><br><span class="line">    dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架。</span><br><span class="line">    相比于cra多了内置的redux和redux-saga，帮我们处理了数据流这方面的需求而已。如果只是想要达到这个效果的话，直接在cra中增加dva-core的依赖也是可以做到的。</span><br><span class="line">umi:</span><br><span class="line">    是一个可插拔的企业级 react 应用框架。umi和cra都是应用框架，可能相比cra来说umi的功能点更多一些，只能说是功能性的话umi要相对来说更胜一筹</span><br></pre></td></tr></table></figure>

# Immutable

## 2、什么是不可变数据

不可变数据 (Immutable Data )就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。Immutable 实现的原理是持久化数据结构（ Persistent Data Structure），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的 s 性能损耗，Immutable 使用了 结构共享（Structural Sharing），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。

## 3、immutable.js 的优缺点

**优点：**

- 降低 mutable 带来的复杂度
- 节省内存
- 历史追溯性（时间旅行）：时间旅行指的是，每时每刻的值都被保留了，想回退到哪一步只要简单的将数据取出就行，想一下如果现在页面有个撤销的操作，撤销前的数据被保留了，只需要取出就行，这个特性在 redux 或者 flux 中特别有用
- 拥抱函数式编程：immutable 本来就是函数式编程的概念，纯函数式编程的特点就是，只要输入一致，输出必然一致，相比于面向对象，这样开发组件和调试更方便。推荐一本函数式编程的在线免费书《[JS 函数式编程指南](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/)》, 此书可以推荐给学生做为课外补充阅读。

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">缺点：</span><br><span class="line">需要重新学习api</span><br><span class="line">资源包大小增加（源码5000行左右）</span><br></pre></td></tr></table></figure>

容易与原生对象混淆：由于 api 与原生不同，混用的话容易出错。在 react 中，immutable 主要是防止 state 对象被错误赋值。

- 将 js 对象转成 immutable 对象

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; fromJS &#125; from &#x27;immutable&#x27;;</span><br><span class="line">const defaultState = fromJS(&#123;</span><br><span class="line">  todoList: []</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

- 获取属性

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">state.get(&#x27;todoList&#x27;); // 获取store中的todoList</span><br><span class="line">statae.get([&#x27;Main&#x27;, &#x27;todoList&#x27;]); // 获取Main组件中store的todoList</span><br></pre></td></tr></table></figure>

- 改变属性

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">state.set(&#x27;todoList&#x27;, action.value);  // 设置单个属性值</span><br><span class="line">// 设置多个属性</span><br><span class="line">state.merge(&#123;</span><br><span class="line">  todoList: fromJS(action.value), // 由于action.value是js对象所以要转成immutable对象</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

- 将 immutable 对象转成 js 对象

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state.get(&#x27;todoList&#x27;).toJS(); // 把todoList转成js数组</span><br></pre></td></tr></table></figure>

# 什么是 useEffect 的副作用

在完成某件事时附带执行的事，在 useEffect 的基本概念中，他表明了，在 dom 构建完成才执行，因为主要事是 dom 构建，所以其被称之为副作用

## cleanup 函数

他是**副作用的清除，**副作用可以在组件挂载，重绘之后任意执行，所以 cleanup 就永远只是清除上一个

## react 的同一个生命周期里连续执行了两个 setstate，实际上会更新状态几次

只更新一次并且是第二次 setstate 时才执行，因为 React 会将多个 this.setState 产生的修改放在一个队列里，react 为了提高整体的渲染性能，会将一次渲染周期中的 state 进行合并，在这个渲染周期中你对所有 setState 的所有调用都会被合并起来之后，再一次性的渲染，这样可以避免频繁的调用 setState 导致频繁的操作 dom，提高渲染性能

## react 的 render 之后做了什么

调用 React.createElement 来创建元素，创建出来的元素被当作参数和指定的 DOM container 一起传进 ReactDOM.render. 接下来会调用一些内部方法, 接着调用了 instantiateReactComponent, 这个函数根据 element 的类型实例化对应的 component. 当 element 的类型为:string 时, 说明是文本, 创建 ReactDOMTextComponent;

ReactElement 时, 说明是 react 元素, 进一步判断 element.type 的类型, 当为

string 时, 为 DOM 原生节点, 创建 ReactDOMComponent;

函数或类时, 为 react 组件, 创建 ReactCompositeComponent

开启批量更新以应对可能的 setState

## vue 和 react 的 diff 算法区别

vue 和 react 的 diff 算法，都是忽略跨级比较，只做同级比较。vue diff 时调动 patch 函数，参数是 vnode 和 oldVnode，分别代表新旧节点。

1. vue 比对节点，当节点元素类型相同，但是 className 不同，任务是不同类型元素，删除重建，而 react 会认为是同类型节点，只是修改节点属性

2. vue 的列表比对，采用从两端到中间的比对方式，而 react 则采用从左到右依次比对的方式。当一个集合，只是把最后一个节点移动到了第一个，react 会把前面的节点依次移动，而 vue 只会把最后一个节点移动到第一个。总体上，vue 的对比方式更高效。

## react 中怎么进行事件绑定

在需要绑定事件的位置进行 onclick=&#123;事件名&#125; 在 render 上面写事件函数 包括绑定后这个事件的指向问题 一种是箭头函数一种是 bind 还一种是在 constructor 里面写 bind 这样只 bind 一次

## react 合成事件

如果 DOM 上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响。React 为了避免这类 DOM 事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，实现了一个中间层——SyntheticEvent。

当用户在为 onClick 添加函数时，React 并没有将 Click 时间绑定在 DOM 上面。

而是在 document 处监听所有支持的事件，当事件发生并冒泡至 document 处时，React 将事件内容封装交给中间层 SyntheticEvent（负责所有事件合成）

所以当事件触发的时候，对使用统一的分发函数 dispatchEvent 将指定函数执行。

## 二.合成事件和原生事件的执行顺序是什么？可以混用吗？

1.React 的所有事件都通过 document 进行统一分发。当真实 Dom 触发事件后冒泡到 document 后才会对 React 事件进行处理。

2.所以原生的事件会先执行，然后执行 React 合成事件，最后执行真正在 document 上挂载的事件

3.React 事件和原生事件最好不要混用。原生事件中如果执行了 =stopPropagation 方法，则会导致其他 React 事件失效。因为所有元素的事件将无法冒泡到 document 上，导致所有的 React 事件都将无法被触发。。

## reducer 在 react 中有什么用

reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。之所以将这样的函数称之为 reducer，是因为这种函数与被传入 Array.prototype.reduce(reducer, ?initialValue)

里的回调函数属于相同的类型。保持 reducer 纯净非常重要。永远不要在 reducer 里做这些操作：

修改传入参数；

执行有副作用的操作，如 API 请求和路由跳转；

调用非纯函数，如 Date.now() 或 Math.random()

不要修改 state。 使用 Object.assign() 新建了一个副本。

不能这样使用 Object.assign(state, &#123; visibilityFilter: action.filter &#125;)，因为它会改变第一个参数的值。

你必须把第一个参数设置为空对象。你也可以开启对 ES7 提案对象展开运算符的支持, 从而使用 &#123; ...state, ...newState &#125; 达到相同的目的。

在 default 情况下返回旧的 state。遇到未知的 action 时，一定要返回旧的 state。

## 组件性能优化

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   减轻 state：只存储跟组件渲染相关的数据</span><br><span class="line">避免不必要的重新渲染 : shouldComponentUpdate(nextProps,nextState)    </span><br><span class="line">通过返回值决定该组件是否重新渲染，返回 true 表示重新渲染，false 表示不重新渲染   起到优化作用</span><br></pre></td></tr></table></figure>

组件懒加载

## 组件懒加载：用 Suspense 的方法

从 react 中解构一个 Suspense 的方法，

constChild=lazy(()=&gt;import(&#39;./Child.jsx&#39;));

定义一个状态比如说 show=false,给一个按钮添加事件去控制 show=true,Suspense 作为标签去包裹，this.state.show&amp;&amp;&lt;Child&gt;&lt;/Child&gt;

((&amp;&amp;，第一个条件为假，立即返回 0))

Suspense 标签内部可以写入属性 fallback=&#123;&lt;div&gt;loading...&lt;/div&gt;&#125;写入的这个 loding...就是加载的时候显示的文字

# 项目难点

# vue 和 react 的区别和相同点

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vue提供了指令，react没有</span><br><span class="line">vue的数据是响应式的，数据是可变的，可以对属性使用watch监听，当属性变化时，响应式的更新对应的虚拟dom；</span><br><span class="line">react的数据是单向数据流，数据不可变，需要用setState重新渲染</span><br><span class="line">react使用jsx，把html，css都写进js里面，</span><br><span class="line">vue是单文件组件vue-loader，将html，css，js都写在.vue里</span><br><span class="line">用框架可以快速学习开发，减少团队差异</span><br></pre></td></tr></table></figure>

# react 项目基础

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">比如基础语法,JSX,组件化,用styled-componments写js文件的css样式</span><br><span class="line">使用create-react-app脚手架构建项目,安装依赖,配置webpack</span><br><span class="line">随着项目的业务场景变化,开始进行redux全局状态管理和CSS3动画</span><br><span class="line">数据管理中涉及异步/不可变性,需要中间件进行处理,如thunk/Immntable.js</span><br><span class="line">使用第三方UI框架,如Antd,Iconfont矢量图标,公司也要求开发自己的Ui组件库</span><br><span class="line">前端路由React-Roouter调式面板使用chrome+react-devtools+redux-devtools应用细节涉及生命周期函数,Ref的操作DOM节点</span><br><span class="line">代码和性能优化上主要是ES6语法和AJAX请求,缓存,CDN等</span><br></pre></td></tr></table></figure>

# 性能优化

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">属性传递优化</span><br><span class="line">多组件优化</span><br><span class="line">利用shouldcomponentUpdate钩子函数来判断组件是否需要渲染。 return true/flase</span><br><span class="line">给dom遍历加上唯一的key值，尽量不要使用下标。</span><br><span class="line">能用const就用const。</span><br><span class="line">DOM里减少使用箭头函数，当然传参的话还是得用，函数的this绑定尽量写在constructor里，避免每次render重新绑定this。</span><br><span class="line">减少对真实DOM的操作。</span><br><span class="line">无状态组件</span><br><span class="line">高阶组件</span><br><span class="line">immutable</span><br><span class="line">react-immutable-render-mixin，实现装饰器简化很多写法</span><br></pre></td></tr></table></figure>

# **什么是前后端接口联调**

之前开发写代码的时候，所有的 ajax 数据都不是后端返回的真实数据，而是我们自己通过接口 mock 模拟的假数据，当前端的代码编写完毕，后端的接口也已经写好之后，我们就需要把 mock 数据干掉，尝试使用后端提供的数据，进行前后端的一个调试，这个过程我们就把它称之为前后端的接口联调。

## **为什么要联调**

本地的 mock 数据是自己写的，肯定符合前端需求，但是后端接口首先需要测试通不通，还需要测试数据格式对不对，还有后端有没有填写足够的数据，比如写列表页，前端想分页，如果后端就写了两条测试数据，你咋整？

所以，Jack 需要根据后端对接口的调整，不断地来回切换 url，这样岂不是还在受后端的影响，还谈什么毛线的前后端分离，名存实亡嘛！”

# webapp 和小程序有什么区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">首先，微信小程序已经提供了一套 view, data, model, router 层的开发工具，</span><br><span class="line">对于开发简单应用，小程序是可以比 webapp 更加快速的。</span><br><span class="line">但是实际上微信小程序提供的这一套开发框架，要开发一些复杂应用，是很困难的，</span><br><span class="line">因为：小程序不支持 npm 等 package manager(麦呢橘)无法复用社区中已经很成熟的 web 框架和工具组件只能封装 view 和 style，无法封装行为（handler），行为只能定义在 page 上小程序有 1mb 的限制，所以我们只能将图片之类的静态资源事先放在服务器上</span><br><span class="line">其次，微信小程序是由微信自己来 host，开发者只需要上传就好，</span><br><span class="line">而微信 webapp 需要开发者自己 host，还需要注册域名甚至备案才可以调用微信接口以及跟公众号集成。</span><br><span class="line">所以微信小程序降低了开发者的门槛。</span><br><span class="line">综上，对于简单的工具型应用，微信小程序可以让开发者加快开发速度，降低发布门槛，</span><br><span class="line">这种类型的应用比较适合微信小程序。对于复杂的应用，webapp 是更适合的形式。</span><br></pre></td></tr></table></figure>

# 新项目如何快速上手，修改

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查看文档，从入口文件查询组件</span><br><span class="line">浏览器f12查看项目结构</span><br><span class="line">ctrl+f搜索</span><br></pre></td></tr></table></figure>

# 项目难点

## 二级路由切换后刷新导致标签样式丢失

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">切换时存入sessionStore内</span><br></pre></td></tr></table></figure>

## 响应式布局

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用antd的栅格化布局</span><br></pre></td></tr></table></figure>

## 数据增删后页面不刷新

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进行增删后再次请求一次新数据</span><br></pre></td></tr></table></figure>

## 后端返回数据的处理

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果返回数据是数字状态，需要用三目或者枚举方法将数字转为对应的状态</span><br></pre></td></tr></table></figure>

## 颜色主题更换

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用less中的@定义变量，将需要用到主题颜色的界面引入变量</span><br></pre></td></tr></table></figure>

## 虚拟列表优化长列表的原理

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优化长列表的原理很简单，基本原理可以—句话概括:</span><br><span class="line">用数组保存所有列表元素的位置，只渲染可视区内的列表元素，当可视区滚动时，根据滚动的offset大小以及所有列表元素的位置，计算在可视区应该渲染哪些元素。</span><br></pre></td></tr></table></figure>

## 虚拟列表：

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">先确定父元素的高度，父元素的高度决定了可视区域的高度。然后获取子元素的高度，计算出在可视区域内子元素的数量，上下留出一段留白区域，子元素渲染的时候只渲染可视区域和下面留白区域的内容，这样保证了渲染的过程不会被用户看到，根据滚动条滚动的方向距离决定是否继续渲染或销毁留白区域外的dom元素</span><br><span class="line">这样保证了无论如何滚动，真实渲染出的dom节点只有可视区内的列表元素。</span><br><span class="line">假设可视区内能展示5个子列表元素，及时长列表总共有1000个元素，但是每时每刻，真实渲染出来的dom节点只有5个。</span><br><span class="line">这种情况下，父元素一般使用position：relative，子元素的定位一般使用：position：absolute或sticky</span><br></pre></td></tr></table></figure>

## 对权限管理是怎么实现的

为什么用：

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在项目中，我们是希望根据登录人来看下这个人是不是有权限进入当前页面。虽然服务端做了进行接口的权限，但是每一个路由加载的时候都要去请求这个接口太浪费了。所以有时候是通过SESSIONID来校验登陆权限的。</span><br></pre></td></tr></table></figure>

如何实现：

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我们会先把路由表配置抽离成一个文件，路由表一般为一个数组，数组中存放保存有路由信息的对象。这个对象的属性常有路径和这个路径对应加载的组件，以及一个鉴别权限的属性，用来判断用户是否登录。再封装一个高阶组件用map来遍历渲染Router组件，在map遍历时做判断，如果没有权限查看当前页面的情况，一般来讲有两种处理方式，一是直接重定向到另一个页面（如首页），二是渲染一个无权限页面，提示用户因为没有当前页面的权限所以无法查看。</span><br><span class="line">在最终的路由中，我们会优先匹配无需鉴权的页面路径，保证所有用户在访问无需鉴权的页面时，第一时间就可以看到页面。然后再去匹配需要鉴权的页面路径，最终如果所有的路径都匹配不到的话，再渲染 404 页面告知用户当前页面路径不存在。</span><br></pre></td></tr></table></figure>

## 瀑布流的核心

实现瀑布流的核心其实就两个：

- 找出图片高度最小的那一列，再那一列插入，然后继续找下一个高度最小的，一直循环直到插满图片为止；
- 计算出每一列距离浏览器整体的距离，也就是`position`里的`left`或`right`，当你知道某一列的`left`的时候，相当于就知道了在它下面插入图片时，图片如何定位到这一列了，只要图片的`left`值和列是一样的，那么图片自然就插入到列里面了

## 图表联动怎么实现

要把当前被选中图表的事件，直接发给其他图表即可，然后判断被选中的图表是哪个作为区分

onTouchEvent(event)普通事件传递

3.产品经理要求智能匹配产品

找网上类似功能的网站 查看源码 和主管讨论

需要一个设计一个投资习惯和风险承受能力测试,

从后端获取这个客户测试的结果 以及客户平常投资的习惯 生成不同的关键字

根据关键字从数据库中匹配产品 展示界面

虚拟列表的实现：用 antd 组件实现

## webapp 和小程序有什么区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">首先，微信小程序已经提供了一套 view, data, model, router 层的开发工具，</span><br><span class="line">对于开发简单应用，小程序是可以比 webapp 更加快速的。</span><br><span class="line">但是实际上微信小程序提供的这一套开发框架，要开发一些复杂应用，是很困难的，</span><br><span class="line">因为：小程序不支持 npm 等 package manager(麦呢橘)无法复用社区中已经很成熟的 web 框架和工具组件只能封装 view 和 style，无法封装行为（handler），行为只能定义在 page 上小程序有 1mb 的限制，所以我们只能将图片之类的静态资源事先放在服务器上</span><br><span class="line">其次，微信小程序是由微信自己来 host，开发者只需要上传就好，</span><br><span class="line">而微信 webapp 需要开发者自己 host，还需要注册域名甚至备案才可以调用微信接口以及跟公众号集成。</span><br><span class="line">所以微信小程序降低了开发者的门槛。</span><br><span class="line">综上，对于简单的工具型应用，微信小程序可以让开发者加快开发速度，降低发布门槛，</span><br></pre></td></tr></table></figure>

这种类型的应用比较适合微信小程序。对于复杂的应用，webapp 是更适合的形式。

多数据长列表

分页或上拉加载

懒加载

图片，先将路径放入自定义属性，然后监听滚动条事件，判断是否滚动到这之前加载

## 后台管理系统数据渲染状态

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据返回字符集处理，两种状态，三目运算，</span><br><span class="line">多种状态，使用类似ts的枚举，根据返回数据先定义key，再定义value值，然后obj[value]</span><br></pre></td></tr></table></figure>

## 如果前端已经开发完成了，后端接口还没有给到，你是怎么做的

使用 mock 模拟数据

## 为什么在框架中使用 bind 来改变 this 指向

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因为react使用jsx语法,渲染的时候会把&#123;&#125;里面包裹的代码先解析一遍，会导致this丢失指向windows，</span><br><span class="line">所以当把一个函数作为callback传递给另一个函数的时候，这个函数的this一定是会丢失的</span><br></pre></td></tr></table></figure>

## 注册登录是怎么实现的

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.登陆注册要做成受控组件，组件定义state，和表单绑定</span><br><span class="line">2.redux-saga调用数据请求，发送action修改数据，</span><br><span class="line">useEffect中dispatch发送数据请求，后端比对用户名是否重复，返回state</span><br><span class="line">3.前端根据返回的信息成功跳转登陆页</span><br><span class="line">4.登陆发送数据请求，数据库对比用户名密码是否正确, 根据后端返回的结果进入首页</span><br><span class="line">5.setCookie将用户登录名密码token存cookie中   通过JWT(Json web token)</span><br><span class="line">6.免密登陆  getCookie获取token    发给后端对比    根据返回结果是否自动登陆</span><br><span class="line">7.注册通过Ant  Design ，validator中进行表单正则的验证</span><br><span class="line">8.用户体验  注册的时候跳转其他页面的时候给用户提示是否需要跳转，避免因为跳转后导致注册信息没有了 用组件内后置守卫做</span><br><span class="line">如果输入框都没有填信息,不拦截跳转如果用户输入信息,弹窗提示,点确定,跳转,点取消,不跳转</span><br></pre></td></tr></table></figure>

## 单页面首页白屏时间过长的

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一是网络的问题，在网络不好的情况下，获取文件的时间也对应这变长。</span><br><span class="line">二是文件大小的问题，项目越大型，文件的体积就越大，下载时间就越长。</span><br><span class="line">三是电脑本身的问题，性能越高的电脑，解析执行js的速度就越快，反之则慢。</span><br><span class="line">之前做的都是后台，</span><br><span class="line">前面2个问题（网络问题和文件大小问题）主要是涉及到了前端性能优化的问题，主要是合并请求，减少请求和文件的打包压缩等优化，</span><br><span class="line">所以要解决白屏时间过长的问题我们还是要从根源上解决，那就是服务器返回来的html只有html骨架，并没有什么实际内容可以显示在浏览器中，我们需要做的就是往html中填充内容，让浏览器在发送请求获取js等文件再到解析js生成页面所需要的html这段时间里有内容可以显示在浏览器中。</span><br><span class="line">骨架屏</span><br><span class="line">骨架屏技术主要是解决首页白屏时间过长的问题，对于SEO并不是很友好。骨架屏有点类似于手机app那些启动图，当数据还没有准备好的时候，显示的是骨架屏的东西，当数据准备好了之后就干掉骨架屏的内容，显示对应的数据。常见的骨架屏主要有图片背景图，css loading动画，还有就是占位块。首先这里的图片背景图需要注意的是需要以base64的格式引入使用，如果使用链接的形式引入，html获取回来后又要发送请求去获取图片，这无疑是增加了首页白屏时间，而且图片的体积不能太大，不然会导致html文件体积变大，下载时间变长，这也是不可取的。所以这种图片背景图很少会使用在网页app中，大多数是使用在手机app中。然后就是css loading 动画，这种做法见得少，一般都是直接来个全屏半透明遮罩层，在上面加个css loading动画，这种做法就是提示用户正在获取数据。最后就是占位块，占位块就是根据不同页面的内容使用div进行占位，让用户看到占位块就知道页面大概会有什么内容，比如顶部有个500200的轮播图，我们就在顶部放置一个背景颜色是灰色，500200的div。其他的页面组件也是如此，这样就组成我们的占位块了。饿了么外卖就是采用这种占位块的做法。骨架屏的原理主要是根据浏览器的地址来显示对应地址的页面的占位块，隐藏其他页面的占位块。骨架屏技术是解决单页面首页白屏时间过长最有效的办法，成本低，实现起来容易。~~~</span><br></pre></td></tr></table></figure>

# 项目亮点

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、使用插件对整体页面进行一个优化，比如nprogress插件是一个显示进度条的模块，可以在用户使用时，根据进度条来判断页面是否加载完毕。还有中英文转换、全屏等这些对用户比较友好。</span><br><span class="line">2、react-window 插件 用于长列表加载优化 或者做成分页 需要后端配合</span><br><span class="line">本项目中采用虚拟列表的模式进行数据渲染，避免用户使用过程中不会出现UI卡顿</span><br><span class="line">3、关键字高亮</span><br><span class="line">4、路由转场组件 用户在跳转页面过程中出现提示给用户良好的体验感</span><br><span class="line">React.lazy (()=&gt;&#123;&lt;&gt;&lt;&gt;&#125;) Suspense fallback=&#123;div&#125;</span><br><span class="line">5、nprogress进度条展示</span><br><span class="line">6、持久化数据 localstorage redux-persist 配置白名单 需要持久化的数据放在白名单里</span><br></pre></td></tr></table></figure>

# 项目中遇到什么困难,怎么解决的?

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一般都是自己上网查，如果实现不了就请教老大</span><br><span class="line">（实在不会反馈，防止拖慢整体进度）</span><br></pre></td></tr></table></figure>

具体

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1、关键字高亮操作</span><br><span class="line">后端返回搜索字段在本段文字中的索引值，用两个变量分别用来存储本段文字前后的两段字a以及b，</span><br><span class="line">一个变量存储变量 &lt;span&gt;</span><br><span class="line">另外一个变量存储 给span标签的加上style文件的样式</span><br><span class="line">再根据索引的位置将 变量和搜索的数据进行拼接，最后进行输出</span><br><span class="line"></span><br><span class="line">2.react中配置二级路由   地址变化  但是界面不更新</span><br><span class="line">在路径文件下，用withRoute()包一层</span><br><span class="line"></span><br><span class="line">3.路由跳转时，组件重复挂载</span><br><span class="line">在使用react的history.push()方法进行路由跳转时，组件重复加载两次</span><br><span class="line">应该是在进行带参数跳转时，浏览器会自动对中文进行转码，然后又会导致router的history方法监听浏览器地址栏变化。也就是说当我们执行上面的代码时，浏览器地址会变化两次，然后导致页面组件也会加载两次；</span><br><span class="line">将中文参数进行URI转码，然后在另一个页面转码回中文；</span><br><span class="line"></span><br><span class="line">4.图表联动怎么实现</span><br><span class="line">把当前被选中图表的事件，直接发给其他图表即可，然后判断被选中的图表是哪个作为区分，功能即可实现</span><br><span class="line">onTouchEvent(event)  普通事件传递</span><br><span class="line">使用 connect 方法将 myChart1 和 myChart2 进行关联，实现多图联动</span><br><span class="line"></span><br><span class="line">5.在没有使用redux的时候 ，有时候使用setState的时候 多次异步操作的时候，第一次获取不到最新的数据，在第二次点击请求才会访问到最新的数据？</span><br><span class="line">这是因为 react有Capture Value 的属性，</span><br><span class="line">利用 useRef 就可以绕过 Capture Value 的特性。可以认为 ref 在所有 Render 过程中只有一个唯一引用，因此所有对 ref 的赋值或取值，拿到的都只有一个最终状态</span><br></pre></td></tr></table></figure>

# 后台管理系统和普通 App 面向用户的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">toB和toC的项目</span><br><span class="line">​</span><br><span class="line">面向企业内部和面向用户的项目的区别</span><br><span class="line">​</span><br><span class="line">后台管理系统权限比较细   App高并发比较多  做性能优化</span><br></pre></td></tr></table></figure>

# 10000 条数据，渲染到页面上，需求是不让用分页，除了懒加载

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用react-virtualized</span><br><span class="line">只加载可见区域的组件</span><br><span class="line">react-virtualized将我们的滚动场景区分为了viewport内的局部滚动和基于viewport的滚动, viewport内的局部滚动相当于在页面中开辟了一个独立的滚动区域，属于内部滚动,基于viewport的滚动则把滚动作为了window滚动的一部分(对于移动端而言，这种更为常见). 基于此计算出当前所需要显示的组件.</span><br><span class="line">API的使用</span><br><span class="line">. List</span><br><span class="line">AutoSizer、CellMeasurer跟List(自适应宽高)</span><br><span class="line">InfiniteLoader跟List(滚动加载)</span><br></pre></td></tr></table></figure>

# ant G2

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">G2 是一套基于图形语法理论的可视化底层引擎，以数据驱动，提供图形语法与交互语法，具有高度的易用性和扩展性。</span><br><span class="line">使用Canvas 和 SVG 构建出各种各样的可交互的统计图表。</span><br><span class="line">条形图</span><br><span class="line">-销量分布 Top10</span><br><span class="line">曲线图</span><br><span class="line">-每月收益</span><br><span class="line">饼图</span><br><span class="line">-用户性别比</span><br></pre></td></tr></table></figure>

# 表格导入导出 SheetJS js-xlsx

## **表格数据导入**：

数据导入用的插件是：SheetJS js-xlsx；

### 使用

1.安装依赖：npm install xlsx；

2.在项目中引用：import \* as XLSX from ‘xlsx’;

3.定义上传 input：

![图片](https://uploader.shimo.im/f/UFmhinxXxHQcTVzS.png!thumbnail?fileGuid=G388gTCtcQRRXyGK)

accept 属性定义了上传文件支持的类型，onChange 操作中的 importExcel 方法定义了上传文件时执行的操作。

4.定义 handleExcel 方法:

![图片](https://uploader.shimo.im/f/LYtdaX4NJ4aVd2vQ.png!thumbnail?fileGuid=G388gTCtcQRRXyGK)

\*原生的上传文件样式特别的简陋，根据项目界面优化：

## **表格数据导出**

1.安装依赖：npm i xlsx-oc --save

2.在项目中导入：

![图片](https://uploader.shimo.im/f/2rWGbpoYfOrTL8ND.png!thumbnail?fileGuid=G388gTCtcQRRXyGK)

3.在项目使用：

定义导出 button

![图片](https://uploader.shimo.im/f/AlkLY699aXRxHCrv.png!thumbnail?fileGuid=G388gTCtcQRRXyGK)定义点击方法:

![图片](https://uploader.shimo.im/f/QFPoOGBNRMQNv7Ou.png!thumbnail?fileGuid=G388gTCtcQRRXyGK)

定义的表头和传入的数据

![图片](https://uploader.shimo.im/f/uf3IP24ZjVh9g4B5.png!thumbnail?fileGuid=G388gTCtcQRRXyGK)

![图片](https://uploader.shimo.im/f/BE3PicJ30fPEcFGv.png!thumbnail?fileGuid=G388gTCtcQRRXyGK)

#

# 项目流程

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">项目立项，需求分析，设计研发，测试，内测，上线</span><br><span class="line">做一个业务，首先产品经理他会提出需求，然后大家一起来开个会就看这个项目能不能进行立项，然后包括。产品文档写好之后，交给他的下一个环节，下一个环节是交互，就是要开始做一些大体的流程，比如说页面的跳转，然后这个页面它的功能都给他差不多实现出来。然后，把整个逻辑跑通之后，大体比如说我哪个区域需要，这是交互做的事情啊，哪个区域需要设计成什么样子的都告诉他的，下一环节就是UI，然后UI去把页面的细节去补充好，就是相当于是我们看到的一个整体的一个网站，然后最后UI这边结束之后，他不是交互，要写交互文档嘛，就所有人一起来评选一个。进行一个需求评审，然后在一起看他的稿子，包括逻辑跳转有没有问题，就前后端那些都要参与的，确定说这个需求可以过，然后这个时候给到了前端，然后前后端是通过需求文档，然后看看这个功能哪一部分需要做什么，然后怎么做通过需求文档来沟通，包括一些数据的交换。在前后端工作的时候，一拿到产品经理写的需求文档，就可以开始找组建啦，因为大概就已经知道需要做什么功能了，就不用等到所有的稿子才给到他才做，不然时间来不及，最后一旦确定之后就定排期嘛，就说谁，比如说交互，比如说是两星期是爵士一星期啊，那到了前后端开发这儿，比如说也是两星期，然后前后端这边做做完了对吧，做完之后给到测试，然后测试的话他做好。就说跑完程序说没有问题啊，这个时候就进行灰度测试，然后灰度测试的意思，就是说我们做一个东西的时候，怕改变太大会影响用户的习惯，就会导致用户流失，这个时候我们就不要去做大范围的上限。找一小部分的就是用户，我们来看看效果，看它的点击情况，然后如果要是效果好的话，我们就进行上线，到时候就所有的用户看到的页面可能都是我们上线后的新的版本，这个就是一个完整的流程。</span><br></pre></td></tr></table></figure>

## 项目流程第二版

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先产品经理他会提出需求，然后大家一起来开个会就看这个项目能不能进行立项，然后包括产品经理，然后还有交互，然后还有ui，然后再加上测试，然后就前后端，然后一起开个会，如果确定了说这个项目能立项，然后就开始进行，然后产品经理就开始写需求。产品文档写好之后，交给他的下一个环节，下一个环节是交互，就是要开始做一些大体的流程，比如说页面的跳转，然后这个页面它的功能都给他差不多实现出来。</span><br><span class="line">然后，把整个逻辑跑通之后，大体比如说哪个区域需要设计成什么样子的都告诉交互，下一环节就是UI，然后UI去把页面的细节去补充好，就是相当于是我们看到的一个整体的一个网站，然后最后UI这边结束之后，就所有人一起来评选一个。进行一个需求评审，然后在一起看他的稿子，包括逻辑跳转有没有问题，就前后端那些都要参与的，确定说这个需求可以过，然后这个时候给到了前端，然后前后端是通过需求文档，然后看看这个功能哪一部分需要做什么，然后怎么做通过需求文档来沟通，包括一些数据的交换。</span><br><span class="line">在前后端工作的时候，一拿到产品经理写的需求文档，就可以开始找组件了，因为大概就已经知道需要做什么功能了，就不用等到所有的稿子给到才做，不然时间来不及。然后前后端这边做做完了，做完之后给到测试，然后测试的话他做好。就说跑完程序说没有问题啊，这个时候就进行灰度测试，找一小部分用户，我们来看看效果，看它的使用情况，然后如果要是效果好的话，我们就进行上线</span><br></pre></td></tr></table></figure>

# 还有什么想问的？

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">公司主要是做哪方面的项目？ 人员配置</span><br><span class="line">您觉得我的技术深度或广度有哪些地方需要再加强?</span><br><span class="line">面试结果通知时间/后续还需要面试吗?</span><br><span class="line">办公地点具体在哪</span><br><span class="line">项目情况</span><br><span class="line">业务内容:</span><br><span class="line">服务对象:</span><br><span class="line">开发形式:</span><br><span class="line">人员配置:</span><br><span class="line">办公地址:</span><br><span class="line"></span><br><span class="line">刚才那个css样式隔离</span><br><span class="line">1，约定</span><br><span class="line">2，bem  注入可见标识</span><br><span class="line">3，</span><br></pre></td></tr></table></figure>

## 什么是跨域

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">跨域是由于浏览器的同源策略造成的</span><br><span class="line">必须协议，端口，域名完全相同才可以访问</span><br></pre></td></tr></table></figure>

## 项目上线跨域方面注意什么

反向代理需要特殊处理的，nignx 配置一下，其他应该不需要处理

## 什么是反向代理

代理服务器为服务器作代理人，站在服务器这边，它就是对外屏蔽了服务器的信息，常用的场景就是多台服务器分布式部署，像一些大的网站，由于访问人数很多，就需要多台服务器来解决人数多的问题，这时这些服务器就由一个反向代理服务器来代理，客户端发来请求，先由反向代理服务器，然后按一定的规则分发到明确的服务器，而客户端不知道是哪台服务器。常常用 nginx 来作反向代理。

## nignx 怎么配置

(Nginx 功能丰富，可作为 HTTP 服务器，也可作为反向代理服务器，邮件服务器。)

Nginx 在做反向代理时，提供性能稳定，并且能够提供配置灵活的转发功能。

在 nginx.conf 的注释符号为：**#**

默认的 nginx 配置文件 nginx.conf 内容如下：

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line">worker_processes  1;</span><br><span class="line">#error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line">events &#123;</span><br><span class="line">worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">include       mime.types;</span><br><span class="line">default_type  application/octet-stream;</span><br><span class="line">#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line">#access_log  logs/access.log  main;</span><br><span class="line">sendfile        on;</span><br><span class="line">#tcp_nopush     on;</span><br><span class="line">#keepalive_timeout  0;</span><br><span class="line">keepalive_timeout  65;</span><br><span class="line">#gzip  on;</span><br><span class="line">server &#123;</span><br><span class="line">listen       80;</span><br><span class="line">server_name  localhost;</span><br><span class="line">#charset koi8-r;</span><br><span class="line">#access_log  logs/host.access.log  main;</span><br><span class="line">location / &#123;</span><br><span class="line">root   html;</span><br><span class="line">index  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">#error_page  404              /404.html;</span><br><span class="line"># redirect server error pages to the static page /50x.html</span><br><span class="line">#</span><br><span class="line">error_page   500 502 503 504  /50x.html;</span><br><span class="line">location = /50x.html &#123;</span><br><span class="line">root   html;</span><br><span class="line">&#125;</span><br><span class="line"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">#</span><br><span class="line">#location ~ \.php$ &#123;</span><br><span class="line">#    proxy_pass   http://127.0.0.1;</span><br><span class="line">#&#125;</span><br><span class="line"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">#</span><br><span class="line">#location ~ \.php$ &#123;</span><br><span class="line">#    root           html;</span><br><span class="line">#    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">#    fastcgi_index  index.php;</span><br><span class="line">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">#    include        fastcgi_params;</span><br><span class="line">#&#125;</span><br><span class="line"># deny access to .htaccess files, if Apache&#x27;s document root</span><br><span class="line"># concurs with nginx&#x27;s one</span><br><span class="line">#</span><br><span class="line">#location ~ /\.ht &#123;</span><br><span class="line">#    deny  all;</span><br><span class="line">#&#125;</span><br><span class="line">&#125;</span><br><span class="line"># another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">#</span><br><span class="line">#server &#123;</span><br><span class="line">#    listen       8000;</span><br><span class="line">#    listen       somename:8080;</span><br><span class="line">#    server_name  somename  alias  another.alias;</span><br><span class="line">#    location / &#123;</span><br><span class="line">#        root   html;</span><br><span class="line">#        index  index.html index.htm;</span><br><span class="line">#    &#125;</span><br><span class="line">#&#125;</span><br><span class="line"># HTTPS server</span><br><span class="line">#</span><br><span class="line">#server &#123;</span><br><span class="line">#    listen       443 ssl;</span><br><span class="line">#    server_name  localhost;</span><br><span class="line">#    ssl_certificate      cert.pem;</span><br><span class="line">#    ssl_certificate_key  cert.key;</span><br><span class="line">#    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">#    ssl_session_timeout  5m;</span><br><span class="line">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">#    ssl_prefer_server_ciphers  on;</span><br><span class="line">#    location / &#123;</span><br><span class="line">#        root   html;</span><br><span class="line">#        index  index.html index.htm;</span><br><span class="line">#    &#125;</span><br><span class="line">#&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## 项目是怎么上线的

我们是打包给后端，后面就不是我负责了

## 打包工具

webpack(之前是 gulp 太久了，不熟悉了)，

如何打包：首先下载插件

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm intall webpack-bundle-analyzer --save-dev</span><br></pre></td></tr></table></figure>

同时在 webpack.config.js 配置

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const BundleAnalyzerPlugin = require(&#x27;webpack-bundle-analyzer&#x27;).BundleAnalyzerPlugin;</span><br><span class="line">webpackConfig.plugins.push(new BundleAnalyzerPlugin());</span><br></pre></td></tr></table></figure>

在 package.json 中添加命令

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">“script”: &#123;</span><br><span class="line">&quot;analyz&quot;: &quot;NODE_ENV=production npm_config_report=true npm run deploy:prod&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

然后命令行输入

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run analyz</span><br></pre></td></tr></table></figure>

app.js 和 vendor.js 是项目的主文件，其中包含了少部分业务代码和大部分公共依赖。
剩余的 number.hash.chunk.js 是业务分片的代码，其中包含了大部分业务代码和少部分公共依赖。

开始构建，根据项目大小不同，时间也不同。



## 为什么使用 hook

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">不必写class组件就可以用state和其他的React特性；</span><br><span class="line">可以使函数组件拥有类组件的一些功能和特性</span><br><span class="line">比如useState、useReducer  状态定义</span><br><span class="line">比如useEffect、useLayoutEffect 生命周期功能</span><br><span class="line">比如useRef useImperativeHandle 替代了类组件的 Ref（父组件获取子组件）</span><br><span class="line">为了优化函数组件，比如useMemo、useCallback</span><br><span class="line">函数组件添加新的方法</span><br><span class="line">  如useDebugValue显示自定义hook，自己添加hook类名</span><br><span class="line">  自定义hooks来复用状态</span><br></pre></td></tr></table></figure>

## 自定义 hook

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">实现组件的复用</span><br><span class="line">用useEffects代替生命周期方法(代码更加简洁)</span><br><span class="line">类似于高阶组件</span><br><span class="line">路由判断，类似路由守卫</span><br><span class="line">时间格式转换，</span><br><span class="line">封装axios</span><br><span class="line">高阶组件返回的一个类组件，而自定义Hook可以返回任何东西</span><br><span class="line">高阶组件必须传递一个组件作为参数，而自定义Hook不需要</span><br><span class="line">function useFriendStatus(friendID) &#123;</span><br><span class="line">  const [isOnline, setIsOnline] = useState(null);</span><br><span class="line">  // 在开发者工具中的这个 Hook 旁边显示标签</span><br><span class="line">  // e.g. &quot;FriendStatus: Online&quot;</span><br><span class="line">  useDebugValue(isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;);</span><br><span class="line">  return isOnline;</span><br><span class="line">&#125;</span><br><span class="line">可以理解为数据的操作都在hook里进行，而外部只关心自己想要的。我只要数据列表，获取产品钩子（可能并不需要，可通过参数变更从而触发重新获取数据）、删除产品钩子</span><br><span class="line">为了封装方法：节流；</span><br><span class="line">1.将组件中共用的逻辑放在统一的自定义hook中写</span><br><span class="line">2.自定义hook,hook名以use开头</span><br><span class="line">3.其他组件通过import引入自定义hook,就可以使用了</span><br></pre></td></tr></table></figure>

## 使用规则

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不要在循环，条件或嵌套函数中调用 Hook</span><br><span class="line">只在函数组件中使用 Hooks</span><br></pre></td></tr></table></figure>

## 常用 Hooks

### useState:

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">定义状态 修改状态</span><br><span class="line">返回一个数组，其中第一项是状态值，第二项是一个更新状态的函数。</span><br><span class="line">状态一旦改变，React 就会重新渲染组件，变量获取新的状态值。</span><br><span class="line">1.使用 useState() 进行状态管理</span><br><span class="line">	调用useState() Hook 来启用函数组件中的状态。</span><br><span class="line">	useState(initialValue)的第一个参数initialValue是状态的初始值。</span><br><span class="line">	[state, setState] = useState(initialValue)返回一个包含2个元素的数组:状态值和状态更新函数。</span><br><span class="line">	使用新值调用状态更新器函数setState(newState)更新状态。或者，可以使用一个回调setState(prev =&gt; next)来调用状态更新器，该回调将返回基于先前状态的新状态。</span><br><span class="line">	调用状态更新器后，React 确保重新渲染组件，以使新状态变为当前状态。</span><br><span class="line">2.多种状态</span><br><span class="line">	通过多次调用useState()，一个函数组件可以拥有多个状态。</span><br><span class="line">	需要注意的，要确保对useState()的多次调用在渲染之间始终保持相同的顺序。</span><br><span class="line">3.状态的延迟初始化</span><br><span class="line">	每当 React 重新渲染组件时，都会执行useState(initialState)。如果初始状态是原始值（数字，布尔值等），则不会有性能问题。</span><br><span class="line">	当初始状态需要昂贵的性能方面的操作时，可以通过为useState(computeInitialState)提供一个函数来使用状态的延迟初始化，该函数仅在初始渲染时执行一次，以获得初始状态。在以后的组件渲染中，不会再调用该函数，从而跳过昂贵的操作。</span><br><span class="line">4.调用 useState()</span><br><span class="line">在使用useState() Hook 时，必须遵循 Hook 的规则：</span><br><span class="line">1.仅顶层调用Hook:不能在循环，条件，嵌套函数等中调用useState()。在多个useState()调用中，渲染之间的调用顺序必须相同。</span><br><span class="line">2.仅从React 函数调用 Hook:必须仅在函数组件或自定义钩子内部调用useState()。</span><br></pre></td></tr></table></figure>

### useState 原理

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">let _state;                            //闭包，深拷贝</span><br><span class="line">function myUseState(initialValue) &#123;    //定义函数，传入state</span><br><span class="line">    _state = _state || initialValue;   //使用_state变量接受传入参数</span><br><span class="line">    function setState(newState) &#123;      //顶部定义setState方法</span><br><span class="line">        _state = newState;             //在setstate方法中修改state</span><br><span class="line">        render();</span><br><span class="line">    &#125;</span><br><span class="line">    return [_state, setState]          //返回变量和state方法</span><br><span class="line">&#125;</span><br><span class="line">多个state</span><br><span class="line">let _state = [];</span><br><span class="line">  let index = 0;</span><br><span class="line">  function myUseState(initialValue) &#123;</span><br><span class="line">    const currentIndex = index;</span><br><span class="line">    console.log(&#x27;currentINdex&#x27;, currentIndex)</span><br><span class="line">    _state[currentIndex] = _state[currentIndex] || initialValue;</span><br><span class="line">    function setState(newState) &#123;</span><br><span class="line">      _state[currentIndex] = newState;</span><br><span class="line">      render();</span><br><span class="line">    &#125;</span><br><span class="line">    index += 1;</span><br><span class="line">    return [_state[currentIndex], setState]</span><br><span class="line">  &#125;</span><br><span class="line">  const render = () =&gt;  &#123;</span><br><span class="line">    index = 0;</span><br><span class="line">    ReactDOM.render(&lt;App /&gt;,  document.getElementById(&#x27;root&#x27;))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

### useEffect:可以代替 DidMount，DidUpdate，willUnmount

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">相当于</span><br><span class="line">componentDidMount,</span><br><span class="line">componentDidUpdate,</span><br><span class="line">componentWillUnmount三个钩子的组合</span><br><span class="line">1  useEffect(() =&gt; &#123;&#125;,[])  相当于componentDidMount钩子作用</span><br><span class="line">2  useEffect(() =&gt; &#123;&#125;,[count])   相当于componentDidMount + componentDidUpdate + watch（只监听数组中数据的变化）钩子作用</span><br><span class="line">3  useEffect(() =&gt; &#123;&#125;)   不跟第二个参数，只要数据改变就触发</span><br><span class="line">4  useEffect(() =&gt; &#123; return () =&gt; &#123; console.log(&#x27;组件被销毁了&#x27;) &#125; &#125;)  相当于componentDidMount + componentWillUnmount</span><br><span class="line">用来弥补的</span><br><span class="line">参数一：执行的回调函数；</span><br><span class="line">参数二：该useEffect在哪些state发生变化时，才重新执行；</span><br><span class="line">第二个参数是空数组的时候执行一次,相当于componentDidMount,不加的时候执行多次</span><br><span class="line">第二个参数的作用就是 仅在更改时更新，实现性能的优化</span><br><span class="line">DOM操作 第三方实例化可以做 清除无用实例和事件</span><br><span class="line">useEffect传入的回调函数本身可以有一个返回值，</span><br><span class="line">这个返回值是另外一个回调函数，来模拟componentWillUnmount</span><br></pre></td></tr></table></figure>

### 什么是 useEffect 的副作用

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在完成某件事时附带执行的事，在useEffect的基本概念中，他表明了，在dom构建完成才执行，因为主要事是dom构建，所以其被称之为副作用</span><br></pre></td></tr></table></figure>

### cleanup 函数

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">他是副作用的清除，副作用可以在组件挂载，重绘之后任意执行，所以cleanup就永远只是清除上一个</span><br></pre></td></tr></table></figure>

### useMemo 和 useEffect 区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useMemo和useEffect的执行时机是不一致的：useEffect执行的是副作用，所以一定是在渲染之后执行的，useMemo是需要有返回值的，而返回值可以直接参与渲染的，所以useMemo是在渲染期间完成的，有这样一个一前一后的区别</span><br></pre></td></tr></table></figure>

### useLayoutEffect:

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">布局副作用</span><br><span class="line">    useEffect 在浏览器渲染完成后执行</span><br><span class="line">    useLayoutEffect 在浏览器渲染前执行</span><br><span class="line">useLayoutEffect 里的任务最好影响了 Layout</span><br><span class="line">为了用户体验，优先使用 useEffect (优先渲染)</span><br></pre></td></tr></table></figure>

### useLayoutEffect 和 useEffect 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useEffect：渲染内容更新到DOM -&gt;执行操作；</span><br><span class="line">useLayoutEffect：执行操作 -&gt; 渲染内容更新到DOM；惰性</span><br></pre></td></tr></table></figure>

### useContext:

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">跨组件通信 createContext创建一个组件</span><br><span class="line">&lt;numContext.Provider value=&#123;num&#125;&gt;</span><br></pre></td></tr></table></figure>

### useDebugValue:

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自定义 hook 的标签 方便调试台查看</span><br></pre></td></tr></table></figure>

### useMemo:

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">记忆组件，当新值和旧值一样,不重新渲染页面,优化作用,类似于shouldComponentUpdate useCallBack:</span><br><span class="line">作用和 useMemo 一样</span><br><span class="line">一般用来缓存计算的值，可以减少计算的量。</span><br><span class="line">useMemo 的第一个参数就是一个函数，这个函数返回的值会被缓存起来，同时这个值会作为 useMemo 的返回值，第二个参数是一个数组依赖，如果数组里面的值有变化，那么就会重新去执行第一个参数里面的函数，并将函数返回的值缓存起来并作为 useMemo 的返回值</span><br></pre></td></tr></table></figure>

### React.memo 和 useMemo 区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memo针对的是一个组件的渲染是否重复执行</span><br><span class="line">而useMemo则定义了一段函数逻辑是否重复执行</span><br><span class="line">（memo和useMemo只是用来做性能优化）</span><br></pre></td></tr></table></figure>

### useCallback

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用来缓存函数，返回值为一个记忆函数，这个记忆函数仅在某个依赖改变时才会更新。从而避免非必要的渲染。</span><br></pre></td></tr></table></figure>

### useCallback 和 useMemo 区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  useMemo返回的是计算的结果值，用于缓存计算后的状态</span><br><span class="line">  useCallback返回的是函数，主要用来缓存函数，因为函数式组件中的state的变化都会导致整个组件被重新刷新（即使一些函数没有必要被刷新），此时用useCallback就会将函数进行缓存，减少渲染时的性能损耗​；</span><br><span class="line">  useMemo和useCallback都会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行</span><br><span class="line">useCallback(x =&gt; console.log(x), [m]) 等价于</span><br><span class="line">useMemo( () =&gt; x =&gt; console.log(x), [m])</span><br><span class="line">共同点：只有在依赖数据发生变化后，才会重新计算结果，起到缓存的作用</span><br></pre></td></tr></table></figure>

### useRef:

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useRef 返回的值传递给组件或者 DOM 的 ref 属性，可以通过 ref.current 值访问组件或真实的 DOM 节点，组件也是可以访问到的，从而可以对 DOM 进行一些操作，比如监听事件等等。</span><br></pre></td></tr></table></figure>

### createRef 与 useRef 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">它像一个变量, 类似于 this , 它就像一个盒子, 你可以存放任何东西.</span><br><span class="line">createRef 每次渲染都会返回一个新的引用</span><br><span class="line">而 useRef 每次都会返回相同的引用。</span><br></pre></td></tr></table></figure>

### React  中  ref  的作用

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ref 是 React 提供的一种可以安全访问 DOM 元素或者某个组件实例的方式。</span><br><span class="line">在类组件中使用 `createRef()`，在函数组件中使用 `useRef` 。</span><br></pre></td></tr></table></figure>

### react 中的 ref 的 3 种方式

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">方式1: string类型绑定</span><br><span class="line">类似于vue中的ref绑定方式，可以通过this.refs.绑定的ref的名字获取到节点dom</span><br><span class="line">注意的是 这种方式已经不被最新版的react推荐使用，有可能会在未来版本中遗弃</span><br><span class="line"></span><br><span class="line">方式2: react.CreateRef()</span><br><span class="line">通过在class中使用React.createRef()方法创建一些变量，可以将这些变量绑定到标签的ref中</span><br><span class="line">那么该变量的current则指向绑定的标签dom</span><br><span class="line"></span><br><span class="line">方式3: 函数形式</span><br><span class="line">在class中声明函数，在函数中绑定ref</span><br><span class="line">使用这种方法可以将子组件暴露给父组件以使得父组件能够调用子组件的方法</span><br><span class="line">通过函数的方法绑定ref可以将整个子组件暴露给父组件</span><br><span class="line">​</span><br><span class="line">当在子组件中调用onRef函数时，正在调用从父组件传递的函数。this.props.onRef（this）这里的参数指向子组件本身，父组件接收该引用作为第一个参数：onRef = &#123;ref =&gt;（this.child = ref）&#125;然后它使用this.child保存引用。之后，可以在父组件内访问整个子组件实例，并且可以调用子组件函数。</span><br></pre></td></tr></table></figure>

### react 父组件通过 ref 获取不到子组件的解决方案

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修正this指向</span><br><span class="line">在子组件中</span><br><span class="line">this.customfunction = this.customfunction.bind(this);</span><br></pre></td></tr></table></figure>

useImperativeHandle:

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将组件中的方法放到外面使用</span><br><span class="line">搭配React.forwardRef</span><br></pre></td></tr></table></figure>

## 如果用的 hook，在组件销毁的时候怎么实现监听

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们可以使用react的Effect hook，</span><br><span class="line">Effect hook的第一个参数可以return一个函数，这样就可以在组件销毁的时候触发它：</span><br><span class="line">根据此hook组件的参数来进行判断，我们在此组件的父组件上将this.props.history传到这个组件上</span><br></pre></td></tr></table></figure>

#

# Promise

## promise 对象

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ES6新增的一种异步解决方案，解决了之前异步回调地狱的问题</span><br><span class="line">Promise有三种状态，pending进行中，resolved成功，rejected失败</span><br><span class="line">特点是：状态不受外界改变，并且状态一旦改变，不可更改。不能暂停</span><br><span class="line">可以使用链式调用方法</span><br><span class="line">当成功时可以使用.then()          第二个参数，失败的回调</span><br><span class="line">失败时可以使用.catch()</span><br><span class="line">不管状态如何都执行的操作.finally()</span><br><span class="line">Promise.race():只要有一个promise执行完毕后就会执行.then操作</span><br><span class="line">promise.all()：将多个promise实例包装成一个新的实例，参数为数组，只有当数组里的所有状态都是resolved新的状态才是resolved，返回值在全部成功时是一个结果数组，数组顺序和接收的顺序一致，失败时是第一个失败状态的值；</span><br></pre></td></tr></table></figure>

## promise.all 和 promise.race

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pomise.all的使用</span><br><span class="line">    Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。</span><br><span class="line">    Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，在前端开发请求数据的过程中，偶尔会遇到发送多个请求并根据请求顺序获取和使用数据的场景，使用Promise.all毫无疑问可以解决这个问题。</span><br><span class="line">Promise.race的使用</span><br><span class="line">    Promise.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。</span><br></pre></td></tr></table></figure>

## promise.all 封装思路

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">参数是数组，数组每一项是promises对象</span><br><span class="line">返回promise对象</span><br><span class="line">定义数字0，</span><br><span class="line">对数组进行循环，如果成功，每次循环数字++，如果数字和数组长度相等，则返回resolve()</span><br><span class="line">如果失败直接直接返回reject</span><br></pre></td></tr></table></figure>

# promise，async，await 区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async / await与 Promise的主要区别是：</span><br><span class="line">Promise代码完全都是Promise的API（then、catch等等），操作本身的语义反而不容易看出来, </span><br><span class="line">async / await函数的实现最简洁，最符合语义，几乎没有语义不相关的代码 </span><br><span class="line">async / await 函数就是 Generator 函数的语法糖</span><br><span class="line">async/await函数的优势 </span><br><span class="line">1. 使用async函数可以让代码简洁很多，不需要像Promise一样需要些then，不需要写匿名函数处理Promise的resolve值，也不需要定义多余的data变量，还避免了嵌套代码  </span><br><span class="line">2. 使用aync/await的话，catch能处理JSON.parse错误 promise中不能处理     </span><br><span class="line">3. 条件语句也和错误捕获是一样的，在 Async 中也可以像平时一般使用条件语句  </span><br></pre></td></tr></table></figure>

## async、await

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  async异步是用来装饰函数的，一个函数如果加上 async ，那么该函数就会返回一个 Promise对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句</span><br><span class="line">  await关键字只能在async函数中使用。可以用来等待Promise状态变成resolved并有返回值。await后面通常跟的是一个promise对象，如果不是，会立即被包装成resoled状态的promise。</span><br><span class="line">  如果await后面的 promise 正常resolve，await promise便会返回结果。但是在reject的情况下，便会抛出异常，并且这种异常需要用try/catch来捕获，整个async函数都会中断执行。</span><br><span class="line">  可以把async看成将函数返回值使用 Promise.resolve() 包裹了下</span><br><span class="line"></span><br><span class="line">await本身返回的也是一个Promise,它只是把await后面的代码放到了await返回的Promise的.then后面，以此来实现的。</span><br><span class="line">await只是让当前async函数内部、后面的代码等待，并不是所有代码都卡在这里。遇到await就先返回，执行async函数之后的代码。</span><br></pre></td></tr></table></figure>

## async/await 优势

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.简洁，不用匿名函数，不需要多余data避免嵌套</span><br><span class="line">2.catch能处理JSON.parse错误</span><br><span class="line">3.可以使用条件语句</span><br><span class="line">同步还是异步  </span><br><span class="line">	await同步   </span><br><span class="line">	async异步</span><br><span class="line">async和await有两个关键字,一个写在函数外面,一个写在函数里面,函数外面是异步的，函数里面是同步的，调用函数的那一行其实是异步的,下一行</span><br><span class="line">函数里面转成阻塞的</span><br><span class="line">async使用的时候报错,如何捕获try...catch</span><br><span class="line">var test3 = async function () &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      await p1();</span><br><span class="line">      await p2();</span><br><span class="line">      p3();</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      console.log(&#x27;p1失败了&#x27;, e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">await后面有个接口  </span><br><span class="line">接口要2S才能完成    接口2S才会执行</span><br></pre></td></tr></table></figure>

# Generate

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Generator 的中文名称是生成器，它是ES6中提供的新特性。</span><br><span class="line">在过去，函数只存在“没有被调用”或者“被调用”的情况，</span><br><span class="line">不存在一个函数被执行之后还能暂停的情况，而Generator的出现让这种情况成为可能。</span><br><span class="line">通过 function* 来定义的函数称之为“生成器函数”（generator function），它的特点是可以中断函数的执行，</span><br><span class="line">每次执行yield语句之后，函数即暂停执行，直到调用返回的生成器对象的next()函数它才会继续执行。</span><br><span class="line">也就是说 Generator 函数是一个状态机，封装了多个内部状态。</span><br><span class="line">执行 Generator 函数返回一个遍历器对象（一个指向内部状态的指针对象），</span><br><span class="line">调用遍历器对象的next方法，使得指针移向下一个状态。每次调用next方法，</span><br><span class="line">内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。</span><br><span class="line">yield关键字</span><br><span class="line">真正让Generator具有价值的是yield关键字，这个yield关键字让 Generator内部的逻辑能够切割成多个部分。</span><br><span class="line">发现函数执行到第一个yield关键字的时候就停止了。要让业务逻辑继续执行完，需要反复调用.next()</span><br><span class="line">可以简单地理解为yield关键字将程序逻辑划分成几部分，每次.next()执行时执行一部分。</span><br><span class="line">这使得程序的执行单元再也不是函数，复杂的逻辑可以通过yield来暂停。</span><br><span class="line">.next()调用时，返回一个对象，这个对象具备两个属性。</span><br><span class="line">其中一个属性是布尔型的done。它表示这个Generator对象的逻辑块是否执行完成。</span><br><span class="line">另一个属性是value，它来自于yield语句后的表达式的结果。</span><br><span class="line">通过.next()传递参数，可以赋值给yield关键字前面的变量声明。</span><br></pre></td></tr></table></figure>

# # 深浅拷贝

# 深浅拷贝

浅拷贝

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.使用Object.assign</span><br><span class="line">2.使用展开运算符（…）</span><br></pre></td></tr></table></figure>

浅拷贝只解决了第一层的问题，如果接下去的值还有对象的话，那就需要用深拷贝
深拷贝

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1.通过 JSON.parse(JSON.stringify(o bject)) 来解决。</span><br><span class="line">但是该方法也是有局限性的：</span><br><span class="line">  - 会忽略 undefined</span><br><span class="line">  - 会忽略 symbol</span><br><span class="line">  - 如果对象里有函数,函数无法被拷贝下来</span><br><span class="line">  - 无法拷贝对象原型链上的属性和方法</span><br><span class="line">  - 当数据的层次很深，会栈溢出</span><br><span class="line">如果遇到这些情况，可以使用递归或者 lodash 的深拷贝函数</span><br><span class="line">2.普通递归函数</span><br><span class="line">function deepCopy( source ) &#123;</span><br><span class="line">if (!isObject(source)) return source; //如果不是对象的话直接返回</span><br><span class="line">    let target = Array.isArray( source ) ? [] : &#123;&#125; //数组兼容</span><br><span class="line">    for ( var k in source ) &#123;</span><br><span class="line">    	if (source.hasOwnProperty(k)) &#123;</span><br><span class="line">    		if ( typeof source[ k ] === &#x27;object&#x27; ) &#123;</span><br><span class="line">            	target[ k ] = deepCopy( source[ k ] )</span><br><span class="line">        	&#125; else &#123;</span><br><span class="line">            	target[ k ] = source[ k ]</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return target</span><br><span class="line">&#125;</span><br><span class="line">function isObject(obj) &#123;</span><br><span class="line">    return typeof obj === &#x27;object&#x27; &amp;&amp; obj !== null</span><br><span class="line">&#125;</span><br><span class="line">将要拷贝的数据 obj 以参数的形式传参</span><br><span class="line">声明一个变量 来储存我们拷贝出来的内容</span><br><span class="line">判断 obj 是否是引用类型数据，如果不是，则直接赋值即可（ 可以利用 obj instanceof Type 来进行判断），</span><br><span class="line">由于用 instanceof 判断array 是否是object的时候，返回值为true, 所以我们在判断的时候，直接判断obj 是否是Array 就可避免这个问题</span><br><span class="line">根据判断的不同类型，再给之前的变量赋予不同的类型： [ ] : &#123; &#125;</span><br><span class="line">循环obj 中的每一项，如果里面还有复杂数据类型，则直接利用递归再次调用copy函数</span><br><span class="line">最后 将 这个变量 return 出来即可</span><br><span class="line">缺点：</span><br><span class="line">（1）无法保持引用</span><br><span class="line">（2）当数据的层次很深，会栈溢出</span><br></pre></td></tr></table></figure>

## 对象浅拷贝在 react 中用到哪些地方,为什么

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为什么在react中要使用浅拷贝</span><br><span class="line">redux中要求:状态是只读的,唯一且不可修改的,reducer必须是一个纯函数</span><br><span class="line">因为redux中数据不可更改,所以redux中的数据应该要拷贝  返回一个新值</span><br></pre></td></tr></table></figure>

# # 递归

自己调用自己

# React   Css 模块化

stylemoment，行内样式，webpack 配置

# 生命周期

# # Redux

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">react component-》action create -》store-》reducer-》store-》component</span><br><span class="line">用户产生了操作，调用了actions的方法</span><br><span class="line">actions将action通过调用store.dispatch方法发送到了reducer中，并传入两个参数：当前的state和收到的action</span><br><span class="line">reducer接收到action并根据标识信息，比如type进行判断之后返回新的state</span><br><span class="line">store的state被reducer更改为新state的时候，store.subscribe方法里的回调函数会执行，此时就可以通知view去重新获取state，页面刷新</span><br></pre></td></tr></table></figure>

# # Es6 新增

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">let const     都有块级作用域，不具备变量提升，不能重复申明</span><br><span class="line">箭头函数 =&gt;；   语法简洁</span><br><span class="line">模板字符串      可读性强，使用$&#123;&#125;定义变量</span><br><span class="line">展开运算符      把数组或对象展开成,比如浅拷贝，数组扁平化</span><br><span class="line">解构赋值        数组或者对象进行模式匹配，对其中的变量进行赋值，语法简洁</span><br><span class="line">Promise        一种异步函数处理模式，语法简洁</span><br><span class="line">import模块化    封闭作用域，项目规范</span><br><span class="line">for-of遍历、for-in遍历；     for-in更适合遍历对象 for of遍历数组</span><br><span class="line">函数默认参数     可以设定初始值</span><br><span class="line">Set            似于数组，特性是所有元素都是唯一的，没有重复。</span><br><span class="line">Symbol         表示独一无二的值，最大的用法是用来定义对象的唯一属性名</span><br><span class="line">代理（proxy）</span><br><span class="line">新增数组方法</span><br><span class="line">1.Array.from()  方法用于将对象转为真正的数组(类数组转数组)</span><br><span class="line">2.Array.of()    方法用于将一组值，转换为数组。</span><br><span class="line">   console.log(Array.of(1,2,3,4,4,50));//[1, 2, 3, 4, 4, 50]</span><br><span class="line">3.Object.assign  (目标对象,对象1,对象2)用于对象的合并,将源对象的所有可枚举属性，复制到目标对象。(浅拷贝)</span><br><span class="line">Generators生成器函数</span><br><span class="line">  	总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。</span><br><span class="line">    </span><br><span class="line">Set结构和Map结构 </span><br><span class="line">1.Set:它类似于数组，但是成员的值都是唯一的，没有重复的值。</span><br><span class="line">Set本身是一个构造函数，用来生成 Set 数据结构，数组作为参数。</span><br><span class="line">        //数组去重</span><br><span class="line">        // let arr=[1,2,3,4,5,6,6,5,4,3,2,1];</span><br><span class="line">        // console.log([...new Set(arr)]);//[1, 2, 3, 4, 5, 6]</span><br><span class="line">        </span><br><span class="line">2.Map数据结构。它类似于对象，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</span><br></pre></td></tr></table></figure>

# # 箭头函数区别

1. 写法简单

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">省略function关键字，如果只有一个参数可以省略小括号，代码块只有一条语句，可以省略大括号，省略大括号还有自动return的作用，等等</span><br></pre></td></tr></table></figure>

2. this 指向更加明确

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">箭头函数表达式的语法比函数表达式更简洁</span><br><span class="line">箭头函数没有自己的this值,指向的是它外层的不是箭头函数的函数，如果没有则指向widnow，不能被改变</span><br><span class="line">适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</span><br><span class="line">是</span><br></pre></td></tr></table></figure>

### 箭头函数和普通函数的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法简洁，this指向明确</span><br><span class="line">普通函数参数可以使用arguments拿到参数</span><br><span class="line">箭头函数可以使用rest参数：形式为...变量名</span><br></pre></td></tr></table></figure>

# # 模块化区别

# js 的几种模块规范

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">js 中现在比较成熟的有四种模块加载方案：</span><br><span class="line">​</span><br><span class="line">第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</span><br><span class="line">​</span><br><span class="line">第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。</span><br><span class="line">​</span><br><span class="line">第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。</span><br><span class="line">​</span><br><span class="line">第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。</span><br></pre></td></tr></table></figure>

# AMD 和 CMD 规范的区别？

cmd 是前置，所以引入的时候就会出 bug，amd 是后置，所以使用的时候才会引入，加载，就才会报 bug，

cmd 浪费资源

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">它们之间的主要区别有两个方面。</span><br><span class="line">第一个方面是在模块定义时对依赖的处理不同。AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。</span><br><span class="line">第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句</span><br><span class="line">的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</span><br></pre></td></tr></table></figure>

# ES6 模块与 CommonJS 模块、AMD、CMD 的差异

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.CommonJS 模块输出的是一个值的拷贝，</span><br><span class="line">ES6 模块输出的是值的引用。</span><br><span class="line">CommonJS 模块输出的是值的，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</span><br><span class="line">ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</span><br><span class="line">2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</span><br><span class="line">而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</span><br></pre></td></tr></table></figure>

##

# # 闭包

闭包本质是函数嵌套小函数，定义在一个函数内部的函数(函数嵌套函数)，外层函数的值会传到内部函数当中，外层函数返回内层函数

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function A() &#123;</span><br><span class="line">  let a = 1</span><br><span class="line">  function B() &#123;</span><br><span class="line">      console.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  return B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## 特性：

1.封闭性——外界无法在闭包没有提供接口的情况下访问闭包内部的数据；

2.持久性——在函数调用结束后，不会像普通函数一样自动注销函数，闭包内的数据会一直在

优点：

1.减少全局变量；！！隔离作用域，会照成变量空间无法释放，模块化，模块化的好处就是，抽离代码，重复使用，如现在很直观的代表 npm 包

2.减少传递 函数的数据量；

3.高度封装

缺点：

闭包会常驻内存，增大内存使用量，使用不当很容易造成内存泄露

当不需要使用闭包时手动释放，设置变量赋值为 null

## 使用场景

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、通过循环给页面上多个dom节点绑定事件</span><br><span class="line">2、封装私有变量(计数器)</span><br><span class="line">3、延续局部变量的寿命</span><br><span class="line">4、高阶组件</span><br><span class="line">5、函数防抖</span><br><span class="line">模块化的就是以闭包为基构建的;</span><br></pre></td></tr></table></figure>

## 主流的布局方式有哪些？

### **一、\*\***静态布局\*\*

即传统 Web 设计，网页上的所有元素的尺寸一律使用 px 作为单位。

1、布局特点

不管浏览器尺寸具体是多少，网页布局始终按照最初写代码时的布局来显示。常规的 pc 的网站都是静态（定宽度）布局的，也就是设置了 min-width，这样的话，如果小于这个宽度就会出现滚动条，如果大于这个宽度则内容居中外加背景，这种设计常见于 pc 端。

### **二、\*\***流式布局\***\*（Liquid Layout）**

流式布局（Liquid）的特点（也叫&quot;Fluid&quot;) 是页面元素的宽度按照屏幕分辨率进行适配调整，但整体布局不变。代表作栅栏系统（网格系统）。

网页中主要的划分区域的尺寸使用百分数（搭配 min-*、max-*属性使用），例如，设置网页主体的宽度为 80%，min-width 为 960px。图片也作类似处理（width:100%, max-width 一般设定为图片本身的尺寸，防止被拉伸而失真）。

1. 布局特点

屏幕分辨率变化时，页面里元素的大小会变化而但布局不变。【这就导致如果屏幕太大或者太小都会导致元素无法正常显示。

2. 设计方法

使用%百分比定义宽度，高度大都是用 px 来固定住，可以根据可视区域 (viewport) 和父元素的实时尺寸进行调整，尽可能的适应各种分辨率。往往配合 max-width/min-width 等属性控制尺寸流动范围以免过大或者过小影响阅读。

这种布局方式在 Web 前端开发的早期历史上，用来应对不同尺寸的 PC 屏幕（那时屏幕尺寸的差异不会太大），在当今的移动端开发也是常用布局方式，但缺点明显：主要的问题是如果屏幕尺度跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示。因为宽度使用%百分比定义，但是高度和文字大小等大都是用 px 来固定，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度、文字大小还是和原来一样（即，这些东西无法变得“流式”），显示非常不协调。

---

### **三、\*\***自适应布局\***\*（Adaptive Layout）**

自适应布局的特点是分别为不同的屏幕分辨率定义布局，即创建多个静态布局，每个静态布局对应一个屏幕分辨率范围。改变屏幕分辨率可以切换不同的静态局部（页面元素位置发生改变），但在每个静态布局中，页面元素不随窗口大小的调整发生变化。可以把自适应布局看作是静态布局的一个系列。

1、布局特点

屏幕分辨率变化时，页面里面元素的位置会变化而大小不会变化。

2、设计方法

使用  @media 媒体查询给不同尺寸和介质的设备切换不同的样式。在优秀的响应范围设计下可以给适配范围内的设备最好的体验，在同一个设备下实际还是固定的布局。

---

### **四、\*\***响应式布局\***\*（Responsive Layout）**

随着 CSS3 出现了媒体查询技术，又出现了响应式设计的概念。响应式设计的目标是确保一个页面在所有终端上（各种尺寸的 PC、手机、手表、冰箱的 Web 浏览器等等）都能显示出令人满意的效果，对 CSS 编写者而言，在实现上不拘泥于具体手法，但通常是糅合了流式布局+弹性布局，再搭配**媒体查询**技术使用。——分别为不同的屏幕分辨率定义布局，同时，在每个布局中，应用流式布局的理念，即页面元素宽度随着窗口调整而自动适配。即：创建多个流体式布局，分别对应一个屏幕分辨率范围。可以把响应式布局看作是流式布局和自适应布局设计理念的融合。

**响应式几乎已经成为优秀页面布局的标准。**

1. 布局特点

每个屏幕分辨率下面会有一个布局样式，即素位置和大小都会变。

2. 设计方法

媒体查询+流式布局。通常使用  @media 媒体查询   和网格系统 (Grid System) 配合相对布局单位进行布局，实际上就是综合响应式、流动等上述技术通过 CSS 给单一网页不同设备返回不同样式的技术统称。

优点：适应 pc 和移动端，如果足够耐心，效果完美。

缺点：（1）媒体查询是有限的，也就是可以枚举出来的，只能适应主流的宽高。（2）要匹配足够多的屏幕大小，工作量不小，设计也需要多个版本。

响应式页面在头部会加上这一段代码：

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;applicable-device&quot; content=&quot;pc,mobile&quot;&gt;&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-transform &quot;&gt;</span><br></pre></td></tr></table></figure>

---

### **五、\*\***弹性布局\***\*（rem/em 布局）**

1. rem/em 区别：rem 是相对于 html 元素的 font-size 大小而言的，而 em 是相对于其父元素。

2.使用 em 或 rem 单位进行相对布局，相对%百分比更加灵活，同时可以支持浏览器的字体大小调整和缩放等的正常显示，因为 em 是相对父级元素的原因没有得到推广。【中国站点制作网页的时候，习惯用 CSS 强制定义字体大小，保证每个人都看到一致的效果，包括网易、搜狐这些门户网站在内的大部分站点，用的都是绝对单位 px（像素）。但是，如果从网站易用性方面考虑，字体大小应该是可变的，一些视力不是那么好的人需要放大字体才能看得清页面内容。然而，占据大部分浏览器市场的 IE 无法调整那些使用 px 作为单位的字体大小。国外人士非常重视网站的易用性，相当一部分外国站点已经使用 em 作为字体单位。

3.  这类布局的特点是，包裹文字的各元素的尺寸采用 em/rem 做单位，而页面的主要划分区域的尺寸仍使用百分数或 px 做单位（同「流式布局」或「静态/固定布局」）。早期浏览器不支持整个页面按比例缩放，仅支持网页内文字尺寸的放大，这种情况下。使用 em/rem 做单位，可以使包裹文字的元素随着文字的缩放而缩放。

4.浏览器的默认字体高度一般为 16px，即 1em:16px，但是 1:16 的比例不方便计算，为了使单位 em/rem 更直观，CSS 编写者常常将页面跟节点字体设为 62.5%，比如选择用 rem 控制字体时，先需要设置根节点 html 的字体大小，因为浏览器默认字体大小 16px\*62.5%=10px。这样 1rem 便是 10px，方便了计算。

5.  用 em/rem 定义尺寸的另一个好处是更能适应缩进/以字体单位 padding 或 margin／浏览器设置字体尺寸等情况（因为 em/rem 相对于字体大小，会同步改变）。例如：p&#123; text-indent: 2em; &#125;。

6. 使用 rem 单位的弹性布局在移动端也很受欢迎。

7.  其实在移动端使用所谓的弹性布局，是比较勉强的。移动端弹性布局流行起来的原因归根结底是 rem 单位对于（根据屏幕尺寸）调整页面的各元素的尺寸、文字大小时比较好用。其实，使用 vw、vh 等后起之秀的单位，可以实现完美的流式布局（高度和文字大小都可以变得“流式”），弹性布局就不再必要了。

**总结结论：**

1.如果只做 pc 端，那么静态布局（定宽度）是最好的选择；

2.如果做移动端，且设计对高度和元素间距要求不高，那么弹性布局（rem+js）是最好的选择，一份 css+一份 js 调节 font-size 搞定；

3.如果 pc，移动要兼容，而且要求很高那么响应式布局还是最好的选择，前提是设计根据不同的高宽做不同的设计，响应式根据媒体查询做不同的布局。

## 可以继承的属性有哪些？

### 字体系列属性

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">font-family：字体系列</span><br><span class="line">font-weight：字体的粗细</span><br><span class="line">font-size：字体的大小</span><br><span class="line">font-style：字体的风格</span><br></pre></td></tr></table></figure>

### 文本系列属性

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">text-indent：文本缩进</span><br><span class="line">text-align：文本水平对齐</span><br><span class="line">line-height：行高</span><br><span class="line">word-spacing：单词之间的间距</span><br><span class="line">letter-spacing：中文或者字母之间的间距</span><br><span class="line">text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）</span><br><span class="line">color：文本颜色</span><br></pre></td></tr></table></figure>

### 元素可见性：

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visibility：控制元素显示隐藏</span><br></pre></td></tr></table></figure>

### 列表布局属性：

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list-style：列表风格，包括list-style-type、list-style-image等</span><br></pre></td></tr></table></figure>

### 光标属性：

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cursor：光标显示为何种形态</span><br></pre></td></tr></table></figure>

# Js

## 介绍一下 js 的数据类型以及区分的方法？

基本类型 7 个

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">number:数字</span><br><span class="line">string:字符串</span><br><span class="line">boolean:布尔值</span><br><span class="line">null:空对象</span><br><span class="line">undefined:未定义/未初始化</span><br><span class="line">symbol(森bou):独一无二的值，ES6 新增</span><br><span class="line">BigInt:大整数，能够表示超过 Number 类型大小限制的整数，ES11新增</span><br></pre></td></tr></table></figure>

复杂类型(引用)

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object:对象。Array/数组 和 function/函数 也属于对象的一种</span><br></pre></td></tr></table></figure>

区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基本类型是存放在栈里的，基本类型的比较是它们的值的比较</span><br><span class="line">引用类型将地址存在栈内，将内容储存在堆内，引用类型比较是地址</span><br></pre></td></tr></table></figure>

### null 和 undefined 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</span><br><span class="line">undefined 代表的含义是未定义，</span><br><span class="line">null 代表的含义是空对象（其实不是真的对象，请看下面的注意！）。一般变量声明了但还没有定义的时候会返回 undefined，null</span><br><span class="line">主要用于赋值给一些可能会返回对象的变量，作为初始化。</span><br><span class="line">当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等 号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</span><br></pre></td></tr></table></figure>

### 检测数据类型

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ES6检测数组 Array.isArray([])</span><br><span class="line">1.typeof：可以检测基本类型，但是引用类型都返回Object</span><br><span class="line">2.instanceof：可以检测引用类型，但不能检测基本类型</span><br><span class="line">3.Object.prototype.toString.call()可以检测所有类型</span><br><span class="line">检测方法4种</span><br><span class="line"> 1、typeOf</span><br><span class="line">    作用: 用于检测基本数据类型和函数</span><br><span class="line">    弊端: 引用数据类型(Arrary/function/object)只会返回Object, 不起作用</span><br><span class="line">    语法: typeOf &quot; &quot;/[ ]/xx</span><br><span class="line">    返回值: &quot;string&quot;/&quot;boolean&quot;/&quot;object&quot; (无法区分)</span><br><span class="line"> 2、instanceOf</span><br><span class="line">    原理: 判断对象类型，基于原型链去判断(obj instanceof Object)</span><br><span class="line">    左边对象的原型链proto上是否有右边构造函数的proptotype属性</span><br><span class="line">    作用: 判断左边的对象是否是右边构造函数的实例</span><br><span class="line">    弊端: 用于引用类型的检测, 对于基本数据类型不生效</span><br><span class="line">    语法: &quot; &quot;/[ ]/true instanceOf String/Array/Boolean</span><br><span class="line">    返回值: true/false</span><br><span class="line"> 3、Object.prototype.toString.call()</span><br><span class="line">    作用: 可以检测所有数据类型</span><br><span class="line">    所有数据类型都可以检测,而且非常正确</span><br><span class="line">    语法: Object.prototype.toString.call( &#x27;xxx&#x27;/11/[ ] )</span><br><span class="line">    返回值: [object Xxx], Xxx 就是对象的类型</span><br><span class="line"> 4、constructor</span><br><span class="line">    作用: 可以检测基本数据类型和引用数据类型</span><br><span class="line">    弊端: 把类的原型进行重写, 很有可能把之前的constructor覆盖 检测出来的结果就会不准确</span><br><span class="line">    语法: (&quot;xx&quot;)/([])/(function()&#123;&#125;).constructor === String/Array/Function</span><br><span class="line">    返回值: true/false</span><br></pre></td></tr></table></figure>

## js 数组有哪些原生方法及对应功能,列举一下

### 数组 API

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pop删除最后一个元素，原数组；</span><br><span class="line">shift删除第一个元素，原数组；</span><br><span class="line">push添加一个新元素在最后，原数组；</span><br><span class="line">unshift添加一个新元素到第一个位置，原数组；</span><br><span class="line">reverse颠倒数组，原数组；</span><br><span class="line">splice（万能的），原数组；</span><br><span class="line">sort特定顺序排序，原数组；</span><br><span class="line">fill填充一些变量到指定位置，原数组；</span><br><span class="line">join用特定字符拼接数组成字符串；</span><br><span class="line">tolocatestring将时间对象转换为字符串格式；</span><br><span class="line">slice截取片段，新数组；</span><br><span class="line">cancat数组最后加元素，新数组；</span><br><span class="line">indexof查找数组里的特定元素，返回索引或-1；</span><br><span class="line">lastindexof倒序查找；</span><br><span class="line">includes返回数组是否包含某个元素；</span><br><span class="line">foreach遍历，执行回调；</span><br><span class="line">every检测每个元素符不符合条件；</span><br><span class="line">some检测有没有元素符合条件；</span><br><span class="line">filter返回过滤后的新数组；</span><br><span class="line">map返回每个都被操作过的元素组成的新数组；</span><br><span class="line">reduce归并，接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值；</span><br><span class="line">find返回第一个满足条件的元素；</span><br><span class="line">findqiindex返回满足条件的元素的索引</span><br></pre></td></tr></table></figure>

## 闭包以及应用场景？

### 闭包

闭包本质是函数嵌套小函数，外层函数的值会传到内部函数当中，外层函数返回内层函数，内层函数就是闭包

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function A() &#123;</span><br><span class="line">  let a = 1</span><br><span class="line">  function B() &#123;</span><br><span class="line">      console.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  return B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

### 特性：

1.封闭性——外界无法在闭包没有提供接口的情况下访问闭包内部的数据；

2.持久性——在函数调用结束后，不会像普通函数一样自动注销函数，闭包内的数据会一直在

优点：

1.减少全局变量；隔离作用域，会照成变量空间无法释放，模块化

2.减少传递 函数的数据量；

3.高度封装

缺点：

闭包会常驻内存，增大内存使用量，使用不当很容易造成内存泄露

当不需要使用闭包时手动释放，设置变量赋值为 null

### 使用场景

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、通过循环给页面上多个dom节点绑定事件</span><br><span class="line">2、封装私有变量(计数器)</span><br><span class="line">3、延续局部变量的寿命</span><br><span class="line">4、高阶组件</span><br><span class="line">5、函数防抖</span><br><span class="line">模块化的就是以闭包为基础构建的;</span><br></pre></td></tr></table></figure>

## 异步编程的方式有哪些？

### 1、Callback 回调函数

假设 func1()执行需要较长的时间，而 func2()等待前者的执行结果

可以将 func2()写成为 func1()的回调函数

Function func1(callback) &#123;

setTimeOut(function () &#123;

// Exe a long time

Callback();

&#125;, 1000);

&#125;

代码变成 func1(func2)

优点：简单，容易写

缺点：不利于维护和阅读，高度耦合，每个任务只能指定一个回调函数

### 2、事件监听

采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个时间按是否发生。

Func1.on(“done”, func2)

Function func1()&#123;

setTimeOut( function() &#123;

// Exe a long time

Func1.trigger(“done”);

&#125;, 1000);

&#125;

优点：容易理解，封装 done，可以绑定多个事件，去耦合，有利于模块化

缺点：整个程序变成事件驱动型，运行流程不清晰

### 3、发布/订阅

设置一个“信号中心”，某个任务执行完成，向信号中心“发布”(publish)一个信号，其他任务可以向信号中心“订阅”(subscribe)这个信号，从而可以执行。这是 publish-subscribe pattern，又叫观察者模式(observer pattern)

这 func2 可以向信号中心”jQuery”订阅”done”信号。

jQuery.subscribe(“done”, func2);

Function func1()&#123;

setTimeOut(function ()&#123;

// Exe a long time

jQuery.publish(“done”);

&#125;, 1000);

&#125;

在 func1 执行完之后，信号中心发布 done 信号，引发 func2 执行。

同时，func2 还可以取消订阅：jQuery.unsubscribe(“done”, func2)

### 4、Promises 对象

Promises 对象是 CommonJS 工作组提出的一种规范，目的是为异步编程提供统一接口

思想：每一个异步任何返回一个 Promise 对象，对象有个 then 方法，允许指定回调函数

Func1().then(func2)

Function func1() &#123;

Var dfd = $.Defered();

setTimeOut( function() &#123;

// Exe a long time

Dfd.resolve();

&#125;, 1000);

Return dfd.promise;

&#125;

Promise 的状态：pending，fulfilled，和 rejected 三种状态，只有两种转换（1，pending -&gt; fulfilled，2, pending-&gt;rejected）,每种转换只能发生一次。

Promise 的 then 方法：then 方法用于指定异步事件完成之后的回调函数。

还可以针对链式回调 Fun1().then(fuc2).then(func3)

### 5、Generator

除了上面的基于回调函数来实现异步的，还有 Generator，最大的特点是可以产生函数的重启和暂停，Python 的协程 Coroutine 的实现。

# reactF

## React 中组件通信方式有哪些?

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">1.父组件向子组件通信</span><br><span class="line">React数据流动是单向的</span><br><span class="line">父组件通过props自定义属性向子组件传递需要的信息</span><br><span class="line">子组件直接使用props.调用</span><br><span class="line">2.子组件向父组件通信</span><br><span class="line">父组件将一个函数作为 props 传递给子组件</span><br><span class="line">子组件内调用该回调函数，便可以向父组件通信。</span><br><span class="line">//  父组件定义状态、用来保存子组件数据的函数</span><br><span class="line">//  子组件触发函数传参</span><br><span class="line">3.非嵌套组件间通信</span><br><span class="line">非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</span><br><span class="line">    1.利用二者共同父组件的 context 对象进行通信</span><br><span class="line">    2.使用自定义事件的方式</span><br><span class="line">    3.采用组件间共同的父级来进行中转</span><br><span class="line">4.跨组件通信</span><br><span class="line">父组件向子组件的子组件通信，向更深层的子组件通信。</span><br><span class="line">中间组件层层传递 props</span><br><span class="line">使用 context 对象</span><br><span class="line">5.使用 context 对象:</span><br><span class="line">    context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。</span><br><span class="line">    父组件使用createContext().Provider包裹子组件，使用value传递状态</span><br><span class="line">    子组件在createContext().Consumer组件内，直接使用状态</span><br><span class="line">使用 context 也很简单，需要满足两个条件：</span><br><span class="line">    上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</span><br><span class="line">    子组件要声明自己需要使用 context</span><br><span class="line">5.redux</span><br><span class="line">首先由view dispatch拦截action，然后执行对应reducer并更新到store中，最终views会根据store数据的改变执行界面的刷新渲染操作。</span><br><span class="line">    通过创建一个store实例createStore,接收一个rootReducer和中间件执行函数</span><br><span class="line">    创建分块的数据rootReducer,通过combineReducers打造rootReducer,里面放分块的数据</span><br><span class="line">    在组件中通过高阶组件connect函数,接收store里的数据,把ActionCreators里的方法绑定到组件身上,</span><br><span class="line">      并且可以发送动作action给reducer</span><br><span class="line">    在reductor中根据action中的type动作类型,判断动作修改数据</span><br></pre></td></tr></table></figure>

## 谈谈高阶组件和 Render Props 应用场景？

### 高阶组件

**本质**

本质是函数，将组件作为接收参数，返回一个新的组件。HOC 本身不是 React API，是一种基于 React 组合的特而形成的设计模式。

**解决的问题（作用）**

- 一句话概括：功能的复用，减少代码冗余
- 进一步解释：在实际情况中，多个组件可能会做某些相同的事情，有着相同的功能，存在大量的代码冗余。我们可以将这部分功能拆分出来，每个组件尽量只保留自己独有的作用，通过 HOC 生成我们最终需要的组件。

**实现方法：**

无论哪种方法，都是在 HOC 函数内定义新的组件，在新的组件内做一些公共的功能和事情

1. 属性代理
2. 反向继承

**属性代理**

这是最常规的写法，原理等同于 ES7 装饰器、Python 装饰器。函数传入的参数，除了原组件，还可以定义其他的参数，通过这些参数来区别每个实际组件。比如，公共的功能是获取数据。获取数据这件事情是相同的，但获取的内容不同。如何决定最后生成的组件获取各自指定的内容呢？通过函数传参。

在这里，React 第三方的组件库通常使用 函数柯里化 的写法。对于使用者来说，改变了调用函数时的传参方式，更加容易理解。即：原本调用函数 wrapper(Component, params1, params2)  柯里化后调用 wrapper(params1,params2)(Component)

**属性代理常见的作用：**

1. 操作 props
2. 通过 Refs 访问组件实例
3. 提取 state
4. 组合更多的 html 元素

**反向继承**

顾名思义，就是将返回的组件继承了原组件。它允许生成的组件通过 this 获取原组件，意味着可以获取到 state,props,生命周期钩子，以及 render

**作用：**

1. 渲染劫持。由于新组件可以控制原组件的 render 方法，可以做各种控制渲染的操作。
2. 操作 state

**注意点：**

1. 不要在函数内修改原组件
2. 使用反向继承方式时，会丢失原本的显示名
3. 不要在 render 函数中使用 HOC

**高阶组件的缺点：**

1. 难以溯源。如果原始组件 A 通过好几个 HOC 的构造，最终生成了组件 B，不知道哪个属性来自于哪个 HOC，需要翻看每个 HOC 才知道各自做了什么事情，使用了什么属性。
2. props 属性名的冲突。某个属性可能被多个 HOC 重复使用。
3. 静态构建。新的组件是在页面构建之前生成，先有组件，后生成页面。

### Render Props

**作用**

1. 功能的复用，与 HOC 类似。
2. 组件间数据的单向传递。

**什么是 Render Props？**

是一个用于告知组件要渲染什么内容的函数属性。该函数返回一个组件，是渲染出来的内容。

通过以上 Demo 可以看到，Mouse 组件通过 render 属性（属性名也可以是别的名字），指定了渲染哪个子组件，并且子组件可以接收参数值，进而实现内部逻辑。

再进行分析，发现 Mouse 组件提供可变数据源，是一个基础数据的提供者，最关键的代码是：

| 1   | &#123;this.props.render(this.state)&#125; |
| :-- | :------------------------------ |

通过 render 属性，将数据传递给另外一个组件。至于这个数据拿来干什么，怎么去渲染，就不是它管的事情了。

因此，整个页面很多地方可能需要用到鼠标坐标数据，以上的例子就可以实现功能的复用。

**相对高阶组件的优点：**

1. 不用担心 props 的命名冲突的问题
2. 可以溯源，子组件的 props 一定来自父组件。
3. 是动态构建的，页面在渲染后，可以动态地决定渲染哪个组件。
4. 所有能用 HOC 完成的事情，Render Props 都可以做，且更加灵活。
5. 除了功能复用，还可以用作两个组件的单向数据传递。

## useRef,useState 的区别?

### useState:

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">定义状态 修改状态</span><br><span class="line">返回一个数组，其中第一项是状态值，第二项是一个更新状态的函数。</span><br><span class="line">状态一旦改变，React 就会重新渲染组件，变量获取新的状态值。</span><br><span class="line">1.使用 useState() 进行状态管理</span><br><span class="line">	调用useState() Hook 来启用函数组件中的状态。</span><br><span class="line">	useState(initialValue)的第一个参数initialValue是状态的初始值。</span><br><span class="line">	[state, setState] = useState(initialValue)返回一个包含2个元素的数组:状态值和状态更新函数。</span><br><span class="line">	使用新值调用状态更新器函数setState(newState)更新状态。或者，可以使用一个回调setState(prev =&gt; next)来调用状态更新器，该回调将返回基于先前状态的新状态。</span><br><span class="line">	调用状态更新器后，React 确保重新渲染组件，以使新状态变为当前状态。</span><br><span class="line">2.多种状态</span><br><span class="line">	通过多次调用useState()，一个函数组件可以拥有多个状态。</span><br><span class="line">	需要注意的，要确保对useState()的多次调用在渲染之间始终保持相同的顺序。</span><br><span class="line">3.状态的延迟初始化</span><br><span class="line">	每当 React 重新渲染组件时，都会执行useState(initialState)。如果初始状态是原始值（数字，布尔值等），则不会有性能问题。</span><br><span class="line">	当初始状态需要昂贵的性能方面的操作时，可以通过为useState(computeInitialState)提供一个函数来使用状态的延迟初始化，该函数仅在初始渲染时执行一次，以获得初始状态。在以后的组件渲染中，不会再调用该函数，从而跳过昂贵的操作。</span><br></pre></td></tr></table></figure>

### useRef:

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useRef 返回的值传递给组件或者 DOM 的 ref 属性，可以通过 ref.current 值访问组件或真实的 DOM 节点，组件也是可以访问到的，从而可以对 DOM 进行一些操作，比如监听事件等等。</span><br></pre></td></tr></table></figure>

那他们的区别我的理解是：

1: useState 的值在每个 rernder 中都是独立存在的。而 useRef.current 则更像是相对于 render 函数的一个全局变量，每次他会保持 render 的最新状态。这种关系更像是 js 一个经典的案例：for 循环中异步打印 i 的值，let 声明的 i 就相当于每个都是独立作用域，互相之间不会干扰。var 则反之。

2：useState 值的更新会触发组件重新渲染，而 useRef 的 current 不会出发重渲染。

## Hooks 需要遵循什么规则?

1.仅顶层调用 Hook:不能在循环，条件，嵌套函数等中调用

2.仅在 React 函数调用 Hook:必须仅在函数组件或自定义钩子内部调用

## ✌️ Hook 的规则

Hook 是 JavaScript 函数，但强加了两个额外的规则：

- 只能在顶层调用 Hook，不要在循环、条件或嵌套函数中调用 Hook。
- 仅从 React 函数式组件中调用 Hook。不要从常规 JavaScript 函数调用 Hook。（还有另一个有效的地方来调用 Hook，即你的自定义 Hook。）

# 面试

# Redux 流程

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">react component-》action create -》store-》reducer-》store-》component</span><br><span class="line">用户产生了操作，调用了actions的方法</span><br><span class="line">actions将action通过调用store.dispatch方法发送到了reducer中，并传入两个参数：当前的state和收到的action</span><br><span class="line">reducer接收到action并根据标识信息，比如type进行判断之后返回新的state</span><br><span class="line">store的state被reducer更改为新state的时候，store.subscribe方法里的回调函数会执行，此时就可以通知view去重新获取state，页面刷新</span><br></pre></td></tr></table></figure>

# **闭包**

闭包本质是函数嵌套小函数，定义在一个函数内部的函数(函数嵌套函数)，外层函数的值会传到内部函数当中，外层函数返回内层函数

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function A() &#123;</span><br><span class="line">  let a = 1</span><br><span class="line">  function B() &#123;</span><br><span class="line">      console.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  return B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## 特性：

1.封闭性——外界无法在闭包没有提供接口的情况下访问闭包内部的数据；

2.持久性——在函数调用结束后，不会像普通函数一样自动注销函数，闭包内的数据会一直在

优点：

1.减少全局变量；！！隔离作用域，会照成变量空间无法释放，模块化，模块化的好处就是，抽离代码，重复使用，如现在很直观的代表 npm 包

2.减少传递 函数的数据量；

3.高度封装

缺点：

闭包会常驻内存，增大内存使用量，使用不当很容易造成内存泄露

当不需要使用闭包时手动释放，设置变量赋值为 null

## 使用场景

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、通过循环给页面上多个dom节点绑定事件</span><br><span class="line">2、封装私有变量(计数器)</span><br><span class="line">3、延续局部变量的寿命</span><br><span class="line">4、高阶组件</span><br><span class="line">5、函数防抖</span><br><span class="line">模块化的就是以闭包为基础构建的;</span><br></pre></td></tr></table></figure>

# 防抖和节流

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">防抖：（按钮提交场景，防止多次点击，只执行最后一次，搜索框的联想场景）</span><br><span class="line">在事件触发时，开始计时，在规定的时间（delay）内，若再次触发事件，将上一次计时（timer）清空，然后重新开始计时。保证只有在规定时间内没有再次触发事件之后，再去执行这个事件.</span><br><span class="line">节流：（拖拽场景，固定时间只执行一次、缩放场景，监控浏览器resize）</span><br><span class="line">指定时间间隔内，若事件被多次触发，只会执行一次</span><br><span class="line">使用时间戳实现</span><br><span class="line">在事件触发之后，开始计时，在规定的时间（delay）内，若再次触发事件，不对此事件做任何处理。保证在规定时间内只执行一次</span><br></pre></td></tr></table></figure>

防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。
防抖

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">函数防抖</span><br><span class="line">* fn [function] 需要防抖的函数</span><br><span class="line">* delay [number] 毫秒，防抖期限值</span><br><span class="line">function debounce(fn,delay)&#123;</span><br><span class="line">    let timer = null</span><br><span class="line">    //借助闭包</span><br><span class="line">    return function() &#123;</span><br><span class="line">        if(timer)&#123;</span><br><span class="line">            clearTimeout(timer) //进入该分支语句，说明当前正在一个计时过程中，并且又触发了相同事件。所以要取消当前的计时，重新开始计时</span><br><span class="line">            timer = setTimeOut(fn,delay) </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            timer = setTimeOut(fn,delay) // 进入该分支说明当前并没有在计时，那么就开始一个计时</span><br><span class="line">        &#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

# 异步

## 同步异步区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在js中，所有任务都分为同步任务和异步任务两大类。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</span><br><span class="line">（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</span><br><span class="line">（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</span><br><span class="line">（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</span><br><span class="line">（4）主线程不断重复上面的第三步。</span><br></pre></td></tr></table></figure>

## js 异步操作

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、定时器都是异步操作</span><br><span class="line">2、事件绑定都是异步操作</span><br><span class="line">3、AJAX中一般我们都采取异步操作（也可以同步）</span><br><span class="line">4、回调函数可以理解为异步（不是严谨的异步操作）</span><br><span class="line">5、promise</span><br><span class="line">6、generator（ES6）</span><br><span class="line">   通过yield关键字可以让任务在需要的地方暂停,每一步的值可以通过next获取</span><br><span class="line">7、async/await(ES7)</span><br><span class="line">   await得到的就是async异步返回值,底层原理还是promise中的resolve方法</span><br><span class="line">8、设计模式-发布订阅模式</span><br><span class="line">9、事件监听</span><br></pre></td></tr></table></figure>

# promise 对象

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ES6新增的一种异步解决方案，解决了之前异步回调地狱的问题</span><br><span class="line">Promise有三种状态，pending进行中，resolved成功，rejected失败</span><br><span class="line">特点是：状态不受外界改变，并且状态一旦改变，不可更改。不能暂停</span><br><span class="line">可以使用链式调用方法</span><br><span class="line">当成功时可以使用.then()          第二个参数，失败的回调</span><br><span class="line">失败时可以使用.catch()</span><br><span class="line">不管状态如何都执行的操作.finally()</span><br><span class="line">Promise.race():只要有一个promise执行完毕后就会执行.then操作</span><br><span class="line">promise.all()：将多个promise实例包装成一个新的实例，参数为数组，只有当数组里的所有状态都是resolved新的状态才是resolved，返回值在全部成功时是一个结果数组，数组顺序和接收的顺序一致，失败时是第一个失败状态的值；</span><br></pre></td></tr></table></figure>

# promise/async&amp;await

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">Promise是es6新增的，异步编程的一种解决方案，用来取代回调函数和事件，比传统的解决方案——回调函数和事件——更合理和更强大。</span><br><span class="line">​</span><br><span class="line">Promise 对象用于延迟(deferred) 计算和异步(asynchronous)计算。一个Promise对象代表着一个还未完成，但预期将来会完成的操作。Promise 对象是一个返回值的代理，这个返回值在promise对象创建时未必已知。它允许你为异步操作的成功或失败指定处理方法。这使得异步方法可以像同步方法那样返回值:异步方法会返回一个包含了原返回值的 promise 对象来替代原返回值。</span><br><span class="line">​</span><br><span class="line">有三种状态：pending（进行中）、fulfilled（resolve已成功）和rejected(锐杰克腾德)（已失败）</span><br><span class="line">​</span><br><span class="line">promise的特点：</span><br><span class="line">（1）对象的状态不受外界影响。Promise对象代表一个异步操作。</span><br><span class="line">（2）一旦状态设定，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为resolve和从pending变为rejected。只要这两种情况发生，状态就凝固了</span><br><span class="line">    </span><br><span class="line">promise的方法：</span><br><span class="line">promise实例方法：</span><br><span class="line">    Promise.prototype.then        </span><br><span class="line">    Promise.prototype.catch</span><br><span class="line"></span><br><span class="line">    一：resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</span><br><span class="line">    二：reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</span><br><span class="line">    三：Promise.prototype.finally</span><br><span class="line">    finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</span><br><span class="line">​</span><br><span class="line">promise的静态方法  </span><br><span class="line">    Promise.all():用于将多个 Promise 实例，包装成一个新的 Promise 实例，接受一个数组作为参数，只有数组里面的每个状态都变成resolve，则新的 Promise 实例状态才会变成resolve.</span><br><span class="line">    Promise.race():将Promise对象数组中最先执行完成的内容通过后面then传出</span><br><span class="line">    </span><br><span class="line">promise的基本使用：</span><br><span class="line">通过new promise创建一个promise对象，里面有一个参数，参数是一个回调函数，</span><br><span class="line">回调函数中有2个参数：resolve、reject</span><br><span class="line">    resolve()当异步执行成功的时候调用的方法，reject()当异步失败的时候调用的方法。</span><br><span class="line">除此之外promise有一个then方法，当成功的时候执行第一个回调函数，当失败的时候执行第二个回调函数。</span><br><span class="line">第二个回调函数也可以通过promise对象.catch调用</span><br><span class="line">​</span><br><span class="line">Promise.all():当所有的异步代码都执行完毕以后才会执行.then中的操作</span><br><span class="line">Promise.race():只要有一个promise执行完毕后就会执行.then操作</span><br><span class="line">​</span><br><span class="line">promise的三种状态：</span><br><span class="line">1.pending - 进行中</span><br><span class="line">2.fulfilled - 成功</span><br><span class="line">3.rejected - 失败</span><br><span class="line">​</span><br><span class="line">链式调用:</span><br><span class="line">promise俗称链式调用，它是es6中最重要的特性之一</span><br><span class="line">简单的说可以不停的then调用嵌套在调用（异步之后，链式调用方式执行回调），这种操作方式称为promise</span><br><span class="line">​</span><br><span class="line">async异步能干什么？</span><br><span class="line">就是用来修饰函数，使该函数异步执行，不阻碍后续函数的执行</span><br><span class="line">同时我们注意到，async修饰的函数也带有then catch方法，</span><br><span class="line">因此，经async修饰的函数也 是一个promise await只能放在async中，且只能修饰promise对象</span><br><span class="line">    1. promise的诞生是为了简化函数嵌套调用流程，也便于后续维护</span><br><span class="line">    2. async/await定义了异步函数，并在其内部可通过await等待promise对象，阻塞后 续的执行</span><br><span class="line">​</span><br><span class="line">await关键字必须在async函数里面</span><br><span class="line">await会阻塞当前直到完成 async返回reject的方法,当抛出异常等同于reject</span><br><span class="line">​</span><br><span class="line">async / await与 Promise的主要区别是：</span><br><span class="line">Promise代码完全都是Promise的API（then、catch等等），操作本身的语义反而不容易看出来,</span><br><span class="line">async / await函数的实现最简洁，最符合语义，几乎没有语义不相关的代码</span><br><span class="line">async / await 函数就是 Generator 函数的语法糖</span><br><span class="line">​</span><br><span class="line">async/await函数的优势</span><br><span class="line">1. 使用async函数可以让代码简洁很多，不需要像Promise一样需要些then，不需要写匿名函数处理Promise的resolve值，也不需要定义多余的data变量，还避免了嵌套代码</span><br><span class="line">2. 使用aync/await的话，catch能处理JSON.parse错误 promise中不能处理</span><br><span class="line">3. 条件语句也和错误捕获是一样的，在 Async 中也可以像平时一般使用条件语句</span><br><span class="line">​</span><br><span class="line">promise的状态处理的原理:</span><br><span class="line">​</span><br><span class="line">​</span><br></pre></td></tr></table></figure>

## promise.all 和 promise.race

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pomise.all的使用</span><br><span class="line">    Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。</span><br><span class="line">    Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，在前端开发请求数据的过程中，偶尔会遇到发送多个请求并根据请求顺序获取和使用数据的场景，使用Promise.all毫无疑问可以解决这个问题。</span><br><span class="line">Promise.race的使用</span><br><span class="line">    Promise.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。</span><br></pre></td></tr></table></figure>

## promise.all 封装思路

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">参数是数组，数组每一项是promises对象</span><br><span class="line">返回promise对象</span><br><span class="line">定义数字0，</span><br><span class="line">对数组进行循环，如果成功，每次循环数字++，如果数字和数组长度相等，则返回resolve()</span><br><span class="line">如果失败直接直接返回reject</span><br></pre></td></tr></table></figure>

# promise，async，await 区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async / await与 Promise的主要区别是：</span><br><span class="line">Promise代码完全都是Promise的API（then、catch等等），操作本身的语义反而不容易看出来, </span><br><span class="line">async / await函数的实现最简洁，最符合语义，几乎没有语义不相关的代码 </span><br><span class="line">async / await 函数就是 Generator 函数的语法糖</span><br><span class="line">async/await函数的优势 </span><br><span class="line">1. 使用async函数可以让代码简洁很多，不需要像Promise一样需要些then，不需要写匿名函数处理Promise的resolve值，也不需要定义多余的data变量，还避免了嵌套代码  </span><br><span class="line">2. 使用aync/await的话，catch能处理JSON.parse错误 promise中不能处理     </span><br><span class="line">3. 条件语句也和错误捕获是一样的，在 Async 中也可以像平时一般使用条件语句  </span><br></pre></td></tr></table></figure>

# async、await

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  async异步是用来装饰函数的，一个函数如果加上 async ，那么该函数就会返回一个 Promise对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句</span><br><span class="line">  await关键字只能在async函数中使用。可以用来等待Promise状态变成resolved并有返回值。await后面通常跟的是一个promise对象，如果不是，会立即被包装成resoled状态的promise。</span><br><span class="line">  如果await后面的 promise 正常resolve，await promise便会返回结果。但是在reject的情况下，便会抛出异常，并且这种异常需要用try/catch来捕获，整个async函数都会中断执行。</span><br><span class="line">  可以把async看成将函数返回值使用 Promise.resolve() 包裹了下</span><br><span class="line"></span><br><span class="line">await本身返回的也是一个Promise,它只是把await后面的代码放到了await返回的Promise的.then后面，以此来实现的。</span><br><span class="line">await只是让当前async函数内部、后面的代码等待，并不是所有代码都卡在这里。遇到await就先返回，执行async函数之后的代码。</span><br></pre></td></tr></table></figure>

## async/await 优势

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.简洁，不用匿名函数，不需要多余data避免嵌套</span><br><span class="line">2.catch能处理JSON.parse错误</span><br><span class="line">3.可以使用条件语句</span><br><span class="line">同步还是异步  </span><br><span class="line">	await同步   </span><br><span class="line">	async异步</span><br><span class="line">async和await有两个关键字,一个写在函数外面,一个写在函数里面,函数外面是异步的，函数里面是同步的，调用函数的那一行其实是异步的,下一行</span><br><span class="line">函数里面转成阻塞的</span><br><span class="line">async使用的时候报错,如何捕获try...catch</span><br><span class="line">var test3 = async function () &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      await p1();</span><br><span class="line">      await p2();</span><br><span class="line">      p3();</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      console.log(&#x27;p1失败了&#x27;, e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">await后面有个接口  </span><br><span class="line">接口要2S才能完成    接口2S才会执行</span><br></pre></td></tr></table></figure>

# Generate

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Generator 的中文名称是生成器，它是ES6中提供的新特性。</span><br><span class="line">在过去，函数只存在“没有被调用”或者“被调用”的情况，</span><br><span class="line">不存在一个函数被执行之后还能暂停的情况，而Generator的出现让这种情况成为可能。</span><br><span class="line">通过 function* 来定义的函数称之为“生成器函数”（generator function），它的特点是可以中断函数的执行，</span><br><span class="line">每次执行yield语句之后，函数即暂停执行，直到调用返回的生成器对象的next()函数它才会继续执行。</span><br><span class="line">也就是说 Generator 函数是一个状态机，封装了多个内部状态。</span><br><span class="line">执行 Generator 函数返回一个遍历器对象（一个指向内部状态的指针对象），</span><br><span class="line">调用遍历器对象的next方法，使得指针移向下一个状态。每次调用next方法，</span><br><span class="line">内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。</span><br><span class="line">yield关键字</span><br><span class="line">真正让Generator具有价值的是yield关键字，这个yield关键字让 Generator内部的逻辑能够切割成多个部分。</span><br><span class="line">发现函数执行到第一个yield关键字的时候就停止了。要让业务逻辑继续执行完，需要反复调用.next()</span><br><span class="line">可以简单地理解为yield关键字将程序逻辑划分成几部分，每次.next()执行时执行一部分。</span><br><span class="line">这使得程序的执行单元再也不是函数，复杂的逻辑可以通过yield来暂停。</span><br><span class="line">.next()调用时，返回一个对象，这个对象具备两个属性。</span><br><span class="line">其中一个属性是布尔型的done。它表示这个Generator对象的逻辑块是否执行完成。</span><br><span class="line">另一个属性是value，它来自于yield语句后的表达式的结果。</span><br><span class="line">通过.next()传递参数，可以赋值给yield关键字前面的变量声明。</span><br></pre></td></tr></table></figure>

# js 作用域和作用域链

作用域：

作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。

作用域链：

作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。

作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。

当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。

# 对 this、call、apply 和 bind 的理解

1、在浏览器里，在全局范围内 this 指向 window 对象；

2、在函数中，this 永远指向最后调用他的那个对象；

3、构造函数中，this 指向 new 出来的那个新的对象；

4、call、apply、bind 中的 this 被强绑定在指定的那个对象上；

5、箭头函数中 this 比较特殊,箭头函数 this 为父作用域的 this，不是调用时的 this.要知道前四种方式,都是调用时确定,也就是动态的,而箭头函数的 this 指向是静态的,声明的时候就确定了下来；

6、apply、call、bind 都是 js 给函数内置的一些 API，调用他们可以为函数指定 this 的执行,同时也可以传参。

- call 和 apply 都是为了解决改变 this 的指向。作用都是相同的，只是传参的方式不同。
- 除了第一个参数外，call 可以接收一个参数列表，apply 只接受一个参数数组。
- bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化。

# 深/浅拷贝针对的是引用类型

浅拷贝

浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。

新旧互相影响,改变的是地址

新值===原值,只能拷贝一层

数组方法: slice 截取, concat 拼接, filter 过滤, map

对象方法: Object.assign(&#123;&#125;,obj), Object.create(obj)

展开运算符: &#123;...obj&#125;,[...arr]

深拷贝

深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象

新旧互不影响,改变的是值

新值=/=原值,可以拷贝多层

1、JSON 序列化

JSON.parse(JSON.stringify(obj))对象--&gt;字符串--&gt;对象

这个方式的弊端：

1、如果 obj 里面有时间对象，则 JSON.stringify 后再 JSON.parse 的结果，时间将只是字符串的形式，而不是对 象的形式

2、如果 obj 里有 RegExp(正则表达式的缩写)、Error 对象，则序列化的结果将只得到空对象；

3、如果 obj 里有函数，undefined，则序列化的结果会把函数或 undefined 丢失；

4、如果 obj 里有 NaN、Infinity 和-Infinity，则序列化的结果会变成 null

5、JSON.stringify()只能序列化对象的可枚举的自有属性，不可枚举的不能被复制

可枚举:可枚举性（enumerable）用来控制所描述的属性，是否将被包括在 for...in 循环之中。具体来说，如果一个属性的 enumerable 为 false，下面三个操作不会取到该属性。

for..in 循环、Object.keys 方法、JSON.stringify 方法

2、原生实现

递归+浅拷贝

3、工具实现【第三方封装库】

loadsh \_.cloneDeep(obj)

.DeepClone()

用于 Model / Entity / ... ... 等引用类型对象的深度克隆

特性说明

1.不需要对对象做任何特殊处理，直接 .DeepClone() 即可得到该对象的深度克隆

2.不受对象层次深度限制，均可实现深度克隆（下面会给出几个简单示例 ... ...）

Immutable

Object.create()

# setstate 同步/异步原理

setState 在合成事件和钩子函数中是异步的

在原生事件和 setTimeout 中是同步的

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">在react中调用setState后会将当前传入的值与已存在的状态合并</span><br><span class="line">可以写一个对象，或者写一个回调</span><br><span class="line">setState()函数接受两个参数，一个是一个对象，就是设置的状态，还有一个是一个回调函数，函数的参数即为 state 的前一个状态以及 props，是在设置状态成功之后执行的，所以我们可以通过回掉拿到最新的state值</span><br><span class="line">1. 同步/异步原理</span><br><span class="line">    setState在合成事件和钩子函数中是异步的</span><br><span class="line">    在原生事件和setTimeout中是同步</span><br><span class="line">2. 两个参数及用法</span><br><span class="line">    第一个参数可以是对象或者函数，用来更新state</span><br><span class="line">    第二个参数用来获取最新的state，可以做dom操作，数据请求，第三方库实例化</span><br><span class="line">* setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。</span><br><span class="line">* 如果对同一个值进行多次 setState，setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。</span><br></pre></td></tr></table></figure>

# 调用  setState  之后发生了什么

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在代码中调用 setState 函数之后，React 会将传入的参数与之前的状态进行合并，然后触发调和过程（Reconciliation），根据新的树和老的树之间的差异对界面进行最小化重新渲染。通过 diff 算法，React 能够精确制导哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</span><br></pre></td></tr></table></figure>

# ES6 新增

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">let const     都有块级作用域，不具备变量提升，不能重复申明</span><br><span class="line">箭头函数 =&gt;；   语法简洁</span><br><span class="line">模板字符串      可读性强，使用$&#123;&#125;定义变量</span><br><span class="line">展开运算符      把数组或对象展开成,比如浅拷贝，数组扁平化</span><br><span class="line">解构赋值        数组或者对象进行模式匹配，对其中的变量进行赋值，语法简洁</span><br><span class="line">Promise        一种异步函数处理模式，语法简洁</span><br><span class="line">import模块化    封闭作用域，项目规范</span><br><span class="line">for-of遍历、for-in遍历；     for-in更适合遍历对象 for of遍历数组</span><br><span class="line">函数默认参数     可以设定初始值</span><br><span class="line">Set            似于数组，特性是所有元素都是唯一的，没有重复。</span><br><span class="line">Symbol         表示独一无二的值，最大的用法是用来定义对象的唯一属性名</span><br><span class="line">代理（proxy）</span><br><span class="line">新增数组方法</span><br><span class="line">1.Array.from()  方法用于将对象转为真正的数组(类数组转数组)</span><br><span class="line">2.Array.of()    方法用于将一组值，转换为数组。</span><br><span class="line">   console.log(Array.of(1,2,3,4,4,50));//[1, 2, 3, 4, 4, 50]</span><br><span class="line">3.Object.assign  (目标对象,对象1,对象2)用于对象的合并,将源对象的所有可枚举属性，复制到目标对象。(浅拷贝)</span><br><span class="line">Generators生成器函数</span><br><span class="line">  	总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。</span><br><span class="line">    </span><br><span class="line">Set结构和Map结构 </span><br><span class="line">1.Set:它类似于数组，但是成员的值都是唯一的，没有重复的值。</span><br><span class="line">Set本身是一个构造函数，用来生成 Set 数据结构，数组作为参数。</span><br><span class="line">        //数组去重</span><br><span class="line">        // let arr=[1,2,3,4,5,6,6,5,4,3,2,1];</span><br><span class="line">        // console.log([...new Set(arr)]);//[1, 2, 3, 4, 5, 6]</span><br><span class="line">        </span><br><span class="line">2.Map数据结构。它类似于对象，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</span><br></pre></td></tr></table></figure>

# 合成事件

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">与原生事件的区别</span><br><span class="line">   React合成事件一套机制：React并不是将click事件直接绑定在dom上面，而是采用事件冒泡的形式冒泡到document上面，然后React将事件封装给正式的函数处理运行和处理。</span><br></pre></td></tr></table></figure>

# Webpack

## webpack

## \* webpack 的了解一点基本功能和工作原理？

- **Entry**：入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。
- **Module**：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。
- **Chunk**：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。
- **Loader**：模块转换器，用于把模块原内容按照需求转换成新内容。
- **Plugin**：扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。
- **Output**：输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。

Webpack 启动后会从 Entry 里配置的 Module 开始递归解析 Entry 依赖的所有 Module。 每找到一个 Module， 就会根据配置的 Loader 去找出对应的转换规则，对 Module 进行转换后，再解析出当前 Module 依赖的 Module。 这些模块会以 Entry 为单位进行分组，一个 Entry 和其所有依赖的 Module 被分到一个组也就是一个 Chunk。最后 Webpack 会把所有 Chunk 转换成文件输出。 在整个流程中 Webpack 会在恰当的时机执行 Plugin 里定义的逻辑。

在实际应用中你可能会遇到各种奇怪复杂的场景，不知道从哪开始。 根据以上总结，你会对 Webpack 有一个整体的认识，这能让你在以后使用 Webpack 的过程中快速知道应该通过配置什么去完成你想要的功能，而不是无从下手。

## 什么是 bundle,什么是 chunk，什么是 module?

我们直接写出来的是 module，

webpack 处理时是 chunk，

最后生成浏览器可以直接运行的 bundle。

## \* Webpack 你用过哪些常见的 Loader？plugin？分别是解决什么问题？

Loader 可以看作具有文件转换功能的翻译员，配置里的`module.rules`数组配置了一组规则，告诉 Webpack 在遇到哪些文件时使用哪些 Loader 去加载和转换。 如上配置告诉 Webpack 在遇到以`.css`结尾的文件时先使用`css-loader`读取 CSS 文件，再交给`style-loader`把 CSS 内容注入到 JavaScript 里。 在配置 Loader 时需要注意的是：

Webpack 是通过`plugins`属性来配置需要使用的插件列表的。`plugins`属性是一个数组，里面的每一项都是插件的一个实例，在实例化一个组件时可以通过构造函数传入这个组件支持的配置属性。

## \* loader 和 plugin 的区别

## \* webpack 的构建流程是什么?

[Webpack](https://webpack.js.org/)是一个打包模块化 JavaScript 的工具，在 Webpack 里一切文件皆模块，通过 Loader 转换文件，通过 Plugin 注入钩子，最后输出由多个模块组合成的文件。Webpack 专注于构建模块化项目。

一切文件：JavaScript、CSS、SCSS、图片、模板，在 Webpack 眼中都是一个个模块，这样的好处是能清晰的描述出各个模块之间的依赖关系，以方便 Webpack 对模块进行组合和打包。 经过 Webpack 的处理，最终会输出浏览器能使用的静态资源。

Webpack 具有很大的灵活性，能配置如何处理文件

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">webpack打包react  vue,与自己的源代码分离使用splitchunks</span><br><span class="line">webpack热更新:不用刷新浏览器而将新变更的模块替换掉旧的模块。</span><br><span class="line">​</span><br><span class="line">webpack会分析每个入口文件，解析包依赖关系的各个文件，每个模块都打包到bundle.js。webpack给每个模块分配一个唯一的ID并通过这个ID索引和访问模块。页面运行时，先启动entry.js，其他模块会在运行require时候执行。</span><br><span class="line">​</span><br><span class="line">1.Webpack  Loader   Plugin</span><br><span class="line">​</span><br><span class="line">（loader ，plugin分别什么作用，哪个配置可以把依赖包抽离出来，不打包进去）</span><br><span class="line">【Loader】：用于对模块源码的转换，loader描述了webpack如何处理非javascript模块，并且在buld中引入这些依赖。loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。babel-loader优雅降级配置ES高版本转成低版本</span><br><span class="line">​</span><br><span class="line">【Plugin】：是用于在webpack打包编译过程里，在对应的事件节点里执行自定义操作，比如资源管理、bundle文件优化等操作,</span><br><span class="line">​</span><br><span class="line">依赖包抽离  const ExtractTextWebapckPlugin= require(&quot;extract-text-webpack-plugin&quot;)    module    exclude node_modules</span><br><span class="line">​</span><br><span class="line">排除excloude排除node_modules</span><br><span class="line">​</span><br><span class="line">loader的使用很简单：</span><br><span class="line">​</span><br><span class="line">在webpack.config.js中指定loader。module.rules可以指定多个loader，对项目中的各个loader有个全局概览。</span><br><span class="line">​</span><br><span class="line">loader是运行在NodeJS中，可以用options对象进行配置。plugin可以为loader带来更多特性。loader可以进行压缩，打包，语言翻译等等。</span><br><span class="line">​</span><br><span class="line">loader从模板路径解析，npm install node_modules。也可以自定义loader，命名XXX-loader。</span><br><span class="line">​</span><br><span class="line">语言类的处理器loader：CoffeeScript，TypeScript，ESNext（Bable）,Sass,Less,Stylus。任何开发技术栈都可以使用webpack。</span><br><span class="line">​</span><br><span class="line">webpack常用的loader</span><br><span class="line">​</span><br><span class="line">样式：style-loader、css-loader、less-loader、sass-loader等</span><br><span class="line">文件：raw-loader、file-loader 、url-loader等</span><br><span class="line">编译：babel-loader、coffee-loader 、ts-loader等</span><br><span class="line">校验测试：mocha-loader、jshint-loader 、eslint-loader等</span><br><span class="line">​</span><br><span class="line">目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。</span><br><span class="line">​</span><br><span class="line">webpack功能强大，难点在于它的配置文件，webpack4默认不需要配置文件，可以通过mode选项为webpack指定了一些默认的配置，mode分为：development/production，默认是production。</span><br><span class="line">​</span><br><span class="line">插件可以携带参数，所以在plugins属性传入new实例。</span><br><span class="line">​</span><br><span class="line">webpack常用的plugin</span><br><span class="line">webpack内置UglifyJsPlugin，压缩和混淆代码。</span><br><span class="line">webpack内置CommonsChunkPlugin，提高打包效率，将第三方库和业务代码分开打包。</span><br><span class="line">ProvidePlugin：自动加载模块，代替require和import</span><br><span class="line">​</span><br><span class="line">html-webpack-plugin可以根据模板自动生成html代码，并自动引用css和js文件extract-text-webpack-plugin 将js文件中引用的样式单独抽离成css文件</span><br><span class="line">​</span><br><span class="line">DefinePlugin 编译时配置全局变量，这对开发模式和发布模式的构建允许不同的行为非常有用。</span><br><span class="line">​</span><br><span class="line">【Mode】可以在config文件里面配置，也可以在CLI参数中配置：webpack--mode=production（一般会选择在CLI，也就是npm scripts里面进行配置）。</span><br><span class="line">​</span><br><span class="line">在webpack4以下版本，webpack3.XX，通过plugins进行环境变量的配置。</span><br><span class="line">​</span><br><span class="line">【resolve】模块，resolver是个库，帮助webpack找到bundle需要引入的模块代码，打包时，webpack使用enhanced-resolve来解析路径。</span><br><span class="line">​</span><br><span class="line">2.webpack优化</span><br><span class="line">多进程打包   安装插件thread-loader   parallel-webpack   HappyPack</span><br><span class="line">​</span><br><span class="line">多进程压缩   parallel-uglify-plugin    terser-webpack-plugin</span><br><span class="line">资源CDN    公用代码提取，使用 CDN 加载</span><br><span class="line">动态polyfill     动态 polyfill 指的是根据不同的浏览器，动态载入需要的 polyfill</span><br></pre></td></tr></table></figure>

# 跨域出现的原因/解决方法

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">原因：由于浏览器的同源策略，即属于不同域的⻚面之间不能相互访问各自的⻚面内容。</span><br><span class="line">​</span><br><span class="line">哪些情况下产生跨域</span><br><span class="line">1、域名不同</span><br><span class="line">2、端口号不同</span><br><span class="line">3、协议不同(http/https)</span><br><span class="line">4、域名和域名对应ip</span><br><span class="line">5、主域名相同(127.0.01 和 localhost) 多域名匹配一个ip地址</span><br><span class="line">6、子域名不同（一级和二级域名）</span><br><span class="line">​</span><br><span class="line">解决方法</span><br><span class="line">​</span><br><span class="line">1、后端代理</span><br><span class="line">后端不存在跨域（后端代码脱离浏览器，后端是服务器端）</span><br><span class="line">利用后端(自己公司的后端)去获取接口数据，将数据传给前端</span><br><span class="line">2、jsonp</span><br><span class="line">原理:</span><br><span class="line">    利用浏览器的&quot;漏洞&quot; src不受同源策略的影响，可以请求任何链接 。动态创建script标签，将事先写好的函数名传给服务器，供服务器使用</span><br><span class="line">（1）script标签src属性不存在跨域</span><br><span class="line">（2）get方式--传递函数名 --弊端</span><br><span class="line">（3）callback回调函数(传递函数名)</span><br><span class="line">3、反向代理  </span><br><span class="line">proxy  webpack配置</span><br><span class="line">&quot;proxy&quot;: &#123;</span><br><span class="line">    &quot;/index.php&quot;: &#123;</span><br><span class="line">      &quot;target&quot;: &quot;http://qinqin.net&quot;,</span><br><span class="line">      &quot;changeOrigin&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">4、CORS解决跨域(xhr2)(后端)</span><br><span class="line">CORS是一个W3C标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）。它允许浏览器向跨源(协议 + 域名 + 端口)服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</span><br><span class="line">需要服务器(提供接口的源码里面)添加下面两句话。</span><br><span class="line">header(&#x27;Access-Control-Allow-Origin:*&#x27;);</span><br><span class="line">header(&#x27;Access-Control-Allow-Method:POST,GET&#x27;);</span><br><span class="line">​</span><br><span class="line">jsonp是一种非正式传输协议，用于解决跨域问题流程：</span><br><span class="line">1、创建一个全局函数</span><br><span class="line">2、创建一个script标签</span><br><span class="line">3、给script添加src</span><br><span class="line">4、给src添加回调函数test(callback=test) callback是传给后端的一个参数</span><br><span class="line">5、将script放到⻚面上</span><br><span class="line">6、script请求完成，将自己从⻚面上删除</span><br></pre></td></tr></table></figure>

# Node

1.Node 不是一个后端语言，但是它可以做类似后端语言的功能

2.Node 是使用谷歌 V8 引擎

3.Node 是 js 的一个运行环境

4.Node 具有非阻塞 I/O 特点

5.Node 采用了 Common.js 规范

node+koa2   node+express

用于快速构建 Node.js 项目

node.js 是一个基于 Chrome V8 引擎的 JavaScirpt 运行环境。

Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型,使其轻量又高效\*\*

Node.js 基于 commonjs 规范

事件驱动： 任务执行，发布者，订阅者，事件驱动 .

异步（非阻塞）： 执行某一个任务的同时也可以执行其他任务

同步（阻塞）： 执行某一个任务，这个任务如果没有执行完成，其他任务必须等待

I/O: 输入/输出（ 数据库操作，文件系统操作等   ） - 服务器的环境

非阻塞 I/O 模型： 当使用 Node.js 来实现数据库操作、文件系统等操作时，要进行的异步操作，异步操作的核心传统实现方式就是回调函数和事件。

Node.js 的包管理工具 npm

优点：Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，异步编程，使其轻量又高效。

缺点：单进程，单线程，只支持单核 cpu，不能充分的利用多核 cpu 服务器。一旦这个进程崩掉，那么整个 web 服务就崩掉了。

内置模块 http 是用于创建一个能够处理和响应 http 响应的服务

fs 用于对系统文件及目录进行读写操作。

path 提供了一些用于处理文件路径的小工具

Url：帮助我们对提交上来的 url 进行解析处理

querystring  提供用于解析和格式化 URL 查询字符串的工具。qs.parse()   qs.stringify()



# 开发登录部分功能时，前后端应该如何协作，考虑哪些方面，如何设计

1. 如果前端页面主要做内容展示，需要后端处理的内容比较多，而前端逻辑简单时，建议采用后端 MVC。如博客、新闻类的网站；

2. 如果前端页面的交互和数据处理较多，可以将逻辑放在前端，而后端只负责数据存取。比如各类管理后台。

# JS

# JavaScript 数据类型

基本类型 7 个

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">number:数字</span><br><span class="line">string:字符串</span><br><span class="line">boolean:布尔值</span><br><span class="line">null:空对象</span><br><span class="line">undefined:未定义/未初始化</span><br><span class="line">symbol(森bou):独一无二的值，ES6 新增</span><br><span class="line">BigInt:大整数，能够表示超过 Number 类型大小限制的整数，ES11新增</span><br></pre></td></tr></table></figure>

复杂类型(引用)

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object:对象。Array/数组 和 function/函数 也属于对象的一种</span><br></pre></td></tr></table></figure>

区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基本类型是存放在栈里的，基本类型的比较是它们的值的比较</span><br><span class="line">引用类型将地址存在栈内，将内容储存在堆内，引用类型比较是地址</span><br></pre></td></tr></table></figure>

## null 和 undefined 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</span><br><span class="line">undefined 代表的含义是未定义，</span><br><span class="line">null 代表的含义是空对象（其实不是真的对象，请看下面的注意！）。一般变量声明了但还没有定义的时候会返回 undefined，null</span><br><span class="line">主要用于赋值给一些可能会返回对象的变量，作为初始化。</span><br><span class="line">当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等 号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</span><br></pre></td></tr></table></figure>

## 检测数据类型

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line">ES6检测数组 Array.isArray([])</span><br><span class="line">1.typeof：可以检测基本类型，但是引用类型都返回Object</span><br><span class="line">2.instanceof：可以检测引用类型，但不能检测基本类型</span><br><span class="line">3.Object.prototype.toString.call()可以检测所有类型</span><br><span class="line">检测方法4种</span><br><span class="line"> 1、typeOf</span><br><span class="line">    作用: 用于检测基本数据类型和函数</span><br><span class="line">    弊端: 引用数据类型(Arrary/function/object)只会返回Object, 不起作用</span><br><span class="line">    语法: typeOf &quot; &quot;/[ ]/xx</span><br><span class="line">    返回值: &quot;string&quot;/&quot;boolean&quot;/&quot;object&quot; (无法区分)</span><br><span class="line"> 2、instanceOf</span><br><span class="line">    原理: 判断对象类型，基于原型链去判断(obj instanceof Object)</span><br><span class="line">    左边对象的原型链proto上是否有右边构造函数的proptotype属性</span><br><span class="line">    作用: 判断左边的对象是否是右边构造函数的实例</span><br><span class="line">    弊端: 用于引用类型的检测, 对于基本数据类型不生效</span><br><span class="line">    语法: &quot; &quot;/[ ]/true instanceOf String/Array/Boolean</span><br><span class="line">    返回值: true/false</span><br><span class="line"> 3、Object.prototype.toString.call()</span><br><span class="line">    作用: 可以检测所有数据类型</span><br><span class="line">    所有数据类型都可以检测,而且非常正确</span><br><span class="line">    语法: Object.prototype.toString.call( &#x27;xxx&#x27;/11/[ ] )</span><br><span class="line">    返回值: [object Xxx], Xxx 就是对象的类型</span><br><span class="line"> 4、constructor</span><br><span class="line">    作用: 可以检测基本数据类型和引用数据类型</span><br><span class="line">    弊端: 把类的原型进行重写, 很有可能把之前的constructor覆盖 检测出来的结果就会不准确</span><br><span class="line">    语法: (&quot;xx&quot;)/([])/(function()&#123;&#125;).constructor === String/Array/Function</span><br><span class="line">    返回值: true/false</span><br><span class="line">instanceof的原理</span><br><span class="line">Plain Text</span><br><span class="line">instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</span><br><span class="line">实现 instanceof：首先获取类型的原型然后获得对象的原型</span><br><span class="line">然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 nullfunction myInstanceof(left, right) &#123;</span><br><span class="line">  let prototype = right.prototype</span><br><span class="line">  left = left.__proto__</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (left === null || left === undefined)</span><br><span class="line">      return false</span><br><span class="line">    if (prototype === left)</span><br><span class="line">      return true</span><br><span class="line">    left = left.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">js的数据类型的转换</span><br><span class="line">Plain Text</span><br><span class="line">在 JS 中类型转换只有三种情况，分别是：</span><br><span class="line">转换为布尔值（调用Boolean()方法）</span><br><span class="line">转换为数字（调用Number()、parseInt()和parseFloat()方法）</span><br><span class="line">转换为字符串（调用.toString()或者String()方法）</span><br><span class="line">js的变量申明方式Plain Text</span><br><span class="line">var</span><br><span class="line">let</span><br><span class="line">const</span><br><span class="line">function</span><br><span class="line">import</span><br><span class="line">class</span><br><span class="line">去除字符串的头尾空格:</span><br><span class="line">Plain Text</span><br><span class="line">trim()</span><br><span class="line">数组转字符串</span><br><span class="line">Plain Text</span><br><span class="line">join()	将数组元素连接起来以构建一个字符串</span><br><span class="line">toString()	将数组转换成一个字符串</span><br><span class="line">toLocalString()	把数组转换成本地约定的字符串</span><br><span class="line">​</span><br><span class="line">常见的http请求</span><br><span class="line">Plain Text</span><br><span class="line">GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT</span><br><span class="line">1、GET方法</span><br><span class="line">  用于使用给定的URI从给定服务器中检索信息，即从指定资源中请求数据。使用GET方法的请求应该只是检索数据，并且不应对数据产生其他影响。</span><br><span class="line">  在GET请求的URL中发送查询字符串(名称/值对)，需要这样写：/test/demo_form.php?name1=value1&amp;name2=value2</span><br><span class="line">  GET请求是可以缓存的，我们可以从浏览器历史记录中查找到GET请求，还可以把它收藏到书签中;且GET请求有长度限制，仅用于请求数据(不修改)。</span><br><span class="line">  因GET请求的不安全性，在处理敏感数据时，不可以使用GET请求。2、HEAD方法</span><br><span class="line">  与GET方法相同，但没有响应体，仅传输状态行和标题部分。这对于恢复相应头部编写的元数据非常有用，而无需传输整个内容。</span><br><span class="line"></span><br><span class="line">3、POST方法</span><br><span class="line">  用于将数据发送到服务器以创建或更新资源，它要求服务器确认请求中包含的内容作为由URI区分的Web资源的另一个下属。</span><br><span class="line">  POST请求永远不会被缓存，且对数据长度没有限制;我们无法从浏览器历史记录中查找到POST请求。4、PUT方法</span><br><span class="line">  用于将数据发送到服务器以创建或更新资源，它可以用上传的内容替换目标资源中的所有当前内容。</span><br><span class="line">  它会将包含的元素放在所提供的URI下，如果URI指示的是当前资源，则会被改变。如果URI未指示当前资源，则服务器可以使用该URI创建资源。5、DELETE方法</span><br><span class="line">用来删除指定的资源，它会删除URI给出的目标资源的所有当前内容。6、CONNECT方法</span><br><span class="line">  用来建立到给定URI标识的服务器的隧道;它通过简单的TCP/IP隧道更改请求连接，通常实使用解码的HTTP代理来进行SSL编码的通信(HTTPS)。7、OPTIONS方法</span><br><span class="line">  用来描述了目标资源的通信选项，会返回服务器支持预定义URL的HTTP策略。8、TRACE方法</span><br><span class="line">  用于沿着目标资源的路径执行消息环回测试;它回应收到的请求，以便客户可以看到中间服务器进行了哪些(假设任何)进度或增量。</span><br><span class="line"></span><br><span class="line">异步</span><br><span class="line">同步异步区别</span><br><span class="line">Plain Text</span><br><span class="line">在js中，所有任务都分为同步任务和异步任务两大类。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</span><br><span class="line">（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</span><br><span class="line">（2）主线程之外，还存在一个&quot;任务队9列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</span><br><span class="line">（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</span><br><span class="line">（4）主线程不断重复上面的第三步。有时候 setTimeout明明写的延时3秒，实际却5，6秒才执行函数，这又是因为什么？答：setTimeout 并不能保证执行的时间，是否及时执行取决于 JavaScript 线程是拥挤还是空闲。</span><br><span class="line">浏览器的JS引擎遇到setTimeout，拿走之后不会立即放入异步队列，同步任务执行之后，timer模块会到设置时间之后放到异步队列中。js引擎发现同步队列中没有要执行的东西了，即运行栈空了就从异步队列中读取，然后放到运行栈中执行。所以setTimeout可能会多了等待线程的时间。</span><br><span class="line">这时setTimeout函数体就变成了运行栈中的执行任务，运行栈空了，再监听异步队列中有没有要执行的任务，如果有就继续执行，如此循环，就叫Event Loop。</span><br><span class="line">js异步操作</span><br><span class="line">Plain Text</span><br><span class="line">1、定时器都是异步操作</span><br><span class="line">2、事件绑定都是异步操作</span><br><span class="line">3、AJAX中一般我们都采取异步操作（也可以同步）</span><br><span class="line">4、回调函数可以理解为异步（不是严谨的异步操作）</span><br><span class="line">5、promise</span><br><span class="line">6、generator（ES6）</span><br><span class="line">   通过yield关键字可以让任务在需要的地方暂停,每一步的值可以通过next获取</span><br><span class="line">7、async/await(ES7)</span><br><span class="line">   await得到的就是async异步返回值,底层原理还是promise中的resolve方法</span><br><span class="line">8、设计模式-发布订阅模式</span><br><span class="line">9、事件监听</span><br><span class="line">promise对象</span><br><span class="line">Plain Text</span><br><span class="line">ES6新增的一种异步解决方案，解决了之前异步回调地狱的问题</span><br><span class="line">Promise有三种状态，pending进行中，resolved成功，rejected失败</span><br><span class="line">特点是：状态不受外界改变，并且状态一旦改变，不可更改。不能暂停</span><br><span class="line">promise是同步，但他的.then() 方法是异步。</span><br><span class="line">可以使用链式调用方法</span><br><span class="line">当成功时可以使用.then()          第二个参数，失败的回调</span><br><span class="line">失败时可以使用.catch()</span><br><span class="line">不管状态如何都执行的操作.finally()Promise.race():只要有一个promise执行完毕后就会执行.then操作</span><br><span class="line">promise.all()：将多个promise实例包装成一个新的实例，参数为数组，只有当数组里的所有状态都是resolved新的状态才是resolved，返回值在全部成功时是一个结果数组，数组顺序和接收的顺序一致，失败时是第一个失败状态的值；</span><br><span class="line">promise.all和promise.race</span><br><span class="line">Plain Text</span><br><span class="line">Pomise.all的使用</span><br><span class="line">    Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。</span><br><span class="line">    Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，在前端开发请求数据的过程中，偶尔会遇到发送多个请求并根据请求顺序获取和使用数据的场景，使用Promise.all毫无疑问可以解决这个问题。Promise.race的使用</span><br><span class="line">    Promise.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。</span><br><span class="line">promise.all封装思路</span><br><span class="line">Plain Text</span><br><span class="line">参数是数组，数组每一项是promises对象</span><br><span class="line">返回promise对象</span><br><span class="line">定义数字0，</span><br><span class="line">对数组进行循环，如果成功，每次循环数字++，如果数字和数组长度相等，则返回resolve()</span><br><span class="line">如果失败直接直接返回reject</span><br><span class="line">promise，async区别</span><br><span class="line">Plain Text</span><br><span class="line">async / await与 Promise的主要区别是：</span><br><span class="line">Promise代码完全都是Promise的API（then、catch等等），操作本身的语义反而不容易看出来,</span><br><span class="line">async / await函数的实现最简洁，最符合语义，几乎没有语义不相关的代码</span><br><span class="line">async / await 函数就是 Generator 函数的语法糖 async/await函数的优势</span><br><span class="line">1. 使用async函数可以让代码简洁很多，不需要像Promise一样需要些then，不需要写匿名函数处理Promise的resolve值，也不需要定义多余的data变量，还避免了嵌套代码</span><br><span class="line">2. 使用aync/await的话，catch能处理JSON.parse错误 promise中不能处理</span><br><span class="line">3. 条件语句也和错误捕获是一样的，在 Async 中也可以像平时一般使用条件语句  async、await</span><br><span class="line">Plain Text</span><br><span class="line">  async异步是用来装饰函数的，一个函数如果加上 async ，那么该函数就会返回一个 Promise对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句</span><br><span class="line">  await关键字只能在async函数中使用。可以用来等待Promise状态变成resolved并有返回值。await后面通常跟的是一个promise对象，如果不是，会立即被包装成resoled状态的promise。</span><br><span class="line">  如果await后面的 promise 正常resolve，await promise便会返回结果。但是在reject的情况下，便会抛出异常，并且这种异常需要用try/catch来捕获，整个async函数都会中断执行。  可以把async看成将函数返回值使用 Promise.resolve() 包裹了下</span><br><span class="line"></span><br><span class="line">await本身返回的也是一个Promise,它只是把await后面的代码放到了await返回的Promise的.then后面，以此来实现的。</span><br><span class="line">await只是让当前async函数内部、后面的代码等待，并不是所有代码都卡在这里。遇到await就先返回，执行async函数之后的代码。</span><br><span class="line">async/await优势</span><br><span class="line">Plain Text</span><br><span class="line">1.简洁，不用匿名函数，不需要多余data避免嵌套</span><br><span class="line">2.catch能处理JSON.parse错误</span><br><span class="line">3.可以使用条件语句</span><br><span class="line">Generate</span><br><span class="line">Plain Text</span><br><span class="line">Generator 的中文名称是生成器，它是ES6中提供的新特性。</span><br><span class="line">在过去，函数只存在“没有被调用”或者“被调用”的情况，</span><br><span class="line">不存在一个函数被执行之后还能暂停的情况，而Generator的出现让这种情况成为可能。通过 function* 来定义的函数称之为“生成器函数”（generator function），它的特点是可以中断函数的执行，</span><br><span class="line">每次执行yield语句之后，函数即暂停执行，直到调用返回的生成器对象的next()函数它才会继续执行。也就是说 Generator 函数是一个状态机，封装了多个内部状态。</span><br><span class="line">执行 Generator 函数返回一个遍历器对象（一个指向内部状态的指针对象），</span><br><span class="line">调用遍历器对象的next方法，使得指针移向下一个状态。每次调用next方法，</span><br><span class="line">内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。yield关键字</span><br><span class="line">真正让Generator具有价值的是yield关键字，这个yield关键字让 Generator内部的逻辑能够切割成多个部分。</span><br><span class="line">发现函数执行到第一个yield关键字的时候就停止了。要让业务逻辑继续执行完，需要反复调用.next()</span><br><span class="line">可以简单地理解为yield关键字将程序逻辑划分成几部分，每次.next()执行时执行一部分。</span><br><span class="line">这使得程序的执行单元再也不是函数，复杂的逻辑可以通过yield来暂停。.next()调用时，返回一个对象，这个对象具备两个属性。</span><br><span class="line">其中一个属性是布尔型的done。它表示这个Generator对象的逻辑块是否执行完成。</span><br><span class="line">另一个属性是value，它来自于yield语句后的表达式的结果。通过.next()传递参数，可以赋值给yield关键字前面的变量声明。</span><br><span class="line">defer，async</span><br><span class="line">Plain Text</span><br><span class="line">原本浏览器解析文档遇到script标签会停下解析下载脚本并执行，一切结束后再解析文档</span><br><span class="line">defer：遇到不停下解析，其他线程下载脚本，脚本完成下载等解析完成后执行脚本</span><br><span class="line">async：遇到不停下解析，其他线程下载脚本，脚本下载完立即执行脚本后解析文档</span><br><span class="line">ES5</span><br><span class="line">Plain Text</span><br><span class="line">1. strict模式</span><br><span class="line">严格模式，限制一些用法，&#x27;use strict&#x27;;2. Array增加方法</span><br><span class="line">forEach，ES5具有遍历数组功能的还有map、filter、some、every、reduce、reduceRight等</span><br><span class="line">增加了indexOf、lastIndexOf、isArray、map、reduce、reduceRight方法</span><br><span class="line">PS：还有其他方法 Function.prototype.bind、String.prototype.trim、Date.now//返回自1970年1月1日0时到现在的毫秒数3. Object方法</span><br><span class="line">Object.getPrototypeOf</span><br><span class="line">Object.create</span><br><span class="line">Object.getOwnPropertyNames</span><br><span class="line">Object.defineProperty</span><br><span class="line">Object.getOwnPropertyDescriptor</span><br><span class="line">Object.defineProperties</span><br><span class="line">Object.keys</span><br><span class="line">Object.preventExtensions / Object.isExtensible</span><br><span class="line">Object.seal / Object.isSealed</span><br><span class="line">Object.freeze / Object.isFrozen</span><br><span class="line">ES6</span><br><span class="line">Plain Text</span><br><span class="line">let const     都有块级作用域，不具备变量提升，不能重复申明</span><br><span class="line">箭头函数 =&gt;；   语法简洁</span><br><span class="line">模板字符串      可读性强，使用$&#123;&#125;定义变量</span><br><span class="line">展开运算符      把数组或对象展开成,比如浅拷贝，数组扁平化</span><br><span class="line">解构赋值        数组或者对象进行模式匹配，对其中的变量进行赋值，语法简洁</span><br><span class="line">Promise        一种异步函数处理模式，语法简洁</span><br><span class="line">import模块化    封闭作用域，项目规范</span><br><span class="line">for-of遍历、for-in遍历；     for-in更适合遍历对象 for of遍历数组（可以遍历对象中可枚举的属性）</span><br><span class="line">函数默认参数     可以设定初始值</span><br><span class="line">Set            似于数组，特性是所有元素都是唯一的，没有重复。</span><br><span class="line">Symbol         表示独一无二的值，最大的用法是用来定义对象的唯一属性名</span><br><span class="line">代理（proxy）新增数组方法</span><br><span class="line">1.Array.from()  方法用于将对象转为真正的数组(类数组转数组)</span><br><span class="line">2.Array.of()    方法用于将一组值，转换为数组。</span><br><span class="line">   console.log(Array.of(1,2,3,4,4,50));//[1, 2, 3, 4, 4, 50]</span><br><span class="line">3.Object.assign  (目标对象,对象1,对象2)用于对象的合并,将源对象的所有可枚举属性，复制到目标对象。(浅拷贝)Generators生成器函数</span><br><span class="line">  	总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。</span><br><span class="line"></span><br><span class="line">Set结构和Map结构</span><br><span class="line">1.Set:它类似于数组，但是成员的值都是唯一的，没有重复的值。</span><br><span class="line">Set本身是一个构造函数，用来生成 Set 数据结构，数组作为参数。</span><br><span class="line">        //数组去重</span><br><span class="line">        // let arr=[1,2,3,4,5,6,6,5,4,3,2,1];</span><br><span class="line">        // console.log([...new Set(arr)]);//[1, 2, 3, 4, 5, 6]</span><br><span class="line"></span><br><span class="line">2.Map数据结构。它类似于对象，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</span><br><span class="line">var和let在for循环的一些不同表现</span><br><span class="line">Plain Text</span><br><span class="line">在var中执行的时候：</span><br><span class="line">    因为var是没有块级作用域的，所以在for循环中声明的i会存在于函数作用域中。每一次for循环就会声明一次i，但后面声明的变量会覆盖前面声明的变量。</span><br><span class="line">在let中执行的时候：</span><br><span class="line">    因为块级作用域的原因，let声明的i都会存在于for块级作用域中，每一次for循环都会生成一个块级作用域。</span><br><span class="line">let, const, var的区别</span><br><span class="line">Plain Text</span><br><span class="line">var的作用域是全局的，会有变量提升，可以前置访问</span><br><span class="line">let用于申明变量，const用于申明常量（如果是一个对象，只改变里面的一个属性，最好也用const），它们都有块级作用域，不具备变量提升（会有暂时性死区），不能重复申明</span><br><span class="line">同一作用域下let和const不能声明同名变量，而var可以</span><br><span class="line">const</span><br><span class="line">一旦声明必须赋值,不能使用null占位。</span><br><span class="line">声明后不能再修改</span><br><span class="line">如果声明的是引用类型数据，可以修改其属性</span><br><span class="line">箭头函数 =&gt;</span><br><span class="line">Plain Text</span><br><span class="line">箭头函数表达式的语法比函数表达式更简洁</span><br><span class="line">箭头函数没有自己的this值,指向的是它外层的不是箭头函数的函数，如果没有则指向widnow，不能被改变</span><br><span class="line">适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</span><br><span class="line">是</span><br><span class="line">箭头函数和普通函数的区别</span><br><span class="line">Plain Text</span><br><span class="line">语法简洁，this指向明确</span><br><span class="line">普通函数参数可以使用arguments拿到参数</span><br><span class="line">箭头函数可以使用rest参数：形式为...变量名</span><br><span class="line">构造函数</span><br><span class="line">Plain Text</span><br><span class="line">(1) 当以 new 关键字调用时，会创建一个新的内存空间，标记为 Animal 的实例。</span><br><span class="line">(2)函数体内部的 this 指向该内存</span><br><span class="line">  每当创建一个实例的时候，就会创建一个新的内存空间(#f2, #f3)，创建 #f2 的时候，函数体内部的 this 指向 #f2, 创建 #f3 的时候，函数体内部的 this 指向 #f3。</span><br><span class="line">(3) 执行函数体内的代码</span><br><span class="line">通过上面的讲解，你就可以知道，给 this 添加属性，就相当于给实例添加属性。</span><br><span class="line">(4) 默认返回 this</span><br><span class="line">rest</span><br><span class="line">Plain Text</span><br><span class="line">rest参数和arguments的区别在于，arguments是类数组对象，不能使用数组API。</span><br><span class="line">而rest 参数是一个真正的数组，数组特有的方法都可以使用。</span><br><span class="line">Set</span><br><span class="line">Plain Text</span><br><span class="line">ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值，所以Set方法一般用来数组去重</span><br><span class="line">    let arr = [2, 3, 3, 4, 6, 5, 3, 4, 4];</span><br><span class="line">    let arr2 = [...new Set(arr)];</span><br><span class="line">这里new Set出来的不是真正的数组，所以需要用到...扩展运算符</span><br><span class="line">Set及应用场景</span><br><span class="line">一、创建Set对象实例</span><br><span class="line">Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用</span><br><span class="line">1.构造函数           (伊特波)</span><br><span class="line">    语法：new Set([iterable])</span><br><span class="line">    参数：iterable 如果传递一个56</span><br><span class="line">    弊端: 引用数据类型(Arrary/function/object)只会返回Object, 不起作用</span><br><span class="line">    语法: typeOf &quot; &quot;/[ ]/xx</span><br><span class="line">    返回值: &quot;string&quot;/&quot;boolean&quot;/&quot;object&quot; (无法区分)</span><br><span class="line"> 2、instanceOf</span><br><span class="line">    原理: 判断对象类型，基于原型链去判断(obj instanceof Object)</span><br><span class="line">    左边对象的原型链proto上是否有右边构造函数的proptotype属性</span><br><span class="line">    作用: 判断左边的对象是否是右边构造函数的实例</span><br><span class="line">    弊端: 用于引用类型的检测, 对于基本数据类型不生效</span><br><span class="line">    语法: &quot; &quot;/[ ]/true instanceOf String/Array/Boolean</span><br><span class="line">    返回值: true/false</span><br><span class="line"> 3、Object.prototype.toString.call()</span><br><span class="line">    作用: 可以检测所有数据类型</span><br><span class="line">    所有数据类型都可以检测,而且非常正确</span><br><span class="line">    语法: Object.prototype.toString.call( &#x27;xxx&#x27;/11/[ ] )</span><br><span class="line">    返回值: [object Xxx], Xxx 就是对象的类型</span><br><span class="line"> 4、constructor</span><br><span class="line">    作用: 可以检测基本数据类型和引用数据类型</span><br><span class="line">    弊端: 把类的原型进行重写, 很有可能把之前的constructor覆盖 检测出来的结果就会不准确</span><br><span class="line">    语法: (&quot;xx&quot;)/([])/(function()&#123;&#125;).constructor === String/Array/Function</span><br><span class="line">    返回值: true/false</span><br></pre></td></tr></table></figure>

## instanceof 的原理

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</span><br><span class="line">实现 instanceof：</span><br><span class="line">首先获取类型的原型</span><br><span class="line">然后获得对象的原型</span><br><span class="line">然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null</span><br><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line">  let prototype = right.prototype</span><br><span class="line">  left = left.__proto__</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (left === null || left === undefined)</span><br><span class="line">      return false</span><br><span class="line">    if (prototype === left)</span><br><span class="line">      return true</span><br><span class="line">    left = left.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## js 的数据类型的转换

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在 JS 中类型转换只有三种情况，分别是：</span><br><span class="line">转换为布尔值（调用Boolean()方法）</span><br><span class="line">转换为数字（调用Number()、parseInt()和parseFloat()方法）</span><br><span class="line">转换为字符串（调用.toString()或者String()方法）</span><br></pre></td></tr></table></figure>

js 的变量申明方式

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var</span><br><span class="line">let</span><br><span class="line">const</span><br><span class="line">function</span><br><span class="line">import</span><br><span class="line">class</span><br></pre></td></tr></table></figure>

## **去除字符串的头尾空格:**

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trim()</span><br></pre></td></tr></table></figure>

## 数组转字符串

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">join()	将数组元素连接起来以构建一个字符串</span><br><span class="line">toString()	将数组转换成一个字符串</span><br><span class="line">toLocalString()	把数组转换成本地约定的字符串</span><br></pre></td></tr></table></figure>

# 闭包

闭包本质是函数嵌套小函数，外层函数的值会传到内部函数当中，外层函数返回内层函数，内层函数就是闭包

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function A() &#123;</span><br><span class="line">  let a = 1</span><br><span class="line">  function B() &#123;</span><br><span class="line">      console.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  return B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## 特性：

1.封闭性——外界无法在闭包没有提供接口的情况下访问闭包内部的数据；

2.持久性——在函数调用结束后，不会像普通函数一样自动注销函数，闭包内的数据会一直在

优点：

1.减少全局变量；隔离作用域，会照成变量空间无法释放，模块化

2.减少传递 函数的数据量；

3.高度封装

缺点：

闭包会常驻内存，增大内存使用量，使用不当很容易造成内存泄露

当不需要使用闭包时手动释放，设置变量赋值为 null

## 使用场景

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、通过循环给页面上多个dom节点绑定事件</span><br><span class="line">2、封装私有变量(计数器)</span><br><span class="line">3、延续局部变量的寿命</span><br><span class="line">4、高阶组件</span><br><span class="line">5、函数防抖</span><br><span class="line">模块化的就是以闭包为基础构建的;</span><br></pre></td></tr></table></figure>

## 防抖和节流

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">防抖：（按钮提交场景，防止多次点击，只执行最后一次，搜索框的联想场景）</span><br><span class="line">在事件触发时，开始计时，在规定的时间（delay）内，若再次触发事件，将上一次计时（timer）清空，然后重新开始计时。保证只有在规定时间内没有再次触发事件之后，再去执行这个事件.</span><br><span class="line">节流：（浏览器窗口，拖拽场景，固定时间只执行一次、缩放场景，监控浏览器resize）</span><br><span class="line">指定时间间隔内，若事件被多次触发，只会执行一次</span><br><span class="line">使用时间戳实现</span><br><span class="line">在事件触发之后，开始计时，在规定的时间（delay）内，若再次触发事件，不对此事件做任何处理。保证在规定时间内只执行一次</span><br></pre></td></tr></table></figure>

防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。
防抖

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">函数防抖</span><br><span class="line">* fn [function] 需要防抖的函数</span><br><span class="line">* delay [number] 毫秒，防抖期限值</span><br><span class="line">function debounce(fn,delay)&#123;</span><br><span class="line">    let timer = null</span><br><span class="line">    //借助闭包</span><br><span class="line">    return function() &#123;</span><br><span class="line">        if(timer)&#123;</span><br><span class="line">            clearTimeout(timer) //进入该分支语句，说明当前正在一个计时过程中，并且又触发了相同事件。所以要取消当前的计时，重新开始计时</span><br><span class="line">            timer = setTimeOut(fn,delay) </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            timer = setTimeOut(fn,delay) // 进入该分支说明当前并没有在计时，那么就开始一个计时</span><br><span class="line">        &#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

# this

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.普通函数的this指向调用这个函数的对象，默认是window</span><br><span class="line">2.构造函数的this指向new出来的实例对象，不能被改变</span><br><span class="line">3.箭头函数的this指向的是它外面的第一个不是箭头函数的函数的 this，不能被改变</span><br><span class="line">4.事件处理函数的this指向事件对象</span><br><span class="line">5.严格模式指向undefined</span><br><span class="line">6.定时器也指向window</span><br><span class="line">  -解决方法：在外部函数中将this存为一个变量，回调函数中使用该变量，而不是直接使用this。</span><br></pre></td></tr></table></figure>

## call, apply, bind 区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apply、call、bind三者都是用来改变函数的this对象的指向的；</span><br><span class="line">第一个参数都是this要指向的对象，也就是想指定的上下文；从第二个参数开始，就是函数的本身的参数；</span><br><span class="line">apply()的参数是数组形式，call是直接传递</span><br><span class="line">bind 返回是函数，和call一样，便于稍后调用；可以通过 bind 实现柯里化。</span><br><span class="line">apply、call 则是立即调用 。</span><br><span class="line">*如果在三个函数里面的第一个参数是Null的话，bind函数不会改变this指向，另两个会指向window</span><br></pre></td></tr></table></figure>

# 浏览器

## 浏览器输入 url 地址然后发生了什么(请求 HTTP 过程)

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">1.对网址进行DNS域名解析，得到对应的IP地址</span><br><span class="line">2.根据这个IP，找到对应的服务器，发起TCP的三次握手</span><br><span class="line">3.建立TCP连接后发起HTTP请求</span><br><span class="line">4.服务器响应HTTP请求，浏览器得到html代码，服务器关闭TCP连接(四次挥手)</span><br><span class="line">5.浏览器解析html代码，并请求html代码中的资源（如js、css图片等）（先得到html代码，才能去找这些资源）</span><br><span class="line">6.浏览器对页面进行渲染呈现给用户</span><br><span class="line">详细解答</span><br><span class="line">1.浏览器（客户端）进行地址解析，补全域名，然后DNS域名解析；</span><br><span class="line">    浏览器会对一些默认的东西进行补齐。例如：互联网url默认端口号为80，浏览器默认补齐功能会补齐协议http</span><br><span class="line">dns解析分为以下几个步骤：</span><br><span class="line">1、先查看浏览器dns中是否有域名对应的ip。</span><br><span class="line">2、如果没有，则查看操作系统dns缓存中是否有对应的ip（例如windows的hosts文件）。</span><br><span class="line">3、依旧没有就对本地区的dns服务器发起请求，</span><br><span class="line">4、如果还是没有，就直接到Root Server域名服务器请求解析。</span><br><span class="line">&lt;1&gt;、DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议；</span><br><span class="line">&lt;2&gt;、全球只有十三台逻辑根服务器</span><br><span class="line">2.通过ip寻址和arp，找到目标（服务器）地址，三次握手建立TCP连接；</span><br><span class="line">    ip协议在第三层互联网层（网络层），arp协议在第四层网络访问层（链路层）。第2步获取到了ip，此时直接通过ip寻址找到ip对应的服务器，然后通过arp协议找到服务器的mac地址。</span><br><span class="line">为什么有了ip地址，还要mac地址？</span><br><span class="line">    因为一开始没有互联网的时候就只有mac地址，还不存在ip地址。后来互联网越来越大之后，发现mac地址找起来太麻烦，并且耗时也越来越久，就发明了ip地址。并且mac地址在一个局域网中还是很有用的，所以就两个一起存在了。</span><br><span class="line">第三步我们找到了目标ip，并获得了服务器ip的mac地址。此时浏览器就会请求和服务器连接，用来传输数据。tcp 是稳定双向面向连接的，断开时也会分两边分别断开。面向连接不是说tcp一个双方一直开着的通道，而是维持一个连接的状态，让它看起来有连接。</span><br><span class="line">3.发送HTTP请求；等待响应</span><br><span class="line">    浏览器会对请求进行包装，包装成请求报文。请求报文的格式如下：</span><br><span class="line">  起始行：如 GET / HTTP/1.0 （请求的方法 请求的URL 请求所使用的协议）</span><br><span class="line">  头部信息：User-Agent Host等成对出现的值</span><br><span class="line">  主体：请求头部和主体之间有一个回车换行。如果是get请求，则没有主体部分，post请求有主体部分。</span><br><span class="line">4.服务器处理请求，返回响应结果</span><br><span class="line">    浏览器请求报文到达服务器之后，服务器接口会对请求报文进行处理，执行接口对应的代码，处理完成后响应客户端。由于http是无状态的，正常情况下，客户端收到响应后就会直接断开连接，然后一次http事物就完成了。但是http1.0有一个keep-alive的请求字段，可以在一定时间内不断开连接（有时时间甚至很长）。http1.1直接就默认开启了keep-alive选项。这导致了一个后果是服务器已经处理完了请求，但是客户端不会主动断开连接，这就导致服务器资源一直被占用。这时服务器就不得不自己主动断开连接，而主动断开连接的一方会出现TIME_WAIT，占用连接池，这就是产生SYN Flood攻击的原因。</span><br><span class="line">    需要关注一个报文头--accept。accept代表发送端（客户端）希望接受的数据类型，这是浏览器自动封装的请求头。如果服务器返回的content-type是accept中的任何一个，浏览器都能解析，并直接展示在网页上。如果服务器返回的content-type是其他类型，此时浏览器有三种处理状态：</span><br><span class="line">1、正常显示。例如返回类型为text/javascript，浏览器能直接处理并展示。</span><br><span class="line">2、下载。例如返回类型为application/octet-stream（二进制流，不知道下载文件类型），这种浏览器不能直接处理的，会被下载。</span><br><span class="line">3、报错。当我们返回一个字符串hello world，却使用text/xml，格式时，浏览器不能正确解析，就会报错，并把报错信息呈现在网页中。</span><br><span class="line">浏览器能直接处理很多种格式，并直接呈现在网页中，并不限于accept中规定的字段。</span><br><span class="line">关闭TCP连接；</span><br><span class="line">客户端：“兄弟，我这边没数据要传了，咱关闭连接吧。”</span><br><span class="line">服务端：“收到，我看看我这边有木有数据了。”</span><br><span class="line">服务端：“兄弟，我这边也没数据要传你了，咱可以关闭连接了。”</span><br><span class="line">客户端：“好嘞。”</span><br><span class="line">5.浏览器解析HTML；</span><br><span class="line">浏览器通过解析HTML，生成DOM树，解析CSS，生成CSS规则树，然后通过DOM树和CSS规则树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。</span><br><span class="line">6.浏览器布局渲染</span><br><span class="line">    浏览器会根据相应的content-type字段对响应字符串进行解析。能够解析并成功解析就显示，能够解析但解析错误就报错，不能解析就下载。由于浏览器采用至上而下的方式解析，所以会先解析html，直到遇到外部样式和外部脚本。这时会阻塞浏览器的解析，外部样式和外部脚本（在没有async、defer属性下）会并行加载，但是外部样式会阻塞外部脚本的执行，dom加载完毕，js脚本执行成功后dom树构建完成（DOMContentLoaded），之后就加载dom中引用的图片等静态资源。</span><br><span class="line">html解析-&gt;外部样式、脚本加载-&gt;外部样式执行-&gt;外部脚本执行-&gt;html继续解析-&gt;dom树构建完成-&gt;加载图片-&gt;页面加载完成</span><br></pre></td></tr></table></figure>

## HTTP

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">http概述:超文本传输协议,是互联网上应用最为广泛的一种网络协议</span><br><span class="line">http的缺点</span><br><span class="line">1.通信使用明文可能会被窃听。</span><br><span class="line">2.不验证通信方的身份可能遭遇伪装。</span><br><span class="line">3.无法证明报文的完整性，可能已遭篡改。</span><br><span class="line">​</span><br><span class="line">https就是在安全的传输层上发送的http。它在将http报文发送给TCP之前，先将其发送给了一个安全层 ，对其进行加密。http安全层是通过ssl及其现代替代协议TSL来实现的。</span><br><span class="line">​</span><br><span class="line">https的优点</span><br><span class="line">（1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</span><br><span class="line">（2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</span><br><span class="line">​</span><br><span class="line">https的缺点</span><br><span class="line">但是https因为加了层ssl，所以在效率方面比较低，会使页面加载的时长延长近50%,也会增加10-20%的耗电。</span><br><span class="line">需要安装证书，在一定基础上增加部署费用，并且报文加密解密对数据传递有一点的效率影响。</span><br><span class="line">​</span><br><span class="line">http/2.0的目标是改善用户加载页面的时候更快</span><br><span class="line">HTTP/2采用二进制格式而非文本格式</span><br><span class="line">HTTP/2是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行</span><br></pre></td></tr></table></figure>

## HTTP 和 HTTPS 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP是超文本传输协议，信息是明文传输的，HTTPS是具有ssl/tls加密传输协议。</span><br><span class="line">默认端口不同，前者是80，后者是443。</span><br><span class="line">HTTPS相对于HTTP比较安全</span><br><span class="line">HTTPS协议需要到CA申请证书，需要一定费用</span><br></pre></td></tr></table></figure>

## 常见的 http 请求

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT</span><br><span class="line">1、GET方法</span><br><span class="line">  用于使用给定的URI从给定服务器中检索信息，即从指定资源中请求数据。使用GET方法的请求应该只是检索数据，并且不应对数据产生其他影响。</span><br><span class="line">  在GET请求的URL中发送查询字符串(名称/值对)，需要这样写：/test/demo_form.php?name1=value1&amp;name2=value2</span><br><span class="line">  GET请求是可以缓存的，我们可以从浏览器历史记录中查找到GET请求，还可以把它收藏到书签中;且GET请求有长度限制，仅用于请求数据(不修改)。</span><br><span class="line">  因GET请求的不安全性，在处理敏感数据时，不可以使用GET请求。</span><br><span class="line">2、HEAD方法</span><br><span class="line">  与GET方法相同，但没有响应体，仅传输状态行和标题部分。这对于恢复相应头部编写的元数据非常有用，而无需传输整个内容。</span><br><span class="line"></span><br><span class="line">3、POST方法</span><br><span class="line">  用于将数据发送到服务器以创建或更新资源，它要求服务器确认请求中包含的内容作为由URI区分的Web资源的另一个下属。</span><br><span class="line">  POST请求永远不会被缓存，且对数据长度没有限制;我们无法从浏览器历史记录中查找到POST请求。</span><br><span class="line">4、PUT方法</span><br><span class="line">  用于将数据发送到服务器以创建或更新资源，它可以用上传的内容替换目标资源中的所有当前内容。</span><br><span class="line">  它会将包含的元素放在所提供的URI下，如果URI指示的是当前资源，则会被改变。如果URI未指示当前资源，则服务器可以使用该URI创建资源。</span><br><span class="line">5、DELETE方法</span><br><span class="line">用来删除指定的资源，它会删除URI给出的目标资源的所有当前内容。</span><br><span class="line">6、CONNECT方法</span><br><span class="line">  用来建立到给定URI标识的服务器的隧道;它通过简单的TCP/IP隧道更改请求连接，通常实使用解码的HTTP代理来进行SSL编码的通信(HTTPS)。</span><br><span class="line">7、OPTIONS方法</span><br><span class="line">  用来描述了目标资源的通信选项，会返回服务器支持预定义URL的HTTP策略。</span><br><span class="line">8、TRACE方法</span><br><span class="line">  用于沿着目标资源的路径执行消息环回测试;它回应收到的请求，以便客户可以看到中间服务器进行了哪些(假设任何)进度或增量。</span><br></pre></td></tr></table></figure>

## http 对称加密非对称加密

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对称密钥加密是指加密和解密使用同一个密钥的方式,一方通过密钥将信息加密后，把密文传给另一方，另一方通过这个相同的密钥将密文解密，转换成可以理解的明文</span><br><span class="line">​</span><br><span class="line">非对称加密是加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。</span><br></pre></td></tr></table></figure>

## WebSocket 和 http 有什么区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信(full-duplex)。</span><br><span class="line">http 协议：每次 http 请求都需要创建一次 tcp 连接，通信只能由客户端发起，做不到服务器主动向客户端推送信息。</span><br><span class="line">websocket 协议：websocket 是保持长连接，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</span><br><span class="line">原理:(webSocket)</span><br><span class="line">WebSocket同HTTP一样也是应用层的协议，但是它是一种双向通信协议，是建立在TCP之上的。</span><br><span class="line">1. 浏览器、服务器建立TCP连接，三次握手。这是通信的基础，传输控制层，若失败后续都不执行。</span><br><span class="line">2. TCP连接成功后，浏览器通过HTTP协议向服务器传送WebSocket支持的版本号等信息。（开始前的HTTP握手）</span><br><span class="line">3. 服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据。</span><br><span class="line">4. 当收到了连接成功的消息后，通过TCP通道进行传输通信。</span><br><span class="line">WebSocket与HTTP的关系</span><br><span class="line">相同点:</span><br><span class="line">都是一样基于TCP的，都是可靠性传输协议。</span><br><span class="line">都是应用层协议</span><br><span class="line">不同点:</span><br><span class="line">WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息。HTTP是单向的。</span><br><span class="line">WebSocket是需要握手进行建立连接的。</span><br></pre></td></tr></table></figure>

## HTTP 状态码

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">1 消息</span><br><span class="line">100 Continue</span><br><span class="line">101 Switching Protocols</span><br><span class="line">102 Processing</span><br><span class="line">2 成功</span><br><span class="line">200 请求成功。一般用于GET与POST请求</span><br><span class="line">3 重定向</span><br><span class="line">300	多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</span><br><span class="line">301	永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</span><br><span class="line">302	临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</span><br><span class="line">303	查看其它地址。与301类似。使用GET和POST请求查看</span><br><span class="line">304	未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</span><br><span class="line">305	使用代理。所请求的资源必须通过代理访问</span><br><span class="line">306	已经被废弃的HTTP状态码</span><br><span class="line">307	临时重定向。与302类似。使用GET请求重定向</span><br><span class="line">4 请求错误</span><br><span class="line">400	客户端请求的语法错误，服务器无法理解</span><br><span class="line">401	请求要求用户的身份认证</span><br><span class="line">402	保留，将来使用</span><br><span class="line">403	服务器理解请求客户端的请求，但是拒绝执行此请求</span><br><span class="line">404	服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置&quot;您所请求的资源无法找到&quot;的个性页面</span><br><span class="line">405	客户端请求中的方法被禁止</span><br><span class="line">406	N服务器无法根据客户端请求的内容特性完成请求</span><br><span class="line">407	请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</span><br><span class="line">408	服务器等待客户端发送的请求时间过长，超时</span><br><span class="line">409	服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</span><br><span class="line">410	客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</span><br><span class="line">411	服务器无法处理客户端发送的不带Content-Length的请求信息</span><br><span class="line">412	客户端请求信息的先决条件错误</span><br><span class="line">413	由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</span><br><span class="line">414	请求的URI过长（URI通常为网址），服务器无法处理</span><br><span class="line">415	服务器无法处理请求附带的媒体格式</span><br><span class="line">416	客户端请求的范围无效</span><br><span class="line">417	服务器无法满足Expect的请求头信息</span><br><span class="line">5 服务器错误</span><br><span class="line">500	服务器内部错误，无法完成请求</span><br><span class="line">501	服务器不支持请求的功能，无法完成请求</span><br><span class="line">502 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</span><br><span class="line">503	由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</span><br><span class="line">504	充当网关或代理的服务器，未及时从远端服务器获取请求</span><br><span class="line">505	服务器不支持请求的HTTP协议的版本，无法完成处理</span><br></pre></td></tr></table></figure>

## 浏览器的强缓存和协商缓存

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">浏览器缓存是指浏览器（客户端）在本地磁盘中对访问过的资源保存的副本文件。</span><br><span class="line">浏览器缓存主要有以下几个优点：</span><br><span class="line">1. 减少重复数据请求，避免通过网络再次加载资源，节省流量。</span><br><span class="line">2. 降低服务器的压力，提升网站性能。</span><br><span class="line">3. 加快客户端加载网页的速度， 提升用户体验。</span><br><span class="line">浏览器缓存分为强缓存和协商缓存，两者有两个比较明显的区别：</span><br><span class="line">1. 如果浏览器命中强缓存，则不需要给服务器发请求；而协商缓存最终由服务器来决定是否使用缓存，即客户端与服务器之间存在一次通信。</span><br><span class="line">2. 在 chrome 中强缓存（虽然没有发出真实的 http 请求）的请求状态码返回是 200 (from cache)；</span><br><span class="line">  而协商缓存如果命中走缓存的话，请求的状态码是 304 (not modified)。</span><br><span class="line">304比200快</span><br></pre></td></tr></table></figure>

## 浏览器请求头

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">Accept(艾可塞克特)</span><br><span class="line">告诉WEB服务器自己接受什么介质类型，*/* 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。</span><br><span class="line">　　</span><br><span class="line">Accept-Charset(恰斯特)</span><br><span class="line">浏览器告诉服务器自己能接收的字符集。</span><br><span class="line"></span><br><span class="line">Accept-Encoding(因扣定)</span><br><span class="line">浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）</span><br><span class="line"></span><br><span class="line">Accept-Language</span><br><span class="line">浏览器申明自己接收的语言。语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。</span><br><span class="line">　　</span><br><span class="line">Authorization(哦瑟惹C逊)</span><br><span class="line">当客户端接收到来自WEB服务器的 WWW-Authenticate 响应时，用该头部来回应自己的身份验证信息给WEB服务器。</span><br><span class="line">　　</span><br><span class="line">If-Match  </span><br><span class="line">如果对象的 ETag 没有改变，其实也就意味著对象没有改变，才执行请求的动作，获取文档。</span><br><span class="line"></span><br><span class="line">If-None-Match</span><br><span class="line">如果对象的 ETag 改变了，其实也就意味著对象也改变了，才执行请求的动作，获取文档。</span><br><span class="line">   (莫得反得)</span><br><span class="line">If-Modified-Since(森恩斯)</span><br><span class="line">如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作（比如返回对象），否则返回代码304，告诉浏览器该对象没有修改。例如：If-Modified-Since：Thu, 10 Apr 2008 09:14:42 GMT</span><br><span class="line"></span><br><span class="line">If-Unmodified-Since</span><br><span class="line">如果请求的对象在该头部指定的时间之后没修改过，才执行请求的动作（比如返回对象）。</span><br><span class="line"></span><br><span class="line">If-Range /reinge/</span><br><span class="line">浏览器告诉 WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分给我，如果对象改变了，就把整个对象给我。浏览器通过发送请求对象的ETag 或者自己所知道的最后修改时间给 WEB 服务器，让其判断对象是否改变了。总是跟 Range 头部一起使用。</span><br><span class="line"></span><br><span class="line">Range</span><br><span class="line">浏览器（比如 Flashget 多线程下载时）告诉 WEB 服务器自己想取对象的哪部分。例如：Range: bytes=1173546</span><br><span class="line"></span><br><span class="line">Proxy-Authenticate(噢三特K特)</span><br><span class="line">代理服务器响应浏览器，要求其提供代理身份验证信息。</span><br><span class="line"></span><br><span class="line">Proxy-Authorization</span><br><span class="line">浏览器响应代理服务器的身份验证请求，提供自己的身份信息。</span><br><span class="line"></span><br><span class="line">Host</span><br><span class="line">客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。如Host：rss.sina.com.cn</span><br><span class="line"></span><br><span class="line">Referer(锐佛尔)</span><br><span class="line">浏览器向WEB 服务器表明自己是从哪个网页URL获得点击当前请求中的网址/URL，</span><br><span class="line">例如：Referer：http://www.ecdoer.com/</span><br><span class="line"></span><br><span class="line">User-Agent(A就特)</span><br><span class="line">浏览器表明自己的身份（是哪种浏览器）。</span><br><span class="line">例如：User-Agent：Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN;rv:1.8.1.14) Gecko/20080404 Firefox/2.0.0.14</span><br></pre></td></tr></table></figure>

## WebSocket 和 http 有什么区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">socket是传输控制层协议，webSocket是应用层协议</span><br><span class="line">​</span><br><span class="line">WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信(full-duplex)。</span><br><span class="line">一开始的握手需要借助HTTP请求完成。</span><br><span class="line">​</span><br><span class="line">HTTP请求缺点：</span><br><span class="line">会导致过多不必要的请求，浪费流量和服务器资源，每一次请求、应答，都浪费了一定流量在相同的头部信息上</span><br><span class="line">​</span><br><span class="line">然而WebSocket的出现可以弥补这一缺点。</span><br><span class="line">在WebSocket中，只需要服务器和浏览器通过HTTP协议进行一个握 手的动作，然后单独建立一条TCP的通信通道进行数据的传送。</span><br><span class="line">​</span><br><span class="line">原理:(webSocket)</span><br><span class="line">WebSocket同HTTP一样也是应用层的协议，但是它是一种双向通信协议，是建立在TCP之上的。</span><br><span class="line">​</span><br><span class="line">1. 浏览器、服务器建立TCP连接，三次握手。这是通信的基础，传输控制层，若失败后续都不执行。</span><br><span class="line">2. TCP连接成功后，浏览器通过HTTP协议向服务器传送WebSocket支持的版本号等信息。（开始前的HTTP握手）</span><br><span class="line">3. 服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据。</span><br><span class="line">4. 当收到了连接成功的消息后，通过TCP通道进行传输通信。</span><br><span class="line">​</span><br><span class="line">WebSocket与HTTP的关系</span><br><span class="line">相同点:</span><br><span class="line">都是一样基于TCP的，都是可靠性传输协议。</span><br><span class="line">都是应用层协议</span><br><span class="line">​</span><br><span class="line">不同点:</span><br><span class="line">WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息。HTTP是单向的。</span><br><span class="line">WebSocket是需要握手进行建立连接的。</span><br></pre></td></tr></table></figure>

# 异步

## 同步异步区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在js中，所有任务都分为同步任务和异步任务两大类。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</span><br><span class="line">（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</span><br><span class="line">（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</span><br><span class="line">（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</span><br><span class="line">（4）主线程不断重复上面的第三步。</span><br><span class="line">有时候 setTimeout明明写的延时3秒，实际却5，6秒才执行函数，这又是因为什么？</span><br><span class="line">答：setTimeout 并不能保证执行的时间，是否及时执行取决于 JavaScript 线程是拥挤还是空闲。</span><br><span class="line">浏览器的JS引擎遇到setTimeout，拿走之后不会立即放入异步队列，同步任务执行之后，timer模块会到设置时间之后放到异步队列中。js引擎发现同步队列中没有要执行的东西了，即运行栈空了就从异步队列中读取，然后放到运行栈中执行。所以setTimeout可能会多了等待线程的时间。</span><br><span class="line">这时setTimeout函数体就变成了运行栈中的执行任务，运行栈空了，再监听异步队列中有没有要执行的任务，如果有就继续执行，如此循环，就叫Event Loop。</span><br></pre></td></tr></table></figure>

## js 异步操作

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、定时器都是异步操作</span><br><span class="line">2、事件绑定都是异步操作</span><br><span class="line">3、AJAX中一般我们都采取异步操作（也可以同步）</span><br><span class="line">4、回调函数可以理解为异步（不是严谨的异步操作）</span><br><span class="line">5、promise</span><br><span class="line">6、generator（ES6）</span><br><span class="line">   通过yield关键字可以让任务在需要的地方暂停,每一步的值可以通过next获取</span><br><span class="line">7、async/await(ES7)</span><br><span class="line">   await得到的就是async异步返回值,底层原理还是promise中的resolve方法</span><br><span class="line">8、设计模式-发布订阅模式</span><br><span class="line">9、事件监听</span><br></pre></td></tr></table></figure>

## promise 对象

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ES6新增的一种异步解决方案，解决了之前异步回调地狱的问题</span><br><span class="line">Promise有三种状态，pending进行中，resolved成功，rejected失败</span><br><span class="line">特点是：状态不受外界改变，并且状态一旦改变，不可更改。不能暂停</span><br><span class="line">promise是同步，但他的.then() 方法是异步。</span><br><span class="line">可以使用链式调用方法</span><br><span class="line">当成功时可以使用.then()          第二个参数，失败的回调</span><br><span class="line">失败时可以使用.catch()</span><br><span class="line">不管状态如何都执行的操作.finally()</span><br><span class="line">Promise.race():只要有一个promise执行完毕后就会执行.then操作</span><br><span class="line">promise.all()：将多个promise实例包装成一个新的实例，参数为数组，只有当数组里的所有状态都是resolved新的状态才是resolved，返回值在全部成功时是一个结果数组，数组顺序和接收的顺序一致，失败时是第一个失败状态的值；</span><br></pre></td></tr></table></figure>

## promise.all 和 promise.race

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pomise.all的使用</span><br><span class="line">    Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。</span><br><span class="line">    Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，在前端开发请求数据的过程中，偶尔会遇到发送多个请求并根据请求顺序获取和使用数据的场景，使用Promise.all毫无疑问可以解决这个问题。</span><br><span class="line">Promise.race的使用</span><br><span class="line">    Promise.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。</span><br></pre></td></tr></table></figure>

## promise.all 封装思路

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">参数是数组，数组每一项是promises对象</span><br><span class="line">返回promise对象</span><br><span class="line">定义数字0，</span><br><span class="line">对数组进行循环，如果成功，每次循环数字++，如果数字和数组长度相等，则返回resolve()</span><br><span class="line">如果失败直接直接返回reject</span><br></pre></td></tr></table></figure>

## promise，async 区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async / await与 Promise的主要区别是：</span><br><span class="line">Promise代码完全都是Promise的API（then、catch等等），操作本身的语义反而不容易看出来, </span><br><span class="line">async / await函数的实现最简洁，最符合语义，几乎没有语义不相关的代码 </span><br><span class="line">async / await 函数就是 Generator 函数的语法糖</span><br><span class="line">async/await函数的优势 </span><br><span class="line">1. 使用async函数可以让代码简洁很多，不需要像Promise一样需要些then，不需要写匿名函数处理Promise的resolve值，也不需要定义多余的data变量，还避免了嵌套代码  </span><br><span class="line">2. 使用aync/await的话，catch能处理JSON.parse错误 promise中不能处理     </span><br><span class="line">3. 条件语句也和错误捕获是一样的，在 Async 中也可以像平时一般使用条件语句  </span><br></pre></td></tr></table></figure>

## async、await

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  async异步是用来装饰函数的，一个函数如果加上 async ，那么该函数就会返回一个 Promise对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句</span><br><span class="line">  await关键字只能在async函数中使用。可以用来等待Promise状态变成resolved并有返回值。await后面通常跟的是一个promise对象，如果不是，会立即被包装成resoled状态的promise。</span><br><span class="line">  如果await后面的 promise 正常resolve，await promise便会返回结果。但是在reject的情况下，便会抛出异常，并且这种异常需要用try/catch来捕获，整个async函数都会中断执行。</span><br><span class="line">  可以把async看成将函数返回值使用 Promise.resolve() 包裹了下</span><br><span class="line"></span><br><span class="line">await本身返回的也是一个Promise,它只是把await后面的代码放到了await返回的Promise的.then后面，以此来实现的。</span><br><span class="line">await只是让当前async函数内部、后面的代码等待，并不是所有代码都卡在这里。遇到await就先返回，执行async函数之后的代码。</span><br></pre></td></tr></table></figure>

## async/await 优势

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.简洁，不用匿名函数，不需要多余data避免嵌套</span><br><span class="line">2.catch能处理JSON.parse错误</span><br><span class="line">3.可以使用条件语句</span><br></pre></td></tr></table></figure>

## Generate

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Generator 的中文名称是生成器，它是ES6中提供的新特性。</span><br><span class="line">在过去，函数只存在“没有被调用”或者“被调用”的情况，</span><br><span class="line">不存在一个函数被执行之后还能暂停的情况，而Generator的出现让这种情况成为可能。</span><br><span class="line">通过 function* 来定义的函数称之为“生成器函数”（generator function），它的特点是可以中断函数的执行，</span><br><span class="line">每次执行yield语句之后，函数即暂停执行，直到调用返回的生成器对象的next()函数它才会继续执行。</span><br><span class="line">也就是说 Generator 函数是一个状态机，封装了多个内部状态。</span><br><span class="line">执行 Generator 函数返回一个遍历器对象（一个指向内部状态的指针对象），</span><br><span class="line">调用遍历器对象的next方法，使得指针移向下一个状态。每次调用next方法，</span><br><span class="line">内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。</span><br><span class="line">yield关键字</span><br><span class="line">真正让Generator具有价值的是yield关键字，这个yield关键字让 Generator内部的逻辑能够切割成多个部分。</span><br><span class="line">发现函数执行到第一个yield关键字的时候就停止了。要让业务逻辑继续执行完，需要反复调用.next()</span><br><span class="line">可以简单地理解为yield关键字将程序逻辑划分成几部分，每次.next()执行时执行一部分。</span><br><span class="line">这使得程序的执行单元再也不是函数，复杂的逻辑可以通过yield来暂停。</span><br><span class="line">.next()调用时，返回一个对象，这个对象具备两个属性。</span><br><span class="line">其中一个属性是布尔型的done。它表示这个Generator对象的逻辑块是否执行完成。</span><br><span class="line">另一个属性是value，它来自于yield语句后的表达式的结果。</span><br><span class="line">通过.next()传递参数，可以赋值给yield关键字前面的变量声明。</span><br></pre></td></tr></table></figure>

## defer，async

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原本浏览器解析文档遇到script标签会停下解析下载脚本并执行，一切结束后再解析文档</span><br><span class="line">defer：遇到不停下解析，其他线程下载脚本，脚本完成下载等解析完成后执行脚本</span><br><span class="line">async：遇到不停下解析，其他线程下载脚本，脚本下载完立即执行脚本后解析文档</span><br></pre></td></tr></table></figure>

# ES5

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. strict模式</span><br><span class="line">严格模式，限制一些用法，&#x27;use strict&#x27;;</span><br><span class="line">2. Array增加方法</span><br><span class="line">forEach，ES5具有遍历数组功能的还有map、filter、some、every、reduce、reduceRight等</span><br><span class="line">增加了indexOf、lastIndexOf、isArray、map、reduce、reduceRight方法</span><br><span class="line">PS：还有其他方法 Function.prototype.bind、String.prototype.trim、Date.now//返回自1970年1月1日0时到现在的毫秒数</span><br><span class="line">3. Object方法</span><br><span class="line">Object.getPrototypeOf</span><br><span class="line">Object.create</span><br><span class="line">Object.getOwnPropertyNames</span><br><span class="line">Object.defineProperty</span><br><span class="line">Object.getOwnPropertyDescriptor</span><br><span class="line">Object.defineProperties</span><br><span class="line">Object.keys</span><br><span class="line">Object.preventExtensions / Object.isExtensible</span><br><span class="line">Object.seal / Object.isSealed</span><br><span class="line">Object.freeze / Object.isFrozen</span><br></pre></td></tr></table></figure>

# ES6

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">let const     都有块级作用域，不具备变量提升，不能重复申明</span><br><span class="line">箭头函数 =&gt;；   语法简洁</span><br><span class="line">模板字符串      可读性强，使用$&#123;&#125;定义变量</span><br><span class="line">展开运算符      把数组或对象展开成,比如浅拷贝，数组扁平化</span><br><span class="line">解构赋值        数组或者对象进行模式匹配，对其中的变量进行赋值，语法简洁</span><br><span class="line">Promise        一种异步函数处理模式，语法简洁</span><br><span class="line">import模块化    封闭作用域，项目规范</span><br><span class="line">for-of遍历、for-in遍历；     for-in更适合遍历对象 for of遍历数组（可以遍历对象中可枚举的属性）</span><br><span class="line">函数默认参数     可以设定初始值</span><br><span class="line">Set            似于数组，特性是所有元素都是唯一的，没有重复。</span><br><span class="line">Symbol         表示独一无二的值，最大的用法是用来定义对象的唯一属性名</span><br><span class="line">代理（proxy）</span><br><span class="line">新增数组方法</span><br><span class="line">1.Array.from()  方法用于将对象转为真正的数组(类数组转数组)</span><br><span class="line">2.Array.of()    方法用于将一组值，转换为数组。</span><br><span class="line">   console.log(Array.of(1,2,3,4,4,50));//[1, 2, 3, 4, 4, 50]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Object.assign  (目标对象,对象1,对象2)用于对象的合并,将源对象的所有可枚举属性，复制到目标对象。(浅拷贝)</span><br><span class="line">Generators生成器函数</span><br><span class="line">  	总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。</span><br><span class="line">    </span><br><span class="line">Set结构和Map结构 </span><br><span class="line">1.Set:它类似于数组，但是成员的值都是唯一的，没有重复的值。</span><br><span class="line">Set本身是一个构造函数，用来生成 Set 数据结构，数组作为参数。</span><br><span class="line">        //数组去重</span><br><span class="line">        // let arr=[1,2,3,4,5,6,6,5,4,3,2,1];</span><br><span class="line">        // console.log([...new Set(arr)]);//[1, 2, 3, 4, 5, 6]</span><br><span class="line">        </span><br><span class="line">2.Map数据结构。它类似于对象，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</span><br></pre></td></tr></table></figure>

## var 和 let 在 for 循环的一些不同表现

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在var中执行的时候：</span><br><span class="line">    因为var是没有块级作用域的，所以在for循环中声明的i会存在于函数作用域中。每一次for循环就会声明一次i，但后面声明的变量会覆盖前面声明的变量。</span><br><span class="line">在let中执行的时候：</span><br><span class="line">    因为块级作用域的原因，let声明的i都会存在于for块级作用域中，每一次for循环都会生成一个块级作用域。</span><br></pre></td></tr></table></figure>

## 箭头函数 =&gt;

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">箭头函数表达式的语法比函数表达式更简洁</span><br><span class="line">箭头函数没有自己的this值,指向的是它外层的不是箭头函数的函数，如果没有则指向widnow，不能被改变</span><br><span class="line">适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</span><br><span class="line">是</span><br></pre></td></tr></table></figure>

### 箭头函数和普通函数的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法简洁，this指向明确</span><br><span class="line">普通函数参数可以使用arguments拿到参数</span><br><span class="line">箭头函数可以使用rest参数：形式为...变量名</span><br></pre></td></tr></table></figure>

### 构造函数

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1) 当以 new 关键字调用时，会创建一个新的内存空间，标记为 Animal 的实例。</span><br><span class="line">(2)函数体内部的 this 指向该内存</span><br><span class="line">  每当创建一个实例的时候，就会创建一个新的内存空间(#f2, #f3)，创建 #f2 的时候，函数体内部的 this 指向 #f2, 创建 #f3 的时候，函数体内部的 this 指向 #f3。</span><br><span class="line">(3) 执行函数体内的代码</span><br><span class="line">通过上面的讲解，你就可以知道，给 this 添加属性，就相当于给实例添加属性。</span><br><span class="line">(4) 默认返回 this</span><br></pre></td></tr></table></figure>

## rest

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rest参数和arguments的区别在于，arguments是类数组对象，不能使用数组API。</span><br><span class="line">而rest 参数是一个真正的数组，数组特有的方法都可以使用。</span><br></pre></td></tr></table></figure>

## Set

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值，所以Set方法一般用来数组去重</span><br><span class="line">    let arr = [2, 3, 3, 4, 6, 5, 3, 4, 4];</span><br><span class="line">    let arr2 = [...new Set(arr)];</span><br><span class="line">这里new Set出来的不是真正的数组，所以需要用到...扩展运算符</span><br><span class="line">Set及应用场景</span><br><span class="line">一、创建Set对象实例</span><br><span class="line">Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用</span><br><span class="line">1.构造函数           (伊特波)</span><br><span class="line">    语法：new Set([iterable])</span><br><span class="line">    参数：iterable 如果传递一个可迭代对象，它的所有元素将被添加到新的Set中；</span><br><span class="line">         如果不指定此参数或其值为null，则新的 Set为空</span><br><span class="line">二、Set实例属性</span><br><span class="line">    size属性将会返回Set对象中元素的个数</span><br><span class="line">三、Set实例方法</span><br><span class="line">1.add() 方法用来向一个 Set 对象的末尾添加一个指定的值</span><br><span class="line">    语法：mySet.add(value)</span><br><span class="line">    参数：value 必需，需要添加到 Set 对象的元素的值</span><br><span class="line">2.delete() 方法可以从一个 Set 对象中删除指定的元素</span><br><span class="line">    语法：mySet.delete(value)</span><br><span class="line">    参数：value 将要删除的元素</span><br><span class="line">    返回值：成功删除返回 true，否则返回 false</span><br><span class="line">3.clear() 方法用来清空一个 Set 对象中的所有元素</span><br><span class="line">    语法：mySet.clear()</span><br><span class="line">4.has() 方法返回一个布尔值来指示对应的值value是否存在Set对象中</span><br><span class="line">    语法：mySet.has(value)</span><br><span class="line">    参数：value 必须，是否存在于Set的值</span><br><span class="line">    返回值：如果指定的值（value）存在于Set对象当中，返回true; 否则返回 false</span><br><span class="line">5.entries() (安吹斯)</span><br><span class="line">    语法：mySet.entries()</span><br><span class="line">    返回值：一个新的包含 [value, value] 形式的数组迭代器对象，value 是给定集合中的每个元素，</span><br><span class="line">          迭代器 对象元素的顺序即集合对象中元素插入的顺序</span><br><span class="line">6.values()</span><br><span class="line">    语法：mySet.values() 或者 mySet.keys()</span><br><span class="line">    返回值：返回一个 Iterator(因特瑞特) 对象，这个对象以插入Set对象的顺序包含了原 Set 对象里的每个元素</span><br><span class="line">7.forEach()</span><br><span class="line">    语法：mySet.forEach(callback[, thisArg]) (this傲歌)</span><br><span class="line">    参数：callback 每个元素都会执行的函数</span><br><span class="line">          thisArg 当执行callback函数时候，可以当作this来使用</span><br><span class="line">5、什么是WeakSet()？</span><br><span class="line">和Set结构类似，也是不重复的值的集合，但WeakSet的成员只能是对象(null 除外)。</span><br><span class="line">而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</span><br><span class="line">应用场景:</span><br><span class="line">1、简单数组去重</span><br><span class="line">2、JSON数组去重</span><br><span class="line">    JSON数组是比较常见的一种数据结构，形如[&#123;…&#125;,…&#123;…&#125;]</span><br><span class="line">    假如你需要统计某个属性中不同的值。</span><br><span class="line">    step1:先使用.map将JSON数组变成简单数组，然后用set执行去重</span><br><span class="line">    step2: 由于生成的Set属于可迭代对象，所以可以使用数组解构符进行解构</span><br><span class="line">3、二维数组去重</span><br><span class="line">    我们可以将Set用作存储每项的唯一值，结合reduce进行对比，得出无重复的项目。</span><br><span class="line">    当然，上面的代码缺点还是不少的。因为只是简单地将其转变成字符串作为对比的键，</span><br><span class="line">    所以不能区分[1,2]、[‘1’ ,‘2’]、[‘1,2’]等子数组。</span><br><span class="line">4、数组之间的对比</span><br><span class="line">    Set的特性不单单可以可以用于单数组，对于数组之间的比较也是十分在行。</span><br><span class="line">什么是WeakSet()？</span><br><span class="line">    和Set结构类似，也是不重复的值的集合，但WeakSet的成员只能是对象。</span><br><span class="line">WeakSet的API：</span><br><span class="line">    add()    //增</span><br><span class="line">    delete() //删</span><br><span class="line">    has()    //是否存在</span><br><span class="line">为什么WeakSet不可遍历？</span><br><span class="line">    因为WeakSet的成员都是弱引用，随时可能消失，成员是不稳定的。</span><br><span class="line">WeakSet的用处：</span><br><span class="line">    使用ws储存DOM节点，就不用担心节点从文档移除时，会引发内存泄漏(即在被移除的节点上绑定的</span><br></pre></td></tr></table></figure>

## Symbol

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表示独一无二的值，最大的用法是用来定义对象的唯一属性名</span><br></pre></td></tr></table></figure>

## 代理,数据劫持（proxy）

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Proxy这个词的原意是代理，用在这里表示由它来代理某些操作，可以译为代理器。可以理解成在目标对象之前设置一层拦截，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</span><br><span class="line">Vue 2.0的版本所使用的数据劫持，是通过Object.defineProperty()来劫持对象属性的setter和getter操作，在数据变动时做你想要做的事情，在vue3.0使用propx进行数据的劫持，可以检测到引用类型的改变</span><br></pre></td></tr></table></figure>

## 解构赋值

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">从对象或数组中获取或提取值的一种新的、更简洁的方法</span><br><span class="line">- let a = 1; let b = 2; [b, a] = [a, b];</span><br><span class="line">- import &#123;Component&#125; from &#x27;react&#x27;</span><br><span class="line">- import &#123;getTableData&#125; from &#x27;../api.js&#x27;</span><br><span class="line">- getTableData().then(res =&gt; &#123;let &#123; data &#125; = res&#125;)</span><br></pre></td></tr></table></figure>

## map

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map 是有序的键值对，其中的键允许是任何类型。与 Set 相似，通过调用 Object.is()方法来判断重复的键，这意味着能将数值 5 与字符串 &quot;5&quot; 作为两个相对独立的键。使用set() 方法能将任何类型的值关联到某个键上，并且该值此后能用 get() 方法提取出来。Map 也拥有一个 size 属性与一个 forEach() 方法，让项目访问更容易。</span><br></pre></td></tr></table></figure>

## for 循环和 for.in

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for循环只能够遍历数组</span><br><span class="line">for.in循环可以遍历数组和对象，最好遍历对象。</span><br><span class="line">object.keys也可以遍历对象</span><br></pre></td></tr></table></figure>

## for of 和 for in 的区别

#### for in遍历数组的毛病

1.index索引为字符串型数字，不能直接进行几何运算
 2.遍历顺序有可能不是按照实际数组的内部顺序
 3.使用for in会遍历数组所有的可枚举属性，包括原型。例如上栗的原型方法method和name属性
 所以for in更适合遍历对象，不要使用for in遍历数组。

 for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name 

 for in 可以遍历到myObject的原型方法method,如果不想遍历原型方法和属性的话，可以在循环内部判断一下,hasOwnPropery方法可以判断某属性是否是该对象的实例属性 

# 原型和原型链

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">每个对象都有一个__proto__属性，并且指向它的原型对象</span><br><span class="line">这个实例对象的构造函数有一个prototype属性，指向原型对象</span><br><span class="line">原型对象通过指向构造函数本身</span><br><span class="line">当对象在查找一个属性的时候，自身没有就会根据__proto__向它的原型进行查找，如果都没有，则向它的原型的原型继续查找，直到查到Object.prototype.__proto_为null,这样也就形成了原型链</span><br><span class="line">原型：</span><br><span class="line">Javascript规定，每一个函数都有一个prototype对象属性，指向另一个对象</span><br><span class="line">prototype就是调用构造函数所创建的那个实例对象的原型</span><br><span class="line">原型链：</span><br><span class="line">实例对象与原型之间的连接，叫做原型链。</span><br><span class="line">JS在创建对象的时候，都有一个叫做__proto__的内置属性，用于指向创建它的函数对象的原型对象prototype</span><br><span class="line">获取原型的方法</span><br><span class="line">p.proto</span><br><span class="line">p.constructor.prototype</span><br><span class="line">Object.getPrototypeOf(p)</span><br></pre></td></tr></table></figure>

![图片](https://uploader.shimo.im/f/iyLXj7QjZHSFAYgA.png!thumbnail?fileGuid=DdqDv83wHqr8W3kc)

## prototype、proto、constructor 三者的关系

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、prototype:</span><br><span class="line">每一个函数都有一个prototype这个属性，而这个属性指向一个对象，这个对象我们叫做原型对象</span><br><span class="line">作用：节约内存扩展属性和方法可以实现类之间的继承</span><br><span class="line">2、__proto__:</span><br><span class="line">每一个对象都有一个__proto__属性,__proto__指向创建自己的那个构造函数的原型对象对象可以直接访问__proto__里面的属性和方法</span><br><span class="line">3、constructor：</span><br><span class="line">指向创建自己的那个构造函数 ，是原型上的方法</span><br><span class="line">总结：</span><br><span class="line">当我们创建一个构造函数的时候这个构造函数自带了一个prototype属性，而这个属性指向一个对象，也就是原型对象。 这个原型对象里面有一个constructor构造器，它的作用是指向创建自己的构造函数。</span><br><span class="line">除此之外 prototype还可以存放公共的属性和方法。</span><br><span class="line">当我们实例化一个对象的时候(被new调用的时候)，这个对象自带了一个 proto 属性，</span><br><span class="line">这个proto 指向创建自己的构造函数的原型对象。可以使用这个原型对象里面的属性和方法</span><br></pre></td></tr></table></figure>

# 什么是高阶函数，有用过哪些高阶函数

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">高阶函数，就是让函数的参数能够接收别的函数</span><br><span class="line">foreach 方法用于调用数组的每个元素，并将元素传递给回调函数。</span><br><span class="line">map     对数组中每个元素进行操作，生成一个新数组</span><br><span class="line">some    方法用于检测数组中的元素是否满足指定条件（函数提供）</span><br><span class="line">filter  方法创建一个新的数组，过滤(当返回值为ture时，才会返回当前处理的元素)：</span><br><span class="line">every   方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。</span><br><span class="line">reduce  方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</span><br><span class="line">这些方法中都是对数组中每一个元素进行遍历操作，只有foreach是没有返回值的</span><br><span class="line">reduce的回调函数中，是有四个参数的，初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。</span><br></pre></td></tr></table></figure>



### 渐进增强

渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。

优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容

# 数组

## 数组 API

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">pop删除最后一个元素，原数组；</span><br><span class="line">shift删除第一个元素，原数组；</span><br><span class="line">push添加一个新元素在最后，原数组；</span><br><span class="line">unshift添加一个新元素到第一个位置，原数组；</span><br><span class="line">reverse颠倒数组，原数组；</span><br><span class="line">splice（万能的），原数组；</span><br><span class="line">sort特定顺序排序，原数组；</span><br><span class="line">fill填充一些变量到指定位置，原数组；</span><br><span class="line">join用特定字符拼接数组成字符串；</span><br><span class="line">tolocatestring将时间对象转换为字符串格式；</span><br><span class="line">slice截取片段，新数组；</span><br><span class="line">cancat数组最后加元素，新数组；</span><br><span class="line">indexof查找数组里的特定元素，返回索引或-1；</span><br><span class="line">lastindexof倒序查找；</span><br><span class="line">includes返回数组是否包含某个元素；</span><br><span class="line">foreach遍历，执行回调；</span><br><span class="line">every检测每个元素符不符合条件；</span><br><span class="line">some检测有没有元素符合条件；</span><br><span class="line">filter返回过滤后的新数组；</span><br><span class="line">map返回每个都被操作过的元素组成的新数组；</span><br><span class="line">reduce归并，接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值；</span><br><span class="line">find返回第一个满足条件的元素；</span><br><span class="line">findqiindex返回满足条件的元素的索引</span><br></pre></td></tr></table></figure>

## 数组和伪数组

伪数组

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">拥有 length 属性，</span><br><span class="line">但是不具有数组所具有的方法</span><br><span class="line">类型是 Object ，而数组类型是 Array</span><br></pre></td></tr></table></figure>

常见的伪数组

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数内部的 arguments</span><br><span class="line">DOM 对象列表（比如通过 document.getElementsByTags 得到的列表）</span><br><span class="line">jQuery 对象（比如 $(&quot;div&quot;) ）</span><br></pre></td></tr></table></figure>

## 如何扩展数组,让他拥有新的方法

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.push.apply(a,b)</span><br></pre></td></tr></table></figure>

## map 和 foreach,reduce 区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map有返回值,函数依次作用到每一个元素，每个元素都会被函数单独作用一次。,对于map当数组中的元素是值类型的时候，不会改变原数组，如果是引用类型就会改变原数组</span><br><span class="line">forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。改变原数组</span><br><span class="line">map()是将传入的函数依次作用到序列的每个元素，每个元素都是独自被函数“作用”一次 。</span><br><span class="line">reduce()是将传人的函数作用在序列的第一个元素得到结果后，把这个结果继续与下一个元素作用（累积计算）。</span><br></pre></td></tr></table></figure>

## 数组合并

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1、concat</span><br><span class="line">	js的Array对象提供了一个叫concat()方法，连接两个或更多的数组，并返回结果。</span><br><span class="line">		var c = a.concat(b); //c=[1,2,3,4,5,6];</span><br><span class="line">	这里有一个问题，concat方法连接a、b两个数组后，a、b两个数组的数据不变，同时会返回一个新的数组。这样当我们需要进行多次的数组合并时，会造成很大的内存浪费，如果是数据量比较小的时候，还可以勉强用，如果数据量大的时候，这个就不妥了，所以这个方法肯定不是最好的。</span><br><span class="line">2、for循环</span><br><span class="line">大概的思路是：遍历其中一个数组，把该数组中的所有元素依次添加到另外一个数组中。直接上代码：</span><br><span class="line">	for(var i in b) &#123; a.push ( b[i] );&#125;</span><br><span class="line"></span><br><span class="line">3、apply</span><br><span class="line">	函数的apply方法有一个特性，那就是func.apply(obj,argv)，argv是一个数组。</span><br><span class="line">		a.push.apply(a,b);</span><br><span class="line">	调用a.push这个函数实例的apply方法，同时把，b当作参数传入，</span><br><span class="line">	这样a.push这个方法就会遍历b数组的所有元素，达到合并的效果。</span><br><span class="line">	这里可能有点绕，我们可以把b看成[4,5,6]，变成这样：</span><br><span class="line">		a.push.apply(a,[4,5,6]);</span><br><span class="line">	然后上面的操作就等同于：</span><br><span class="line">		a.push(4,5,6);</span><br></pre></td></tr></table></figure>

# 深浅拷贝

浅拷贝

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.使用Object.assign</span><br><span class="line">2.使用展开运算符（…）</span><br></pre></td></tr></table></figure>

浅拷贝只解决了第一层的问题，如果接下去的值还有对象的话，那就需要用深拷贝
深拷贝

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1.通过 JSON.parse(JSON.stringify(object)) 来解决。</span><br><span class="line">但是该方法也是有局限性的：</span><br><span class="line">  - 会忽略 undefined</span><br><span class="line">  - 会忽略 symbol</span><br><span class="line">  - 如果对象里有函数,函数无法被拷贝下来</span><br><span class="line">  - 无法拷贝对象原型链上的属性和方法</span><br><span class="line">  - 当数据的层次很深，会栈溢出</span><br><span class="line">如果遇到这些情况，可以使用递归或者 lodash 的深拷贝函数</span><br><span class="line">2.递归函数</span><br><span class="line">function deepCopy( source ) &#123;</span><br><span class="line">if (!isObject(source)) return source; //如果不是对象的话直接返回</span><br><span class="line">    let target = Array.isArray( source ) ? [] : &#123;&#125; //数组兼容</span><br><span class="line">    for ( var k in source ) &#123;</span><br><span class="line">    	if (source.hasOwnProperty(k)) &#123;</span><br><span class="line">    		if ( typeof source[ k ] === &#x27;object&#x27; ) &#123;</span><br><span class="line">            	target[ k ] = deepCopy( source[ k ] )</span><br><span class="line">        	&#125; else &#123;</span><br><span class="line">            	target[ k ] = source[ k ]</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return target</span><br><span class="line">&#125;</span><br><span class="line">function isObject(obj) &#123;</span><br><span class="line">    return typeof obj === &#x27;object&#x27; &amp;&amp; obj !== null</span><br><span class="line">&#125;</span><br><span class="line">将要拷贝的数据 obj 以参数的形式传参</span><br><span class="line">声明一个变量 来储存我们拷贝出来的内容</span><br><span class="line">判断 obj 是否是引用类型数据，如果不是，则直接赋值即可（ 可以利用 obj instanceof Type 来进行判断），</span><br><span class="line">由于用 instanceof 判断array 是否是object的时候，返回值为true, 所以我们在判断的时候，直接判断obj 是否是Array 就可避免这个问题</span><br><span class="line">根据判断的不同类型，再给之前的变量赋予不同的类型： [ ] : &#123; &#125;</span><br><span class="line">循环obj 中的每一项，如果里面还有复杂数据类型，则直接利用递归再次调用copy函数</span><br><span class="line">最后 将 这个变量 return 出来即可</span><br><span class="line">缺点：</span><br><span class="line">（1）无法保持引用</span><br><span class="line">（2）当数据的层次很深，会栈溢出</span><br></pre></td></tr></table></figure>

## 对象浅拷贝在 react 中用到哪些地方,为什么

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为什么在react中要使用浅拷贝</span><br><span class="line">redux中要求:状态是只读的,唯一且不可修改的,reducer必须是一个纯函数</span><br><span class="line">因为redux中数据不可更改,所以redux中的数据应该要拷贝  返回一个新值</span><br></pre></td></tr></table></figure>

# 数据请求

## jQuery ajax

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">	$.ajax(&#123;</span><br><span class="line">		type: &#x27;POST&#x27;,</span><br><span class="line">		url: url,</span><br><span class="line">		data: data,</span><br><span class="line">		dataType: dataType,</span><br><span class="line">		success: function () &#123;&#125;,</span><br><span class="line">		error: function () &#123;&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">// 优缺点：</span><br><span class="line">	是对原生XHR的封装，除此以外还增添了对JSONP的支持。</span><br><span class="line">	本身是针对MVC的编程,不符合现在前端MVVM的浪潮</span><br><span class="line">	基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案</span><br><span class="line">	JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理</span><br><span class="line">	（采取个性化打包的方案又不能享受CDN服务）</span><br></pre></td></tr></table></figure>

## axios

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	axios(&#123;</span><br><span class="line">		method: &#x27;post&#x27;,</span><br><span class="line">		url: &#x27;/user/12345&#x27;,</span><br><span class="line">		data: &#123;</span><br><span class="line">			firstName: &#x27;Fred&#x27;,</span><br><span class="line">			lastName: &#x27;Flintstone&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	.then(function (response) &#123;</span><br><span class="line">		console.log(response);</span><br><span class="line">	&#125;)</span><br><span class="line">	.catch(function (error) &#123;</span><br><span class="line">		console.log(error);</span><br><span class="line">	&#125;);</span><br><span class="line">// 优缺点：</span><br><span class="line">	Axios本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，</span><br><span class="line">	从它的官网上可以看到它有以下几条特性：</span><br><span class="line">		从 node.js 创建 http 请求</span><br><span class="line">		支持 Promise API</span><br><span class="line">		客户端支持防止CSRF</span><br><span class="line">		提供了一些并发请求的接口（重要，方便了很多的操作）</span><br></pre></td></tr></table></figure>

## fetch

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fetch(&#x27;some-url&#x27;, &#123;</span><br><span class="line">  method: &#x27;post&#x27;,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    &#x27;Content-Type&#x27;: &#x27;application/json&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  body: JSON.stringify(content)</span><br><span class="line">&#125;)</span><br><span class="line">// 优缺点：</span><br><span class="line">    符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里</span><br><span class="line">    更好更方便的写法</span><br><span class="line">    更加底层，提供的API丰富（request, response）</span><br><span class="line">    脱离了XHR，是ES规范里新的实现方式</span><br><span class="line">fetch是一个低层次的API，你可以把它考虑成原生的XHR，所以使用起来并不是那么舒服，</span><br><span class="line">需要进行封装，例如：</span><br><span class="line">1）fetch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理</span><br><span class="line">2）fetch默认不会带cookie，需要添加配置项</span><br><span class="line">3）fetch不支持abort，不支持超时控制，</span><br><span class="line">   使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费</span><br><span class="line">4）fetch没有办法原生监测请求的进度，而XHR可以</span><br><span class="line"></span><br></pre></td></tr></table></figure>

## 为什么要用 axios?

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征：</span><br><span class="line">	从浏览器中创建 XMLHttpRequest</span><br><span class="line">	从 node.js 发出 http 请求</span><br><span class="line">	支持 Promise API</span><br><span class="line">	拦截请求和响应</span><br><span class="line">	转换请求和响应数据</span><br><span class="line">	取消请求</span><br><span class="line">	自动转换JSON数据</span><br><span class="line">    客户端支持防止CSRF/XSRF</span><br></pre></td></tr></table></figure>

## axios 和 fetch 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">axios是一种对ajax的封装，fetch是一种浏览器原生实现的请求方式，跟ajax对等</span><br><span class="line">axios需要第三方库引入，fetch浏览器原生支持</span><br><span class="line">1.兼容问题  Axios可以兼容IE浏览器，而Fetch在IE浏览器和一些老版本浏览器上没有受到支持，但是有一个库可以让老版本浏览器支持Fetch即它就是whatwg-fetch，它可以让你在老版本的浏览器中也可以使用Fetch，并且现在很多网站的开发都为了减少成本而选择不再兼容IE浏览器。</span><br><span class="line"></span><br><span class="line">2.请求方式 传递数据的方式不同，Axios是放到data属性里，以对象的方式进行传递，而Fetch则是需要放在body属性中，以字符串的方式进行传递</span><br><span class="line"></span><br><span class="line">3.响应超时  Axios的相应超时设置是非常简单的，直接设置timeout属性就可以了，而Fetch设置起来就远比Axios麻烦，这也是很多人更喜欢Axios而不太喜欢Fetch的原因之一</span><br><span class="line">Fetch提供了AbortController属性，但是使用起来不像Axios那么简单</span><br><span class="line"></span><br><span class="line">4.对数据的转换  Axios还有非常好的一点就是会自动对数据进行转化，而Fetch则不同，它需要使用者进行手动转化。</span><br><span class="line"></span><br><span class="line">5.拦截器  Axios的一大卖点就是它提供了拦截器，可以统一对请求或响应进行一些处理，相信如果看过一个比较完整的项目的请求封装的话，一定对Axios的拦截器有一定的了解，它是一个非常重要的功能。</span><br><span class="line">使用它可以为请求附加token、为请求增加时间戳防止请求缓存，以及拦截响应，一旦状态码不符合预期则直接将响应消息通过弹框的形式展示在界面上，比如密码错误、服务器内部错误、表单验证不通过等问题</span><br><span class="line">而Fetch没有拦截器功能，但是要实现该功能并不难，直接重写全局Fetch方法就可以办到</span><br><span class="line"></span><br><span class="line">axios怎么取消请求</span><br><span class="line">原生中有一个取消的方法，可以调用XMLHttpRequest对象上的abort方法</span><br><span class="line">在axios拦截器里, 查找axios的文档，发现 可以通过使用CancelToken来取消axios发起的请求</span><br></pre></td></tr></table></figure>

## get 与 post 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.提交方式</span><br><span class="line">get: get会将接收到的数据拼接到url地址中,以&quot;?&quot;问号划分,问号后面是接收到的数据,多个数据之间用&amp;连接。用户可以很直观的看见。</span><br><span class="line">post: post会将接收到的数据放置在html header中一起发送到指定的url地址内。用户看不到这个过程。</span><br><span class="line">​</span><br><span class="line">2.传递数据大小</span><br><span class="line">get: get传递数据的大小因为受到浏览器地址栏的限制,所以一般在2k-8k,这要据浏览器而定,比如谷歌浏览器就是8k。</span><br><span class="line">post: post传递数据的大小最小是2M,但理论上是无上限的。</span><br><span class="line">​</span><br><span class="line">3.应用范围</span><br><span class="line">get: get一般用于获取/查询资源信息.多用于a标签的href属性中,也常用于location.href属性中。</span><br><span class="line">post: post一般是用于更新数据信息.多用于表单提交。</span><br><span class="line">​</span><br><span class="line">1.get传参方式是通过地址栏URL传递，是可以直接看到get传递的参数</span><br><span class="line">  post传参方式参数URL不可见</span><br><span class="line">  get把请求的数据在URL后通过？连接，通过&amp;进行参数分割</span><br><span class="line">  psot将参数存放在HTTP的包体内</span><br><span class="line">2.get传递数据是通过URL进行传递，对传递的数据长度是受到URL大小的限制，URL最大长度是2048个字符。post没有长度限制</span><br><span class="line">3.get后退不会有影响，post后退会重新进行提交</span><br><span class="line">4.get请求可以被缓存，post不可以被缓存</span><br><span class="line">5.get请求只URL编码，post支持多种编码方式</span><br><span class="line">6.get请求的记录会留在历史记录中，post请求不会留在历史记录</span><br><span class="line">7.get只支持ASCII字符，post没有字符类型限制</span><br></pre></td></tr></table></figure>

## 数据请求设置请求数据格式 Content-Type

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.浏览器默认的 application/x-www-form-urlencoded(url因扣得的)</span><br><span class="line">这应该是最常见的 POST 提交数据的方式了。浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.multipart(莫踢怕特)/form-data</span><br><span class="line">这也是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，就要让 form 的 enctype 等于这个值</span><br><span class="line"></span><br><span class="line">3.application/json</span><br><span class="line">除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify  </span><br><span class="line"></span><br><span class="line">4.text/xml</span><br><span class="line">相比于JSON，不能更好的适用于数据交换，它包含了太多的包装, 而且它跟大多数编程语言的数据模型不匹配，让大多数程序员感到诧异，XML是面向数据的，JSON是面向对象和结构的，JSON会给程序员一种更加亲切的感觉。</span><br></pre></td></tr></table></figure>

# 跨域

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">跨域是由于浏览器的同源策略造成的</span><br><span class="line">必须协议，端口，域名完全相同才可以访问</span><br></pre></td></tr></table></figure>

## JSONP

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">JSONP 的原理是利用 &lt;script&gt; 标签没有跨域限制的漏洞。通过动态创建 &lt;script&gt; 标签，使用src指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。​</span><br><span class="line">原理:</span><br><span class="line">	利用浏览器的&quot;漏洞&quot; script的src不受同源策略的影响，可以请求任何链接 。动态创建script标签，将事先写好的函数名传给服务器，供服务器使用</span><br><span class="line">（1）script标签src属性不存在跨域</span><br><span class="line">（2）get方式--传递函数名 --弊端</span><br><span class="line">（3）callback回调函数(传递函数名)</span><br><span class="line">JSONP 使用简单且兼容性不错，但是只限于 get 请求。</span><br><span class="line">jsonp返回的是一个JS函数调用代码，把返回的数据和客户端能调用的函数名拼接在一起，放到浏览器环境下，去执行而得到最终的服务端数据，也就是jsonp是一种json数据的传输方式而不是格式</span><br><span class="line">而json是一个数据格式</span><br><span class="line">JSON.stringify() 将js值转换为JSON字符串</span><br><span class="line">JSON.parse()     将JSON字符串转换为对象。</span><br><span class="line">流程</span><br><span class="line">1、创建一个全局函数 </span><br><span class="line">2、创建一个script标签 </span><br><span class="line">3、给script添加src </span><br><span class="line">4、给src添加回调函数test(callback=test) callback是传给后端的一个参数</span><br><span class="line">5、将script放到⻚面上</span><br><span class="line">6、script请求完成，将自己从⻚面上删除</span><br></pre></td></tr></table></figure>

## CORS 找后端开放接口

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">普通跨域请求:只服务端设置Access-Control-Allow-Origin即可，前端无须设置。</span><br><span class="line">​浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</span><br><span class="line">​服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源</span><br></pre></td></tr></table></figure>

## 反向代理 nginx 配置

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">跨域原理:同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</span><br><span class="line">实现思路:通过nginx配置一个代理服务器(域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，实现跨域。</span><br></pre></td></tr></table></figure>

webpack
​![图片](https://uploader.shimo.im/f/cqPEDyITuqfZ6nbz.png!thumbnail?fileGuid=DdqDv83wHqr8W3kc)

# 前端存储

localStorage, sessionStorage 和 cookie 之间的区别

| 特性         | cookie                                     | localStorage                                 | sessionStorage | IndexDB                                      |
| :----------- | :----------------------------------------- | :------------------------------------------- | :------------- | :------------------------------------------- |
| 数据生命周期 | 一般由服务器生成，可以设置过期时间         | 持久化本地存储，除非被主动删除，否则一直存在 | 页面关闭就清理 | 持久化本地存储，除非被主动删除，否则一直存在 |
| 数据存储大小 | 4K                                         | 5M                                           | 5M             | 无限                                         |
| 与服务端通信 | 每次都会携带在 header 中，对于请求性能影响 | 不参与                                       | 不参与         | 不参与                                       |

首先总的来说，三者都是用于持久化数据存储的手段，都是存储在浏览器端，且同源.

localStorage 和 sessionStorage 都是 Web 存储，大小 5M 左右，完全存储在客户端，它们是因为本地存储数据而存在.

cookies 也是存储在浏览器端的，大小不超过 4k，由服务器端存储在客户端。没有自己的方法，需要自己封装一些方法

localStorage 属于永久性存储,数据存储量大,，而 sessionStorage 属于当会话结束的时候，存储的值会被清空，而 cookie 是通过设置过期时间 expires 来存储的。

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cookie数据存放在客户的浏览器上，session数据放在服务器上 </span><br><span class="line">cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session </span><br><span class="line">session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie </span><br><span class="line">区别： </span><br><span class="line">1、cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下 </span><br><span class="line">2、存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 </span><br><span class="line">3、数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭 </span><br><span class="line">4、作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的 </span><br><span class="line">5、web Storage支持事件通知机制，可以将数据更新的通知发送给监听者 </span><br><span class="line">6、web Storage的api接口使用更方便</span><br></pre></td></tr></table></figure>

## locastorage 封装过期时间

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var date = new Date().getTime();</span><br><span class="line">//设置localStorage的值</span><br><span class="line">foowwLocalStorage.set(&quot;test&quot;, &quot;你好&quot;, date + 10000);</span><br><span class="line">//获取localStorage的值</span><br><span class="line">var data = foowwLocalStorage.get(&quot;test&quot;);</span><br><span class="line">const foowwLocalStorage = &#123;</span><br><span class="line">    set: function (key, value, ttl_ms) &#123;</span><br><span class="line">        var data = &#123; value: value, expirse: new Date(ttl_ms).getTime() &#125;;</span><br><span class="line">        localStorage.setItem(key, JSON.stringify(data));</span><br><span class="line">    &#125;,</span><br><span class="line">    get: function (key) &#123;</span><br><span class="line">        var data = JSON.parse(localStorage.getItem(key));</span><br><span class="line">        if (data !== null) &#123;</span><br><span class="line">            debugger</span><br><span class="line">            if (data.expirse != null &amp;&amp; data.expirse &lt; new Date().getTime()) &#123;</span><br><span class="line">                localStorage.removeItem(key);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return data.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

## 怎么携带 cookie 发送给后端

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置请求头   请求头中携带cookie</span><br></pre></td></tr></table></figure>

# 泄漏和内存溢出的区别?

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、内存泄漏:是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。</span><br><span class="line">2、内存溢出:指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。</span><br></pre></td></tr></table></figure>

## 会造成内存泄漏的操作

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、意外的全局变量</span><br><span class="line">2、被遗忘的定时器</span><br><span class="line">3、没有清除的dom应用 ，故要及时清除，</span><br><span class="line">4、滥用闭包</span><br><span class="line">第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</span><br><span class="line">第二种情况是我们设置了setInterval定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</span><br><span class="line">第三种情况是我们获取一个DOM元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</span><br><span class="line">第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</span><br></pre></td></tr></table></figure>

# 垃圾回收机制

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数。</span><br><span class="line">1、标记清除</span><br><span class="line">　　标记清除——当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。</span><br><span class="line">2、引用计数 12年左右废弃</span><br><span class="line">　　跟踪记录每个值被引用的次数。一旦没有引用，内存就直接释放了。</span><br></pre></td></tr></table></figure>

# es5 继承

原型链继承

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">基本代码</span><br><span class="line">function SuperType () &#123;</span><br><span class="line">　　this.property = true</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = function () &#123;</span><br><span class="line">　　return this.property</span><br><span class="line">&#125;</span><br><span class="line">function SubType () &#123;</span><br><span class="line">　　this.subproperty = false</span><br><span class="line">&#125;</span><br><span class="line">// 继承了SuperType //</span><br><span class="line">SubType.prototype = new SuperType()</span><br><span class="line">SubType.protype.getSubValue = function () &#123;</span><br><span class="line">　　return this.subproperty</span><br><span class="line">&#125;</span><br><span class="line">var instance = new SubType()</span><br><span class="line">实现的本质：重写原型对象，用一个新的类型的实例去替代</span><br><span class="line">SubType Prototype === SuperType构造函数的实例</span><br><span class="line">注意：</span><br><span class="line">1.默认的原型</span><br><span class="line">所有的引用类型都默认继承Object，这个继承也是通过原型链实现的</span><br><span class="line">2.原型链的问题</span><br><span class="line">a.对象实例共享所有继承的属性和方法</span><br><span class="line">b.创建子类型的实例的时候，不能传递参数</span><br><span class="line">特点：</span><br><span class="line">    非常纯粹的继承关系，实例是子类的实例，也是父类的实例</span><br><span class="line">    父类新增原型方法/原型属性，子类都能访问到</span><br><span class="line">    简单，易于实现</span><br><span class="line">缺点：</span><br><span class="line">    要想为子类新增属性和方法，不能放到构造器中</span><br><span class="line">    无法实现多继承</span><br><span class="line">    来自原型对象的所有属性被所有实例共享</span><br><span class="line">    创建子类实例时，无法向父类构造函数传参</span><br></pre></td></tr></table></figure>

构造继承

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Son.prototype = new Father() </span><br><span class="line">核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类</span><br><span class="line">特点：</span><br><span class="line">    解决了子类实例共享父类引用属性的问题</span><br><span class="line">    创建子类实例时，可以向父类传递参数</span><br><span class="line">    可以实现多继承（call多个父类对象）</span><br><span class="line">缺点：</span><br><span class="line">    实例并不是父类的实例，只是子类的实例</span><br><span class="line">    只能继承父类的实例属性和方法，不能继承原型属性/方法</span><br><span class="line">    无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</span><br></pre></td></tr></table></figure>

实例继承

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">核心：为父类实例添加新特性，作为子类实例返回</span><br><span class="line">特点：</span><br><span class="line">    不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果</span><br><span class="line">缺点：</span><br><span class="line">    实例是父类的实例，不是子类的实例</span><br><span class="line">    不支持多继承</span><br></pre></td></tr></table></figure>

拷贝继承

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">    支持多继承</span><br><span class="line">缺点：</span><br><span class="line">    效率较低，内存占用高（因为要拷贝父类的属性）</span><br></pre></td></tr></table></figure>

组合继承

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</span><br><span class="line">特点：</span><br><span class="line">    可以继承实例属性/方法，也可以继承原型属性/方法</span><br><span class="line">    既是子类的实例，也是父类的实例</span><br><span class="line">    不存在引用属性共享问题</span><br><span class="line">    可传参</span><br><span class="line">    函数可复用</span><br></pre></td></tr></table></figure>

寄生组合继承

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</span><br></pre></td></tr></table></figure>

## es6 继承 extends

（（通过 babel 将 es6 转换 es5））

extend 在实现继承方面，本质上也是原型链继承，不过相对于 es5 原有继承模式而言，多了一条原型链继承。

- 继承会首先在闭包里调用`_inherits(B, _A);`该方法实现了两步原
- 型链继承
  - `B.prototype = Object.create(A.prototype, &#123;constructor:&#123;value: B&#125;&#125;)`
  - `Object.setPrototypeOf(B, A)`；即将`B.__proto__ =A`
- 然后在构造函数里进行初始化操作
  - 首先调用`_classCallCheck`来阻止直接函数调用，原理通过判断当前 this 是否是 A 的实例（这个是 class 定义函数的限制，不是 extend 的限制）
  - 调用`_this = _possibleConstructorReturn(this, _getPrototypeOf(B).call(this, age))`；\_getPrototypeOf(B)相当于 A;此句相当于调用了 A 的构造函数；所以上面第二处原型链`B.__proto__ =A`就得到了体现
  - 调用`_createClass`为子类原型添加自定义方法
- 以上是普通函数继承，如果要是继承系统对象，比如说 Date，在第一步\_A 是又另外包了一层的内部函数 WrapperClass。`WrapperClass.prototype.__proto__`指向`Date.prototype`。A 子构造函数返回的是 Date 的对象 b，b 的原型指向 WrapperClass

## b 对象继承 a 对象,可以把 a 的属性继承过来吗

可以

# 事件轮询循环 Event Loop

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Event Loop 即事件循环</span><br><span class="line">是指浏览器或者Node的一种解决JavaScript单线程运行时不阻塞的一种机制，单线程的是所有任务都在主线程上完成,任务太多的时候,页面卡死,eventLoop可以解决单线程阻塞问题,程序中会有两个线程,一个主线程,一个eventLoop线程,负责主线程和其他进程之间的通信,遇到I/O的时候,主线程会让eventLoop线程通知对应的程序,主线程的任务会继续往后执行,等I/O程序执行完了,eventLoop线程会把结果返回给主线程,主线程利用回调函数调用结果,完成任务</span><br><span class="line">（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</span><br><span class="line">（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</span><br><span class="line">（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</span><br><span class="line">（4）主线程不断重复上面的第三步。</span><br><span class="line">运行机制</span><br><span class="line">浏览器首先会执行全局Script同步代码，清空调用栈</span><br><span class="line">JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。</span><br><span class="line">1.执行栈在执行完同步任务后，查看执行栈是否为空，如果执行栈为空</span><br><span class="line">2.就会去执行Task（宏任务），宏任务执行完毕后</span><br><span class="line">3.检查微任务(microTask)队列是否为空，如果不为空的话，会按照先入先出的规则全部执行完微任务(microTask)后，设置微任务(microTask)队列为null，然后再执行宏任务，如此循环。</span><br><span class="line">宏任务和微任务的执行顺序</span><br><span class="line">    一次事件循环中，先执行宏任务队列里的一个任务，再把微任务队列里的所有任务执行完毕，再去宏任务队列取下一个宏任务执行。</span><br><span class="line">    宏任务主要包含：script( 整体代码)、setTimeout、setInterval、I/O、UI 交互事件、setImmediate(Node.js 环境)</span><br><span class="line">    微任务主要包含：Promise、MutaionObserver、process.nextTick(Node.js 环境)</span><br></pre></td></tr></table></figure>

调用栈（执行上下文）--&gt;WEB API--&gt;任务队列（宏任务队列，微任务队列）
提升

宏任务：整体 script 代码，settimeout，setinterval，I/O，setImmediate

微任务：promise.then(catch,finally)，process.nextTick，MutationObserver，await 下面的代码也是

## 事件轮询自己理解

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">把不能一次性执行的嵌套在函数内部的这个代码放入调用栈，执行栈这边先执行同步队列，然后执行所有异步队列的微任务</span><br><span class="line">（（（（.then(当成功时可以使用.then()   第二个参数，失败的回调，失败时可以使用.catch()，不管状态如何都执行的操作.finally()</span><br></pre></td></tr></table></figure>

)），然后再执行异步队列的宏任务（定时器），再然后就是把调用栈里面的代码拿出来再执行一次上面的操作。

## setTimeout 和 promise 的执行顺序

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise比setTimeout()先执行。</span><br><span class="line">因为Promise定义之后便会立即执行，其后的.then()是异步里面的微任务。</span><br><span class="line">而setTimeout()是异步的宏任务。</span><br></pre></td></tr></table></figure>

## **宏任务和微任务**

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">js 是单线程执行的，js中的任务按顺序一个一个的执行，但是一个任务耗时太长，那么后面的任务就需要等待，为了解决这种情况，将任务分为了同步任务和异步任务，而异步任务又可以分为微任务和宏任务</span><br><span class="line">概念</span><br><span class="line">1.宏任务：当前调用栈中执行的代码成为宏任务。（主代码快，定时器等等）。</span><br><span class="line">2.微任务：当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务,可以理解为回调事件。（promise.then，proness.nextTick等等）。</span><br><span class="line">3.宏任务中的事件放在callback queue中，由事件触发线程维护；微任务的事件放在微任务队列中，由js引擎线程维护。</span><br><span class="line">运行机制</span><br><span class="line">1. 在执行栈中执行一个宏任务。</span><br><span class="line">2. 执行过程中遇到微任务，将微任务添加到微任务队列中。</span><br><span class="line">3. 当前宏任务执行完毕，立即执行微任务队列中的任务。</span><br><span class="line">4. 当前微任务队列中的任务执行完毕，检查渲染，GUI线程接管渲染。</span><br><span class="line">5. 渲染完毕后，js线程接管，开启下一次事件循环，执行下一次宏任务（事件队列中取）。</span><br><span class="line">微任务：process.nextTick、MutationObserver、Promise.then catch finally</span><br><span class="line">宏任务：I/O、setTimeout、setInterval、setImmediate、requestAnimationFrame</span><br><span class="line">js执行顺序，（先执行宏任务列，微任务队列）</span><br><span class="line">先同步再异步，在此基础上先宏任务再微任务</span><br><span class="line">流程：</span><br><span class="line">    同步和异步任务分别进入不同的执行“场所”，同步进入主线程，异步进入Event Table并注册函数。当指定的事情完成时，Event Table会将这个函数移入Event Queue。主线程内的任务执行完毕为空，回去了Event Queue读取对应的函数，进入主线程。</span><br><span class="line">    上述过程会不断重复，也就是常说的Event Loop（事件循环）。</span><br><span class="line">    但是，JS异步还有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入event queue，然后再执行微任务，将微任务放入eventqueue，但是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回调函数，然后再从宏任务的queue拿宏任务的回调函数。</span><br></pre></td></tr></table></figure>

# New 操作符过程

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 创建一个空对象</span><br><span class="line">2. 继承了该函数的原型,属性和方法被加入到 this 引用的对象中</span><br><span class="line">3. 绑定 this</span><br><span class="line">4. 返回新对象</span><br></pre></td></tr></table></figure>

# 堆和栈

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">栈：存放基本类型的值和引用类型的地址 (速度快，空间小)</span><br><span class="line">堆：存放引用类型的值。(速度慢，空间大)</span><br><span class="line">1、栈--基本类型值传递</span><br><span class="line">    栈——自动分配内存空间，系统自动释放，先进后出</span><br><span class="line">    基本类型: Undefined、Null、Boolean、Number 和 String, Symbol(ES6新增)</span><br><span class="line">    访问方法: 按值访问, 直接操作内存中的</span><br><span class="line">2、堆——引用类型地址传递</span><br><span class="line">    堆：动态分配的内存，大小不定，不会自动释放。存放引用类型的值，先进先出</span><br><span class="line">    引用类型: Object(Arrary, Date, Math,Function, Object)</span><br><span class="line">    访问方法: JS不能直接访问内存中的值, 只能操作对象的地址, 所以产生深/浅拷贝问题</span><br></pre></td></tr></table></figure>

# 事件

## 事件监听

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用addEventListener(&#x27;事件类型&#x27;，&#x27;触发后调用的函数&#x27;，&#x27;false默认冒泡，true捕获&#x27;)</span><br><span class="line">冒泡中，内部元素先被触发，然后再触发外部元素，</span><br><span class="line">捕获中，外部元素先被触发，在触发内部元素，</span><br></pre></td></tr></table></figure>

## 事件触发三阶段

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- window 往事件触发处传播，遇到注册的捕获事件会触发</span><br><span class="line">- 传播到事件触发处时触发注册的事件</span><br><span class="line">- 从事件触发处往 window 传播，遇到注册的冒泡事件会触发</span><br></pre></td></tr></table></figure>

注册事件

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">通常我们使用 addEventListener 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false 。useCapture 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性</span><br><span class="line">​</span><br><span class="line">- capture，布尔值，和 useCapture 作用一样</span><br><span class="line">- once，布尔值，值为 true 表示该回调只会调用一次，调用后会移除监听</span><br><span class="line">- passive，布尔值，表示永远不会调用 preventDefault</span><br><span class="line">​</span><br><span class="line">一般来说，我们只希望事件只触发在目标上，这时候可以使用 stopPropagation 来阻止事件的进一步传播。通常我们认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。stopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。</span><br></pre></td></tr></table></figure>

事件代理

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上</span><br><span class="line">&lt;ul id=&quot;ul&quot;&gt;</span><br><span class="line">  &lt;li&gt;1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;2&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;3&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;4&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;5&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  let ul = document.querySelector(&#x27;##ul&#x27;)</span><br><span class="line">  ul.addEventListener(&#x27;click&#x27;, event =&gt; &#123;</span><br><span class="line">    console.log(event.target)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">事件代理的方式相对于直接给目标注册事件来说，有以下优点</span><br><span class="line">​</span><br><span class="line">- 节省内存</span><br><span class="line">- 不需要给子节点注销事件</span><br></pre></td></tr></table></figure>

## 三种事件模型

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">事件 是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。</span><br><span class="line">DOM0级模型：</span><br><span class="line">    这种模型不会传播，所以没有事件流的概念，同元素 绑定多个事件，只会绑定最后一次的事件，前面的会被覆盖。</span><br><span class="line">IE 事件模型：</span><br><span class="line">    在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。</span><br><span class="line">    事件处理阶段会首先执行目标元素绑定的监听事件。</span><br><span class="line">    然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，</span><br><span class="line">    依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</span><br><span class="line">    这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，</span><br><span class="line">    会按顺序依次执行。detachEvent删除事件</span><br><span class="line">DOM2 级事件模型：</span><br><span class="line">    在该事件模型中，一次事件共有三个过程，</span><br><span class="line">    第一个过程是事件捕获阶段事件处理阶段，和事件冒泡阶段。</span><br><span class="line">    捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，</span><br><span class="line">    如果有则执行。。</span><br><span class="line">    这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</span><br><span class="line">    取消事件removeEventListener</span><br></pre></td></tr></table></figure>

## 事件委托(代理)

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">本质上是利用了事件冒泡的机制。</span><br><span class="line">并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，</span><br><span class="line">由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托</span><br><span class="line">支持为同一个DOM元素注册多个同类型事件，可将事件分成事件捕获和事件冒泡机制</span><br></pre></td></tr></table></figure>

## 利用冒泡判断是内层那个元素触发事件：用 e.target 去判断，去找到这个冒泡的元素

event.target 可以捕获当前事件作用的对象，如 event.srcElement.tagName 可以捕获活动标记名称。找到当前事件源

## 事件传播

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">事件传播有三个阶段：</span><br><span class="line">捕获阶段–事件从 window 开始，然后向下到每个元素，直到到达目标元素事件或event.target。</span><br><span class="line">目标阶段–事件已达到目标元素。</span><br><span class="line">冒泡阶段–事件从目标元素冒泡，然后上升到每个元素，直到到达 window。</span><br><span class="line">什么是事件捕获</span><br><span class="line">当事件发生在 DOM 元素上时，该事件并不完全发生在那个元素上。在捕获阶段，事件从window开始，一直到触发事件的元素。</span><br><span class="line">什么是事件冒泡？</span><br><span class="line">事件冒泡刚好与事件捕获相反，当前元素----&gt;body ----&gt; html----&gt;document ----&gt;window。当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在冒泡阶段，事件冒泡，或者事件发生在它的父代，祖父母，祖父母的父代，直到到达window为止。</span><br></pre></td></tr></table></figure>

# 阻止冒泡和取消默认事件(默认行为)

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">防止事件捕获和冒泡:</span><br><span class="line">w3c的方法是e.stopPropagation()</span><br><span class="line">IE则是使用e.cancelBubble = true</span><br><span class="line">取消默认事件</span><br><span class="line">w3c的方法是e.preventDefault()</span><br><span class="line">IE则是使用e.returnValue = false</span><br><span class="line">jQuery用法</span><br><span class="line">阻止默认事件 return false (不停止冒泡)</span><br></pre></td></tr></table></figure>

# 模块化

## 模块化开发的理解

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.可以避免命名冲突</span><br><span class="line">  一个模块内的命名随自己起，和外界不会冲突，对外的永远是你exports出来的内容。</span><br><span class="line">2.代码重用</span><br><span class="line">  把可复用代码抽取出function（再通用点会抽象出类，也就是构造函数），独立文件，一般模块化都有缓存机制，在二次调用时无需再解析，直接获取到缓存模块内容。</span><br><span class="line">3.模块化能让自己思路更为清晰，降低代码耦合</span><br><span class="line">  公共模块除了避免重复造轮子的痛苦外，也避免了逻辑混淆</span><br></pre></td></tr></table></figure>

## js 中现在比较成熟的有四种模块加载方案：

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</span><br><span class="line">第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。</span><br><span class="line">第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。</span><br><span class="line">第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导</span><br></pre></td></tr></table></figure>

## ES6 模块与 CommonJS 模块、AMD、CMD 的差异

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.CommonJS 模块输出的是一个值的拷贝，</span><br><span class="line">ES6 模块输出的是值的引用。</span><br><span class="line">ES6是在 JS 脚本进行静态分析的时候 ，遇到模块加载命令import 的时候 ，会自动生成一个引用， 当遇到模块需要用到加载的时候，会用这个值的引用在模块中进行查找数据以及对象的值和方法 </span><br><span class="line">commonjs  是在需要加载模块的时候，会自动生成一个对象，当脚本真正需要执行的时候 会直接在生成的对象中进行查找数值以及方法，这种加载称为“运行时加载”。</span><br><span class="line">AMD是“前置依赖”执行，依赖的是require.js</span><br><span class="line">CMD是采用的是“sea.js”推崇的是就近依赖执行</span><br><span class="line">而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</span><br></pre></td></tr></table></figure>

# requireJS 的核心原理

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数</span><br></pre></td></tr></table></figure>

# 面向对象

面向对象是一个思想，把事物抽象成对象，对象中有属性和方法。

特点：

1.抽象——把核心的提出来用于解决问题；

2.封装——不用考虑内部，只考虑功能使用，保护内部代码，提供 api 接口；

3.继承——为了代码的复用率高，将父类的一些属性或方法作用在子类上；

4.多态——不同对象做同一操作有不同效果

组成：

1.属性——状态，静态的；

2.方法——过程，动态的

this 指向：谁调用就是谁

# node.js

五大核心：http 模块，events 事件机制，process 全局对象，file system 文件访问系统，stream 常用工具

# 正则表达式

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\d 匹配数字  \D 匹配非数字  \w 匹配数字字母下划线 \W 匹配非数字字母下划线</span><br><span class="line">\n 匹配一个换行符 \s 匹配任何不可见字符包括空格、制表符、换页符等等  \S 匹配任何可见字符</span><br><span class="line">^ 匹配输入字行首   $匹配输入行尾 *(0到多次)匹配前面的子表达式任意次</span><br><span class="line">+(1到多) 匹配前面的子表达式一次或多次(大于等于1次）</span><br><span class="line">?(0或1)匹配前面的子表达式零次或一次</span><br><span class="line">&#123;n&#125;n是一个非负整数，匹配确定的n次</span><br><span class="line">&#123;n,&#125;n是一个非负整数。至少匹配n次</span><br></pre></td></tr></table></figure>

# JS 兼容

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#关于获取滚动条时,出现的兼容问题</span><br><span class="line">        Var scrollTop = document.documentElment.scrollTop || document.body.scrollTop</span><br><span class="line">​</span><br><span class="line"># 获取非行内样式的兼容方式</span><br><span class="line">function getStyle(obj,attr)&#123;  //获取非行间样式，obj是对象，attr是值</span><br><span class="line">     if(obj.currentStyle)&#123;                //针对ie获取非行间样式</span><br><span class="line">          return obj.currentStyle[attr];</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">          return getComputedStyle(obj,false)[attr];   //针对非ie</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"># 获取事件对象</span><br><span class="line">document.onclick=function(eve)&#123;</span><br><span class="line">        var e=eve||window.event;</span><br><span class="line">        console.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">#阻止事件冒泡</span><br><span class="line">function stopBubble(e)&#123;</span><br><span class="line">        if(e.stopPropagation)&#123;</span><br><span class="line">            e.stopPropagation();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            e.cancelBubble = true;//兼容ie</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#阻止浏览器默认行为</span><br><span class="line">    if( e.preventDefault )&#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        window.event.returnValue = false;//ie</span><br><span class="line">    &#125;</span><br><span class="line">#事件委托</span><br><span class="line">var oul = document.querySelector(&quot;ul&quot;)</span><br><span class="line">    oul.onclick = function(eve)&#123;</span><br><span class="line">        var e = eve || window.event;</span><br><span class="line">        var t = e.target || e.srcElement;</span><br><span class="line">        if(t.getAttribute(&quot;abc&quot;) == &quot;l&quot;)&#123;</span><br><span class="line">            console.log(e.target.innerHTML)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">#键盘事件的兼容方法</span><br><span class="line">var eve = eve||window.event;</span><br><span class="line">var keyC = eve.keyCode||eve.which;</span><br></pre></td></tr></table></figure>

# js 延迟加载的方式

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。</span><br><span class="line">我了解到的几种方式是：</span><br><span class="line">1、将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</span><br><span class="line">2、给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</span><br><span class="line">3、给 js 脚本添加 async属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</span><br><span class="line">4、动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</span><br></pre></td></tr></table></figure>

# js 的原理(运行机制)

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">首先js是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。</span><br><span class="line">在执行同步代码的时候，如果遇到了异步事件，js引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务</span><br><span class="line">所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。</span><br><span class="line">同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</span><br><span class="line">异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有等主线程任务执行完毕，&quot;任务队列&quot;开始通知主线程，请求执行任务，该任务才会进入主线程执行。</span><br><span class="line">当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。</span><br><span class="line">任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。</span><br><span class="line">当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</span><br><span class="line">异步运行机制如下：</span><br><span class="line">（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</span><br><span class="line">（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。</span><br><span class="line">    只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</span><br><span class="line">（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。</span><br><span class="line">    那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</span><br><span class="line">（4）主线程不断重复上面的第三步。</span><br></pre></td></tr></table></figure>

# arguments 的对象

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arguments对象是函数中传递的参数值的集合。它是一个类似数组的对象，因为它有一个length属性，</span><br><span class="line">我们可以使用数组索引表示法arguments[1]来访问单个值，但它没有数组中的内置方法，</span><br><span class="line">如：forEach、reduce、filter和map。</span><br><span class="line">我们可以使用Array.prototype.slice将arguments对象转换成一个数组。</span><br><span class="line">Array.prototype.slice.call(arguments)</span><br></pre></td></tr></table></figure>

# ECMAScript(ES)

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ECMAScript 是编写脚本语言的标准，ECMA（European Computer Manufacturers Association）规定一下他的标准，因为当时有java语言了，又想强调这个东西是让ECMA这个人定的规则，所以就这样一个神奇的东西诞生了，这个东西的名称就叫做ECMAScript。</span><br><span class="line">javaScript = ECMAScript + DOM + BOM</span><br></pre></td></tr></table></figure>

# ES2016(ES7)新特性

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">求幂运算符（**）</span><br><span class="line">                (因颗录此)</span><br><span class="line">Array.prototype.includes()方法</span><br><span class="line">    数组原型的方法,查找一个数值是否在数组中，只能判断一些简单类型的数据，对于复杂类型的数据无法判断。</span><br><span class="line">    该方法接受两个参数，分别是查询的数据和初始的查询索引值。</span><br></pre></td></tr></table></figure>

# ES2017(ES8)新特性

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">async  await</span><br><span class="line">函数参数列表结尾允许逗号</span><br><span class="line">    es2017允许函数对象的定义调用时参数可以加入尾逗号，以及json对象array对象都允许</span><br><span class="line">Object.values()</span><br><span class="line">    values: [obj]，返回obj自身可枚举属性的属性值的集合</span><br><span class="line">       (安吹斯)</span><br><span class="line">Object.entries()</span><br><span class="line">    entries：[obj], 与values类似，返回的一个2元素的数组</span><br><span class="line">Object.getOwnPropertyDescriptors()</span><br><span class="line">    getOwnpropertyDescriptors: [obj]，返回obj对象的属性描述符</span><br><span class="line">    (get 哦 泼破踢 迪斯亏不踢斯)</span><br><span class="line">String padding:</span><br><span class="line">    padStart()和padEnd()，填充字符串达到当前长度</span><br><span class="line">    在字符串首位开始添加string直到满足length为止并返回新的字符串</span><br><span class="line">ShareArrayBuffer和Atomics对象，用于从共享内存位置读取和写入</span><br><span class="line">(夏尔 啊锐 八法儿)     (啊偷没此)</span><br></pre></td></tr></table></figure>

# ES2018(ES9)新特性

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">异步迭代</span><br><span class="line">Promise.finally()</span><br><span class="line">        (饭的嘞)</span><br><span class="line">Rest/Spread 属性</span><br><span class="line">(锐斯特)(斯破锐的)</span><br><span class="line">正则表达式命名捕获组（Regular Expression Named Capture Groups）</span><br><span class="line">正则表达式反向断言（lookbehind）</span><br><span class="line">正则表达式dotAll模式</span><br><span class="line">正则表达式 Unicode 转义</span><br><span class="line">         (右内扣的)</span><br><span class="line">非转义序列的模板字符串</span><br></pre></td></tr></table></figure>

# ES2019(ES10)新特性

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">行分隔符（U + 2028）和段分隔符（U + 2029）符号现在允许在字符串文字中，与JSON匹配</span><br><span class="line">更加友好的JSON.stringify</span><br><span class="line">新增了Array的flat()方法和flatMap()方法</span><br><span class="line">新增了String的trimStart()方法和trimEnd()方法</span><br><span class="line">Object.fromEntries()</span><br><span class="line">Symbol.prototype.description</span><br><span class="line">String.prototype.matchAll</span><br><span class="line">Function.prototype.toString()现在返回精确字符，包括空格和注释</span><br><span class="line">简化try&#123;&#125; catch&#123;&#125;,修改catch绑定</span><br><span class="line">新的基本数据类型BigInt</span><br><span class="line">globalThis</span><br><span class="line">import()</span><br><span class="line">Legacy RegEx</span><br><span class="line">私有的实例方法和访问器</span><br></pre></td></tr></table></figure>

# ES2020(ES11)新特性

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">私有变量</span><br><span class="line">    ES11在类中新增私有变量控制符#，在内部变量或者函数前添加一个hash符号#，</span><br><span class="line">    可以将它们设置为私有属性，只能在类的内部可以使用。</span><br><span class="line">空值合并运算符</span><br><span class="line">    空值合并操作符就是 ?? :如果左侧的值为null或者undefined就返回左侧的值，如果没有就返回右侧的值</span><br><span class="line">可选链操作符</span><br><span class="line">    可选链操作符 (?.) :如果左侧表达式有值，就会继续访问右侧的字段</span><br><span class="line">BigInt</span><br><span class="line">    使用BigInt的方式有两种：</span><br><span class="line">        1.在数字后面加n</span><br><span class="line">        2.使用BigInt函数</span><br><span class="line">动态导入</span><br><span class="line">globalThis</span><br><span class="line">    提供一种标准化的方式去访问全局对象，可以在任意上下文中获取全局对象自身，并且不用担心环境的问题</span><br><span class="line">Promise.all缺陷与Promise.allSettled</span><br><span class="line">    promise.all可以并发执行异步任务,如果其中某个任务执行出现了异常，所有任务都会over，Promise会直接进入reject状态</span><br><span class="line">    使用Promise.allSettled，它会创建一个新的promise，在所有promise完成后返回一个包含每个promise结果的数组</span><br></pre></td></tr></table></figure>

# 函数式编程

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数式编程（通常缩写为FP）是通过编写纯函数，避免共享状态、可变数据、副作用 来构建软件的过程。数式编程是声明式 的而不是命令式 的，应用程序的状态是通过纯函数流动的。与面向对象编程形成对比，面向对象中应用程序的状态通常与对象中的方法共享和共处。</span><br><span class="line">函数式编程是一种编程范式 ，这意味着它是一种基于一些基本的定义原则（如上所列）思考软件构建的方式。当然，编程范式的其他示例也包括面向对象编程和过程编程。</span><br><span class="line">函数式的代码往往比命令式或面向对象的代码更简洁，更可预测，更容易测试</span><br></pre></td></tr></table></figure>

# 为什么函数被称为一等公民

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在JavaScript中，函数不仅拥有一切传统函数的使用方式（声明和调用），而且可以做到像简单值一样:</span><br><span class="line">赋值（var func = function()&#123;&#125;）、</span><br><span class="line">传参(function func(x,callback)&#123;callback();&#125;)、</span><br><span class="line">返回(function()&#123;return function()&#123;&#125;&#125;)，</span><br><span class="line">这样的函数也称之为第一级函数（First-class Function）。不仅如此，JavaScript中的函数还充当了类的构造函数的作用，同时又是一个Function类的实例(instance)(因斯疼斯)。这样的多重身份让JavaScript的函数变得非常重要。</span><br></pre></td></tr></table></figure>

# 回调函数是什么？回调函数有什么缺点

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">回调函数是一个匿名函数，它作为一个参数传递给其他的代码，其作用是在需要的时候方便调用这段（回调函数）代码。可以让异步代码同步执行。</span><br><span class="line">回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）</span><br></pre></td></tr></table></figure>

# 设计模式

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。</span><br><span class="line">1、单例模式</span><br><span class="line">2、工厂模式</span><br><span class="line">3、观察者模式</span><br><span class="line">4、代理模式</span><br><span class="line">5、策略模式</span><br><span class="line">6、迭代器模式</span><br><span class="line">单例模式（Singleton Pattern）</span><br><span class="line">    单例模式中Class的实例个数最多为1。当需要一个对象去贯穿整个系统执行某些任务时，单例模式就派上了用场。而除此之外的场景尽量避免单例模式的使用，因为单例模式会引入全局状态，而一个健康的系统应该避免引入过多的全局状态。</span><br><span class="line">工厂模式</span><br><span class="line">    工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。</span><br><span class="line">使用场景：如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择</span><br><span class="line">class Product &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    init() &#123;</span><br><span class="line">        console.log(&#x27;init&#x27;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">class Factory &#123;</span><br><span class="line">    create(name) &#123;</span><br><span class="line">        return new Product(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// use</span><br><span class="line">let factory = new Factory()</span><br><span class="line">let p = factory.create(&#x27;p1&#x27;)</span><br><span class="line">p.init()</span><br><span class="line">https://juejin.im/post/6844904200917221389#heading-81</span><br></pre></td></tr></table></figure>

# &amp;&amp; 、||和!! 运算符

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp; 叫逻辑与，在其操作数中找到第一个虚值表达式并返回它，如果没有找到任何虚值表达式，则返回最后一个真值表达式。它采用短路来防止不必要的工作。</span><br><span class="line">|| 叫逻辑或，在其操作数中找到第一个真值表达式并返回它。这也使用了短路来防止不必要的工作。在支持 ES6 默认函数参数之前，它用于初始化函数中的默认参数值。</span><br><span class="line">!! 运算符可以将右侧的值强制转换为布尔值，这也是将值转换为布尔值的一种简单方法</span><br></pre></td></tr></table></figure>

# &#123;&#125;和[ ]的 valueOf 和 toString 的结果

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，toString 的结果为 &quot;[object Object]&quot;</span><br><span class="line">[] 的 valueOf 结果为 [] ，toString 的结果为 &quot;&quot;</span><br></pre></td></tr></table></figure>

# js 的作用域和作用域链

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">作用域：</span><br><span class="line">    作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。</span><br><span class="line">作用域链：</span><br><span class="line">    作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。</span><br><span class="line">    作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</span><br><span class="line">当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。</span><br></pre></td></tr></table></figure>

# js 创建对象的方式

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象创建方式，我了解到的方式有这么几种：</span><br><span class="line">（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</span><br><span class="line">（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</span><br><span class="line">（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</span><br><span class="line">（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</span><br><span class="line">（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</span><br><span class="line">（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</span><br></pre></td></tr></table></figure>

# 什么是 DOM 和 BOM

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DOM指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</span><br><span class="line">BOM指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。</span><br><span class="line">BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，</span><br><span class="line">又是一个 Global（全局）(歌楼波)对象。</span><br><span class="line">这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。</span><br><span class="line">window 对象含有 location 对象、navigator(那V给特)对象、screen(斯歌锐)对象等子对象，</span><br><span class="line">并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。。31、</span><br><span class="line">】】</span><br></pre></td></tr></table></figure>

# DOM 操作

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">（1）创建新节点</span><br><span class="line">     createDocumentFragment()    //创建一个DOM片段 (科瑞A特)(法歌们特)</span><br><span class="line">     createElement()             //创建一个具体的元素</span><br><span class="line">     createTextNode()            //创建一个文本节点</span><br><span class="line">（2）添加、移除、替换、插入</span><br><span class="line">    appendChild(node)</span><br><span class="line">    removeChild(node)</span><br><span class="line">    replaceChild(new,old) (锐普利斯)</span><br><span class="line">    insertBefore(new,old) (因色特比佛)</span><br><span class="line">（3）获取、查找</span><br><span class="line">    getElementById();</span><br><span class="line">    getElementsByName();</span><br><span class="line">    getElementsByTagName();</span><br><span class="line">    getElementsByClassName();</span><br><span class="line">    querySelector(); (斯来科特)</span><br><span class="line">    querySelectorAll();</span><br><span class="line">（4）属性操作</span><br><span class="line">    getAttribute(key); (去比又特)</span><br><span class="line">    setAttribute(key, value);</span><br><span class="line">    hasAttribute(key);</span><br><span class="line">    removeAttribute(key);</span><br></pre></td></tr></table></figure>

# 图片懒加载

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将页面里所有img属性src属性用data-xx代替，当页面滚动直至此图片出现在可视区域时，用js取到该图片的data-xx的值赋给src。</span><br></pre></td></tr></table></figure>

# constructor 与 class 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">传统的javascript中只有对象，没有类的概念。它是基于原型的面向对象语言。</span><br><span class="line">原型对象特点就是将自身的属性共享给新对象。</span><br><span class="line">ES6引入了Class（类）这个概念，通过class关键字可以定义类。</span><br><span class="line">该关键字的出现使得其在对象写法上更加清晰，更像是一种面向对象的语言</span><br><span class="line">constructor：</span><br><span class="line">constructor()方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。</span><br><span class="line">一个类必须有constructor()方法，如果没有显式定义，一个空的 constructor()方法会被默认添加。</span><br></pre></td></tr></table></figure>

# 构造函数与普通函数的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 返回值类型的区别：</span><br><span class="line">    构造函数是没有返回值类型的，</span><br><span class="line">    普通函数是有返回值类型的，即使函数没有返回值，返回值类型也要写上void。</span><br><span class="line">2. 函数名的区别：</span><br><span class="line">    构造函数的函数名必须要与类名一致，</span><br><span class="line">    普通函数的函数名只要符合标识符的命名规则即可。</span><br><span class="line">3. 调用方式的区别：</span><br><span class="line">    构造函数是在创建对象的时候由jvm调用的。</span><br><span class="line">    普通函数是由我们使用对象调用的，一个对象可以对象多次普通的函数，</span><br><span class="line">4. 作用上的区别：</span><br><span class="line">    构造函数的作用用于初始化一个对象。</span><br><span class="line">    普通函数是用于描述一类事物的公共行为的。</span><br></pre></td></tr></table></figure>

# Generator

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Generator 的中文名称是生成器，它是ECMAScript6中提供的新特性。</span><br><span class="line">在过去，封装一段运算逻辑的单元是函数。函数只存在“没有被调用”或者“被调用”的情况，</span><br><span class="line">不存在一个函数被执行之后还能暂停的情况，而Generator的出现让这种情况成为可能。</span><br><span class="line">通过 function* 来定义的函数称之为“生成器函数”（generator function），它的特点是可以中断函数的执行，</span><br><span class="line">每次执行yield语句之后，函数即暂停执行，直到调用返回的生成器对象的next()函数它才会继续执行。</span><br><span class="line">也就是说 Generator 函数是一个状态机，封装了多个内部状态。</span><br><span class="line">执行 Generator 函数返回一个遍历器对象（一个指向内部状态的指针对象），</span><br><span class="line">调用遍历器对象的next方法，使得指针移向下一个状态。每次调用next方法，</span><br><span class="line">内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。</span><br><span class="line">yield关键字</span><br><span class="line">真正让Generator具有价值的是yield关键字，这个yield关键字让 Generator内部的逻辑能够切割成多个部分。</span><br><span class="line">发现函数执行到第一个yield关键字的时候就停止了。要让业务逻辑继续执行完，需要反复调用.next()</span><br><span class="line">可以简单地理解为yield关键字将程序逻辑划分成几部分，每次.next()执行时执行一部分。</span><br><span class="line">这使得程序的执行单元再也不是函数，复杂的逻辑可以通过yield来暂停。</span><br><span class="line">.next()调用时，返回一个对象，这个对象具备两个属性。</span><br><span class="line">其中一个属性是布尔型的done。它表示这个Generator对象的逻辑块是否执行完成。</span><br><span class="line">另一个属性是value，它来自于yield语句后的表达式的结果。</span><br><span class="line">通过.next()传递参数，可以赋值给yield关键字前面的变量声明。</span><br></pre></td></tr></table></figure>

# 表单只能输入数字

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正则   type number</span><br></pre></td></tr></table></figure>

# Proxy

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”</span><br></pre></td></tr></table></figure>

## Proxy 和 Reflect

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Proxy用于修改某些操作的默认行为，即对编程语言层面进行修改，属于“元编程”，Proxy意思为“代理”，即在访问对象之前建立一道“拦截”，任何访问该对象的操作之前都会通过这道“拦截”，即执行Proxy里面定义的方法</span><br><span class="line">let pro = new Proxy(target,handler)</span><br><span class="line">其中 new Proxy相当于创建了一个Proxy实例，target为所要拦截的目标对象，handler也是一个对象，里面定义的是对拦截对象所要进行的拦截方法</span><br><span class="line">Proxy也可以作为其他对象的原型对象使用</span><br><span class="line">上述实例将pro作为obj的原型对象使用，虽然obj本身没有name这个属性，但是根据原型链，会在pro上读取到name属性，之后会执行相对应的拦截操作。</span><br><span class="line">let pro = new Proxy(target,handler);</span><br><span class="line">let obj = Object.create(pro);</span><br></pre></td></tr></table></figure>

## Proxy 常用的拦截方法

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">get(target,name,property)方法</span><br><span class="line">用于拦截某个读取属性的操作,第一个参数为目标对象，第二个参数为属性名称，第三个属性为操作所针对的对象（可选参数）</span><br><span class="line">set(target,name,value,property)</span><br><span class="line">用于拦截某个属性的赋值操作，第一个参数为目标对象，第二个参数为属性名，第三个参数为属性值，第四个参数为操作行为所针对的对象（可选参数）</span><br><span class="line">has(target,key)</span><br><span class="line">用来拦截对象是否具有某个属性值的操作，第一个参数为目标对象，第二个参数为属性名</span><br><span class="line">Reflect(锐付莱克特)对象:</span><br><span class="line">Reflect设计的目的是为了优化Object的一些操作方法以及合理的返回Object操作返回的结果，对于一些命令式的Object行为，Reflect对象可以将其变为函数式的行为</span><br><span class="line">Reflect(target,name,property)  Reflect.has(obj,&quot;name&quot;)  Reflect.get(target,name,property)</span><br></pre></td></tr></table></figure>

# 请求头

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Accept(艾可塞克特)</span><br><span class="line">告诉WEB服务器自己接受什么介质类型，*/* 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。</span><br><span class="line">　　</span><br><span class="line">Accept-Charset(恰斯特)</span><br><span class="line">浏览器告诉服务器自己能接收的字符集。</span><br><span class="line">Accept-Encoding(因扣定)</span><br><span class="line">浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）</span><br><span class="line">Accept-Language</span><br><span class="line">浏览器申明自己接收的语言。语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。</span><br><span class="line">　　</span><br><span class="line">Authorization(哦瑟惹C逊)</span><br><span class="line">当客户端接收到来自WEB服务器的 WWW-Authenticate 响应时，用该头部来回应自己的身份验证信息给WEB服务器。</span><br><span class="line">　　</span><br><span class="line">If-Match</span><br><span class="line">如果对象的 ETag 没有改变，其实也就意味著对象没有改变，才执行请求的动作，获取文档。</span><br><span class="line">If-None-Match</span><br><span class="line">如果对象的 ETag 改变了，其实也就意味著对象也改变了，才执行请求的动作，获取文档。</span><br><span class="line">   (莫得反得)</span><br><span class="line">If-Modified-Since(森恩斯)</span><br><span class="line">如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作（比如返回对象），否则返回代码304，告诉浏览器该对象没有修改。例如：If-Modified-Since：Thu, 10 Apr 2008 09:14:42 GMT</span><br><span class="line">If-Unmodified-Since</span><br><span class="line">如果请求的对象在该头部指定的时间之后没修改过，才执行请求的动作（比如返回对象）。</span><br><span class="line">If-Range /reinge/</span><br><span class="line">浏览器告诉 WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分给我，如果对象改变了，就把整个对象给我。浏览器通过发送请求对象的ETag 或者自己所知道的最后修改时间给 WEB 服务器，让其判断对象是否改变了。总是跟 Range 头部一起使用。</span><br><span class="line">Range</span><br><span class="line">浏览器（比如 Flashget 多线程下载时）告诉 WEB 服务器自己想取对象的哪部分。例如：Range: bytes=1173546</span><br><span class="line">Proxy-Authenticate(噢三特K特)</span><br><span class="line">代理服务器响应浏览器，要求其提供代理身份验证信息。</span><br><span class="line">Proxy-Authorization</span><br><span class="line">浏览器响应代理服务器的身份验证请求，提供自己的身份信息。</span><br><span class="line">Host</span><br><span class="line">客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。如Host：rss.sina.com.cn</span><br><span class="line">Referer(锐佛尔)</span><br><span class="line">浏览器向WEB 服务器表明自己是从哪个网页URL获得点击当前请求中的网址/URL，</span><br><span class="line">例如：Referer：http://www.ecdoer.com/</span><br><span class="line">User-Agent(A就特)</span><br><span class="line">浏览器表明自己的身份（是哪种浏览器）。</span><br><span class="line">例如：User-Agent：Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN;rv:1.8.1.14) Gecko/20080404 Firefox/2.0.0.14</span><br></pre></td></tr></table></figure>

# static 有什么特性

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new出来一个实例对象是否带有static属性   static用ES5怎么写</span><br><span class="line">没有创建对象，也能使用属性和调用方法</span><br><span class="line">用来形成静态代码块以优化程序性能。因为只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</span><br><span class="line">static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次</span><br><span class="line">被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。</span><br><span class="line">类第一次加载初始化的时候就去加载static部分,后面可以重新赋值</span><br><span class="line">static用ES5怎么写: 静态是通过类名直接调用 class A staticB</span><br><span class="line">直接用A.B    将B绑定在A上</span><br></pre></td></tr></table></figure>

#

# class 中 super 作用是什么

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">es5 的继承是先创建子类的this，然后将父类的方法添加到子类的this上去；</span><br><span class="line">es6 的继承是创建父类的this对象，然后再对this对象添加方法/属性。</span><br><span class="line">而super方法就是用来创建父类this对象的。</span><br><span class="line">实际上执行的是 super.sport.call(this);</span><br></pre></td></tr></table></figure>

# xss 攻击和 csrf 攻击是什么

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1、CSRF（Cross-site request forgery）：跨站请求伪造。</span><br><span class="line">（1）登录受信任网站A，并在本地生成Cookie。</span><br><span class="line">    （如果用户没有登录网站A，那么网站B在诱导的时候，请求网站A的api  接口时，会提示你登录）</span><br><span class="line">（2）在不登出A的情况下，访问危险网站B（其实是利用了网站A的漏洞）</span><br><span class="line">CSRF如何防御</span><br><span class="line">方法一: Token 验证：（用的最多）</span><br><span class="line">    （1）服务器发送给客户端一个token；</span><br><span class="line">    （2）客户端提交的表单中带着这个token。</span><br><span class="line">    （3）如果这个 token 不合法，那么服务器拒绝这个请求。</span><br><span class="line">方法二: 隐藏令牌：</span><br><span class="line">    把 token 隐藏在 http 的 head头中。</span><br><span class="line">    方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。</span><br><span class="line">方法三: Referer(锐服尔) 验证：</span><br><span class="line">    Referer 指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截。</span><br><span class="line">2、XSS（Cross Site Scripting）：跨域脚本攻击。</span><br><span class="line">XSS攻击的核心原理是：</span><br><span class="line">    不需要你做任何的登录认证，它会通过合法的操作（比如在url中输入、在评论框中输入），</span><br><span class="line">    向你的页面注入脚本（可能是js、hmtl代码块等）。</span><br><span class="line">最后导致的结果可能是：</span><br><span class="line">    盗用Cookie破坏页面的正常结构，插入广告等恶意内容D-doss攻击</span><br><span class="line"></span><br><span class="line">XSS的攻击方式</span><br><span class="line">1、反射型</span><br><span class="line">    发出请求时，XSS代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，</span><br><span class="line">    XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS。</span><br><span class="line">2、存储型存</span><br><span class="line">    储型XSS和反射型XSS的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），</span><br><span class="line">    下次请求时目标页面时不用再提交XSS代码。</span><br><span class="line">XSS的防范措施（encode + 过滤）主要有三个：</span><br><span class="line">1、编码：</span><br><span class="line">    对用户输入的数据进行HTML Entity(安特踢) 编码。</span><br><span class="line">2、过滤：</span><br><span class="line">    移除用户输入的和事件相关的属性。如onerror可以自动触发攻击，还有onclick等。</span><br><span class="line">    （总而言是，过滤掉一些不安全的内容）移除用户输入的Style节点、Script节点、Iframe节点。</span><br><span class="line">    （尤其是Script节点，它可是支持跨域的呀，一定要移除）。</span><br><span class="line">3、校正</span><br><span class="line">    避免直接对HTML Entity进行解码。</span><br><span class="line">    使用DOM Parse转换，校正不配对的DOM标签。</span><br><span class="line">        这个概念，它的作用是把文本解析成DOM结构。</span><br><span class="line">        比较常用的做法是，通过第一步的编码转成文本，然后第三步转成DOM对象，然后经过第二步的过滤。</span><br><span class="line">    还有一种简洁的答案：</span><br><span class="line">    首先是encode，如果是富文本，就白名单。</span><br><span class="line">3、CSRF 和 XSS 的区别:</span><br><span class="line">区别一：</span><br><span class="line">    CSRF：需要用户先登录网站A，获取 cookie。</span><br><span class="line">    XSS：不需要登录。</span><br><span class="line">区别二：（原理的区别）</span><br><span class="line">    CSRF：是利用网站A本身的漏洞，去请求网站A的api。</span><br><span class="line">    XSS：是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。</span><br></pre></td></tr></table></figure>

# location 有哪些属性

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 完整的url</span><br><span class="line">location.href</span><br><span class="line">// 当前URL的协议，包括 :; 比如 https:</span><br><span class="line">location.protocol</span><br><span class="line">/* 主机名和端口号，如果端口号是80(http)或443(https), 那就会省略端口号，比兔 www.baidu.com:8080 */</span><br><span class="line">location.host</span><br><span class="line">// 主机名：比如：www.baidu.com</span><br><span class="line">location.hostname</span><br><span class="line">// 端口号；比如8080</span><br><span class="line">location.port</span><br><span class="line">// url的路径部分，从 / 开始; 比如 https://www.baidu.com/s?ie=utf-8，那么 pathname = &#x27;/s&#x27;了</span><br><span class="line">location.pathname</span><br><span class="line">// 查询参数，从?开始；比如 https://www.baidu.com/s?ie=utf-8 那么 search = &#x27;?ie=utf-8&#x27;</span><br><span class="line">location.search</span><br><span class="line">// hash是页面中的一个片段，从 # 开始的，比如 https://www.baidu.com/#/a/b 那么返回值就是：&quot;#/a/b&quot;</span><br><span class="line">location.hash</span><br></pre></td></tr></table></figure>

## ajax 请求的五个步骤

1.创建一个 XMLHttpRequest 异步对象

2.设置请求方式和请求地址

3.接着，用 send 发送请求

4.监听状态变化

5.最后，接收返回的数据

varxmlHttp =newXMLHttpRequest();

functionCommentAll() &#123;

_//第二步，注册回调函数_

xmlHttp.onreadystatechange =callback1;

_//&#123;_

_// if (xmlHttp.readyState == 4)_

_// if (xmlHttp.status == 200) &#123;_

_// var responseText = xmlHttp.responseText;_

_// &#125;_

_//&#125;_

_//第三步，配置请求信息，open(),get_

_//get 请求下参数加在 url 后，.ashx?methodName = GetAllComment&amp;str1=str1&amp;str2=str2_

xmlHttp.open(&quot;post&quot;,&quot;/ashx/myzhuye/Detail.ashx?methodName=GetAllComment&quot;,true);

_//post 请求下需要配置请求头信息_

_//xmlHttp.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);_

_//第四步，发送请求,post 请求下，要传递的参数放这_

xmlHttp.send(&quot;methodName = GetAllComment&amp;str1=str1&amp;str2=str2&quot;);_//&quot;_

&#125;

_//第五步，创建回调函数_

functioncallback1() &#123;

if(xmlHttp.readyState ==4)

if(xmlHttp.status ==200) &#123;

_//取得返回的数据_

vardata = xmlHttp.responseText;

_//json 字符串转为 json 格式_

data =eval(data);

$.each(data,

function(i, v) &#123;

alert(v);

&#125;);

&#125;

&#125;

## 代码规范：

1.代码缩进两个制表符

2.代码应该简洁易懂，逻辑清晰。能写简单就简单，不要追求技术，这样大家都能看懂，bug 也更容易找到

3.程序已修改，比如说一个 less 里面的一个主题颜色的变量，一改全改，就不需要一个个去修改

然后就是复用方面，一样的代码，一样的方法可以封装成函数给大家共用，就调用同一个方法就可以了，减少代码量，不会有很多定义函数的名字。

# 暂时性死区

let 和 const 不存在变量提升，初始化的时候

# CSdn

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">React面试题正文：</span><br><span class="line">React的特点和关键版本区别。</span><br><span class="line">答案：React的特定及缺点以及关键版本介绍</span><br><span class="line">请讲讲react的this.setState()方法</span><br><span class="line">答案：React的this.setState详细介绍</span><br><span class="line">为什么this.setState是异步的？</span><br><span class="line">答案：https://blog.csdn.net/weixin_43606158/article/details/100572101</span><br><span class="line">React的ref是干嘛的？怎么创建ref？</span><br><span class="line">答案：React函数组件和类组件创建ref及其常用场景讲解</span><br><span class="line">你知道的React生命周期有哪些？分别都是用来做什么的？</span><br><span class="line">答案：React的生命周期钩子函数详细介绍</span><br><span class="line">React运用了什么算法？你有了解过这个算法么？</span><br><span class="line">答案：React的diff算法解析，React的fiber算法解析</span><br><span class="line">如何提高React框架的性能？</span><br><span class="line">答案：React详细介绍性能优化的方法</span><br><span class="line">React创建组件有几种方式？</span><br><span class="line">答案：React创建组件的3种方式介绍</span><br><span class="line">你开发React的时候用过哪些UI框架并讲一下他们的设计理念？</span><br><span class="line">答案： 有很多，请自行百度</span><br><span class="line">请讲讲React的组件的概念。</span><br><span class="line">答案：React之组件介绍</span><br><span class="line">你知道JSX么？请简要讲述一下。</span><br><span class="line">答案：JSX浅析</span><br><span class="line">你的react项目当中用过哪些插件？</span><br><span class="line">答案：React实际项目常用插件</span><br><span class="line">React父子组件传参是通过什么方式？</span><br><span class="line">答案：React父子组件传参</span><br><span class="line">你知道React的虚拟DOM么？为什么虚拟DOM会提升性能？</span><br><span class="line">答案：React虚拟DOM的机制特点</span><br><span class="line">当使用F5刷新页面的时候会经过react的哪些生命周期？</span><br><span class="line">答案：与渲染页面的时候走的是一样的</span><br><span class="line">你用过Redux么？请讲一下Redux的特点。</span><br><span class="line">答案：Redux核心知识</span><br><span class="line">请讲一下react-router。</span><br><span class="line">答案：React-router详细介绍</span><br><span class="line">你了解react-hook么？</span><br><span class="line">答案：了解react-hook以及State Hook</span><br><span class="line">React Hook之Effect Hook</span><br><span class="line">React Hook之useContext的介绍与使用</span><br><span class="line">React Hooks相对高阶组件和Class组件有什么优势/缺点？</span><br><span class="line">react做路由跳转的方法你知道哪些？</span><br><span class="line">答案：React做路由跳转</span><br><span class="line">webpack中，是借助loader完成的JSX代码转换还是babel？</span><br><span class="line">答案：借助了babel的 preset-react</span><br><span class="line">调用setState后，发生了什么？</span><br><span class="line">答案：</span><br><span class="line">分为俩种情况：</span><br><span class="line">React的更新策略已经被启动时（事件触发时）：</span><br><span class="line">React响应事件处理 =&gt; 启动更新策略事务（绑定了wrapper） =&gt; 事务perform =&gt; setState =&gt; 获取内部实例 =&gt; 存储新的状态 =&gt; 发现更新策略事务已启动 =&gt; 将当前内部实例放入脏组件数组 =&gt; setState执行结束 =&gt; 更新策略事务perform完毕 =&gt; wrapper处理组件状态的更新</span><br><span class="line">React的更新策略没有被启动时（异步触发时）：</span><br><span class="line">setState =&gt; 获取内部实例 =&gt; 存储新的状态 =&gt; 发现更新策略事务未启动 =&gt; 启动更新策略事务（绑定了wrapper） =&gt; 事务perform =&gt; 将当前内部实例放入脏组件数组 =&gt; 更新策略事务perform完毕 =&gt; wrapper处理组件状态的更新 =&gt; setState执行结束</span><br><span class="line">setState是异步的，这个点你在什么时候遇到过坑</span><br><span class="line">答案：比如说你使用了setState更改了状态，但是你在他这个方法后面输出那个状态值会发现结果还是之前的状态，只有在他的第二个参数回调函数中才可以输出更改后的state。</span><br><span class="line">再就是当多次调用setState的时候对于相同的会被糅合成一个，后面的覆盖掉前面的。【它会集齐一批需要更新的组件然后一起更新。】</span><br><span class="line">refs的作用是什么，你在什么业务场景下使用过refs？</span><br><span class="line">答案：用来控制dom不好控制的内容，比如说我们做一个上传图片的功能，自定义样式，这时候我们用上ref就可以很轻松的实现：可参考：React自定义input样式以及实现上传照片功能。以及Refs是一种很好的发送消息给特定子实例(通过流式的Reactive props 和 state来做会不方便)的方式。</span><br><span class="line">备注：Refs 不能连接到一个 stateless function（无状态函数），因为这些组件没有支持实例。你总是可以包装一个无状态组件在一个标准复合组件里并且连接一个ref到这个复合组件。</span><br><span class="line"></span><br><span class="line">useEffect如何在props改变的时候才更新，初始化的时候不触发？</span><br><span class="line">答案：【伪代码】</span><br><span class="line">import React,&#123;useEffect, useRef&#125; from &#x27;react&#x27;</span><br><span class="line">function Test(props) &#123;</span><br><span class="line">	const refs = useRef(0);</span><br><span class="line">	useEffect(() =&gt; &#123;</span><br><span class="line">		console.log(&#x27;mount&#x27;)</span><br><span class="line">	&#125;, [])</span><br><span class="line">	useEffect(() =&gt; &#123;</span><br><span class="line">		if (refs.current++) &#123;</span><br><span class="line">			console.log(&#x27;update&#x27;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, [props.param])</span><br><span class="line">	/* 后面代码省略 */</span><br><span class="line">&#125;</span><br><span class="line">ref是一个函数，有什么好处？</span><br><span class="line">答案：react可以更优雅的完成对组件销毁时的变量回收，你只要这么用，react在销毁组件时，this.test 很方便的就可以被清理变为null。</span><br><span class="line">另一好处：ref是一个回调函数，使得我们能在这个函数中做更多的事情，比如说，我们可以借助这种函数的机制，让父组件直接获取子组件的Dom。而如果你让ref是一个字符串，实现这个功能是不可能的。</span><br><span class="line">useImperativeHandle是做什么的？</span><br><span class="line">答案：https://react.docschina.org/docs/hooks-reference.html#useimperativehandle</span><br><span class="line">高阶组件你是怎么理解的，它本质是一个什么东西？</span><br><span class="line">高阶组件和继承哪一个更好，在React里用过继承么？</span><br><span class="line">高阶组件的缺点是什么？</span><br><span class="line">受控组件与非受控组件的区别？</span><br><span class="line">受控组件与非受控组件分别适合在什么场景使用？</span><br><span class="line">答案：在这里插入图片描述</span><br><span class="line">this指向问题你一般怎么解决？</span><br><span class="line">答案：方法很多种，使用bind，call，apply，或者定义变量然后赋值。</span><br><span class="line">函数组件怎么做性能优化</span><br><span class="line">函数组件比普通组件性能高还是低？</span><br><span class="line">答案：高，因为函数组件没有类组件哪些冗余的生命周期等等</span><br><span class="line">你在哪个生命周期里发送ajax？</span><br><span class="line">答案：componentDidMount</span><br><span class="line">ssr的原理是什么？</span><br><span class="line">redux-sage的设计思想是什么？什么是sideEffects</span><br><span class="line">react,jquery,vue是否有可能共存在一个项目中？</span><br><span class="line">组件是什么？类是什么？类被编译成什么？</span><br><span class="line">你是如何跟着社区成长的？</span><br><span class="line">如何避免ajax数据重新获取？</span><br><span class="line">react-router4的核心思想是什么，和3有什么区别</span><br><span class="line">immutable.js和redux的最佳实战</span><br><span class="line">reselect是做什么使用的</span><br><span class="line">react-router的基本原理，hasHistory,browserHistory</span><br><span class="line">什么情况下使用异步组件</span><br><span class="line">xss攻击在react中如何防范？</span><br><span class="line">答案：使用JSX就可以防范，但注意少用react的这个方法(dangerouslySetInnerHTML)：（特殊情况还是可以用的）详细介绍：https://blog.csdn.net/weixin_43606158/article/details/95863666</span><br><span class="line">useMemo和useCallback用过么？他们是做什么的？他们的区别是什么？</span><br><span class="line">请讲讲React 16.X 的Fiber原理。</span><br><span class="line">React跨平台的实现原理。</span><br><span class="line">说一说redux，以及比flux先进的原因。</span><br><span class="line">React你做过降级处理么？降级以后有什么作用？【个人认为有点过时了】</span><br><span class="line">答案：React总结笔记之降级兼容</span><br><span class="line">React.lazy 实现原理</span><br><span class="line">antd 按需加载实现原理</span><br><span class="line">react-router 实现原理，hash 路由实现原理</span><br><span class="line">React 事件注册实现原理</span><br></pre></td></tr></table></figure>

讲讲 react

vue 对比 react

http://caibaojian.com/vue-vs-react.html

react 优缺点

https://www.cnblogs.com/qiqi715/p/10513195.html

react 生命周期

https://www.jianshu.com/p/b331d0e4b398

Redux 流程

https://www.cnblogs.com/goodjobluo/p/9077010.html

git 情景题

https://www.jianshu.com/p/34bf7e7ee694

Es6

https://www.cnblogs.com/ainyi/p/8537027.html

异步操作

https://www.jianshu.com/p/6f91e7696b91

虚拟 dom diff 算法

https://www.cnblogs.com/xiaohanga/p/11075861.html

setState

https://www.cnblogs.com/dreamcc/p/11409053.html

本地存储

https://zhuanlan.zhihu.com/p/25567678

react 路由传参

https://www.jianshu.com/p/ad8cc02b9e6c

Eventloop 浏览器与 Node 的事件循环(Event Loop)有何区别

https://zhuanlan.zhihu.com/p/55511602

https://www.jianshu.com/p/5f1a8f586019

https://www.jianshu.com/p/deedcbf68880

Webpack

https://www.cnblogs.com/gaoht/p/11310365.html

Webpack 优化

https://www.jianshu.com/p/773760145ea5

Eslint https://www.jianshu.com/p/f8d2ef372adf

node 基于 v8 运行环境，非阻塞 i/o

https://blog.csdn.net/banana960531/article/details/89043185

https://www.yuque.com/sunluyong/node

Ts

https://www.cnblogs.com/shangyixuan/p/11400619.html

# js

###### **1.函数节流防抖**

**（先讲下原理，再问问题：比如 7s 内点击 100 次，我用截流和防抖分别设置了 3s，那么实际情况是分别执行了几次）**

函数防抖：当事件被触发一段时间后再执行回调，如果在这段时间内事件又被触发，则重新计时。
在事件触发时，开始计时，在规定的时间（delay）内，若再次触发事件，将上一次计时（timer）清空，然后重新开始计时。保证只有在规定时间内没有再次触发事件之后，再去执行这个事件。 1 次

函数节流（throttle）：指定时间间隔内，若事件被多次触发，只会执行一次
在事件触发之后，开始计时，在规定的时间（delay）内，若再次触发事件，不对此事件做任何处理。保证在规定时间内只执行一次事件.3 次

首先函数节流和函数防抖都是为了解决高频触发函数而带来的负荷问题

应用场景:防抖:向 input 框中一直输入文字

search 搜索联想，用户在不断输入值时，用防抖来节约请求资源；
window 触发 resize 的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次

节流:鼠标不断点击触发，mousedown(单位时间内只触发一次)
监听滚动事件，比如是否滑到底部自动加载更多，用 throttle 来判断

###### **2.promise**

（假设有个页面交互式：需要执行 10 次接口以后再渲染页面，看他怎么完成这个交互，他可以答得出来用 promise.all。我再问他：有 9 个接口都是需要 1s 执行的，还有 1 个是需要 2s 执行的，那么总共大约会花多少时间）

2s

###### **3.js 原型链（讲一下你的理解）**

&gt; 实例对象与原型之间的连接，叫做原型链。\_\_proto\_\_( 隐式连接 )

&gt; JS 在创建对象的时候，都有一个叫做\_\_proto\_\_的内置属性，用于指向创建它的函数对象的原型对 prototype。

&gt; 内部原型(\_\_proto\_\_)和构造器的原型（prototype）
&gt;
&gt; 1、每个对象都有一个\_\_proto\_\_属性,原型链上的对象正是依靠这个属性连结在一起.
&gt;
&gt; 2、[原型链的过程] 作为一个对象，当你访问其中的一个属性或方法的时候，如果这个对象中没有这个方法或属性，那么 Javascript 引擎将会访问这个对象的(\_\_\_proto\_\_)属性所指向上一个对象 prototype，并在那个对象中查找指定的方法或属性，如果不能找到，那就会继续通过那个对象的(\_\_proto\_\_)属性指向的对象进行向上查找 Object.prototype，直到这个链表结束。(null)

###### **4.eventloop**

Event Loop 即事件循环，是指浏览器或者 Node 的一种解决 JavaScript 单线程运行时不阻塞的一种机制，

单线程的是所有任务都在主线程上完成,任务太多的时候,页面卡死,

eventLoop 可以解决单线程阻塞问题,程序中会有两个线程,一个主线程,一个 eventLoop 线程,负责主线程和其他进程之间的通信,

遇到 I/O 的时候,主线程会让 eventLoop 线程通知对应的程序,主线程的任务会继续往后执行,等 I/O 程序执行完了,eventLoop 线程会把结果返回给主线程,主线程利用回调函数调用结果,完成任务

###### **5.es6 新特性**

let let 声明的变量有块作用域 不能重复声明变量,

const 常量声明,一旦声明,常量的值不能改

const 定义一个对象,可以修改里面的属性,因为对象是引用类型 改变的是引用地址

解构赋值

扩展运算符 ...

模板字符串

箭头函数 简洁,同时函数体内 this 对象，就是定义时所在的对象，而不是使用时所在的对象。This 不会改变了 一定是匿名函数 不要在最外层定义箭头函数

Symbol 类型 独一无二的值

Generators 生成器函数 \* 函数体内部使用 yield 表达式将进程分片暂停 next 获得结果

class extends 类和继承

promise 异步编程的一种解决方法 三个状态 pending-resolve-reject

状态从 pending-resolve 成功返回一个 promise 对象,通过 then 传递

状态从 pending-reject 失败走 reject

promise.all 并发 promise.race 速发

###### set 和 map forEach

不说 set 数据结构 Set new set()存储数据 set.size 得到存储的数据长度

has()判断某个值是否存在 set 中 foreach 遍历 set

不说 map : new map map.set map.get map.delete

都是用来存储数据用的，但是存储的数据格式不同
set 直接存储 任意类型数据
map 存储数据的时候，必须以 key，value 的形式，
set 使用 forEach 遍历的时候，key 和 value 值是一样的
而 map 遍历的时候，key 就是存进去的对象的 key，value 就是存在的值

for 循环这种写法比较麻烦，因此数组提供内置的 forEach 方法。

forEach 没有返回值，无法中途跳出 forEach 循环，break 命令或 return 命令都不能奏效。

for...in 循环主要是为遍历对象而设计的，不适用于遍历数组\*\*

for...of 循环相比上面几种做法，有一些显著的优点。
有着同 for...in 一样的简洁语法，但是没有 for...in 那些缺点。
不同于 forEach 方法，它可以与 break、continue 和 return 配合使用。
提供了遍历所有数据结构的统一操作接口。

###### **6.宏任务和微任务**

同步和异步任务分别进入不同的执行&quot;场所&quot;，同步的进入主线程，异步的进入 Event Table 并注册函数。

当指定的事情完成时，Event Table 会将这个函数移入 Event Queue。

主线程内的任务执行完毕为空，会去 Event Queue 读取对应的函数，进入主线程执行。

上述过程会不断重复，也就是常说的 Event Loop(事件循环)。

先执行同步代码 微任务放在微任务队列中 宏任务放在宏任务队列中

宏任务和微任务是任务队列是两个任务队列中

同步执行完,执行微任务,再执行宏任务

宏任务 setTimout setInterval

微任务 promise process.nextTick

###### **7.异步操作**

回调函数 异步回调 函数作为参数传递给另外有一个函数 将函数内部的值通过回调函数传出来 解决同步的一种方式 多层嵌套 造成回调地狱
事件监听

发布/订阅 系统中有一个信号中心,当某个任务执行完成后向信号中心发布一个消息,其他任务就可以通过这个信号中心去订阅这个信号,从而知道什么时候直接可以开始执行 发布订阅模式和事件监听类似,可以查看消息中心有多少信号,每个信号有多少订阅者

promise  
generator（ES6） 异步任务 通过 yield 关键字可以让任务在需要的地方暂停,每一步的值可以通过 next 获取

async/await(ES7) await 得到的就是 async 异步返回值,底层原理还是 promise 中的 resolve 方法

###### **8.本地存储** **三种存储**

首先总的来说，三者都是用于持久化数据存储的手段，都是存储在浏览器端，且同源.

localStorage 和 sessionStorage 都是 Web 存储，大小 5M 左右，完全存储在客户端，它们是因为本地存储数据而存在.

cookies 也是存储在浏览器端的，大小不超过 4k，由服务器端存储在客户端。

localStorage 属于永久性存储,数据存储量大,，而 sessionStorage 属于当会话结束的时候，存储的值会被清空，而 cookie 是通过设置过期时间 expires 来存储的。

###### 9.表单只能输入数字

正则 type number

###### 10.es2016-es2020

https://zhuanlan.zhihu.com/p/133658121

https://juejin.im/post/6844904021308735502

String.prototype.matchAll

String.prototype.matchAll 比 match() 多得多的信息---它返回的迭代器不仅包括精确的匹配结果，还有全部的正则模式捕获结果。返回的结果更全面

而 String.prototype 的 match() 方法仅返回完整的匹配结果，却不会返回特定正则表达式组的信息,

import() 按需获取的动态 import 返回了一个强大的 promise 函数，使得诸如按需引入

BigInt – 任意精度整数 或是在一个数值后添加 n 后缀，来将一个 number 转换为 bigint 类型

Promise.allSettled 它可以用在处理所有的 promise 无论结果是 fulfilled 还是 rejected，无需 catch

Promise.any()

globalThis 手动定义全局 this 指向,全局 this 指向:浏览器中它是 window, 在 worker 中它是 self, 在 Node.js 中它是 global

可选链 简化对象属性的长链式访问易出错又不易读
const title = data &amp;&amp; data.article &amp;&amp; data.article.title // 之前
const title = data?.article?.title // 之后

空值合并运算符 空值合并运算符 ?? 只会在左边的值严格等于 null 或 undefined 时起作用

###### 11.Proxy 和 Reflect

Proxy 用于修改某些操作的默认行为，即对编程语言层面进行修改，属于“元编程”，Proxy 意思为“代理”，即在访问对象之前建立一道“拦截”，任何访问该对象的操作之前都会通过这道“拦截”，即执行 Proxy 里面定义的方法

let pro = new Proxy(target,handler)

其中 new Proxy 相当于创建了一个 Proxy 实例，target 为所要拦截的目标对象，handler 也是一个对象，里面定义的是对拦截对象所要进行的拦截方法

Proxy 也可以作为其他对象的原型对象使用

上述实例将 pro 作为 obj 的原型对象使用，虽然 obj 本身没有 name 这个属性，但是根据原型链，会在 pro 上读取到 name 属性，之后会执行相对应的拦截操作。

let pro = new Proxy(target,handler);
let obj = Object.create(pro);

**Proxy 常用的拦截方法**

get(target,name,property)方法，用于拦截某个读取属性的操作,第一个参数为目标对象，第二个参数为属性名称，第三个属性为操作所针对的对象（可选参数）

set(target,name,value,property),用于拦截某个属性的赋值操作，第一个参数为目标对象，第二个参数为属性名，第三个参数为属性值，第四个参数为操作行为所针对的对象（可选参数）

has(target,key),用来拦截对象是否具有某个属性值的操作，第一个参数为目标对象，第二个参数为属性名

Reflect 对象 :Reflect 设计的目的是为了优化 Object 的一些操作方法以及合理的返回 Object 操作返回的结果，对于一些命令式的 Object 行为，Reflect 对象可以将其变为函数式的行为

Reflect(target,name,property) Reflect.has(obj,&quot;name&quot;)

Reflect.get(target,name,property)

###### 12.浏览器优化

**减少请求数量**

一.图片处理

1、雪碧图 - gulp Base64 使用字体图标来代替图片 - 自定义字体 @font-face&#123;&#125; 在安卓下可以使用 webp 格式的图片，它

二.减小资源大小 - grunt gulp webpack

1、HTML 压缩 2、CSS 压缩 3、JS 压缩与混乱 4、图片压缩

三.优化网络连接

cdnCDN 即内容分发网络，它能够实时地根据网络流量和各节点的连接、负载状

用户可就近取得所需内容，解决 Internet 网络拥挤的状况，提高用户访问网站的响应速度

四.优化资源加载

资源加载位置

1、CSS 文件放在 head 中，先外链，后本页

2、JS 文件放在 body 底部，先外链，后本页

3、body 中间尽量不写 style 标签和 script 标签

资源加载时机

1、异步 script 标签

2、模块按需加载需要根据路由来加载当前页面需要的业务模块

3、资源懒加载与资源预加载

五.减少重绘回流

当 render tree 中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。

当 render tree 中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如 background-color。则就叫称为重绘。

回流必将引起重绘，而重绘不一定会引起回流。

优化

减少回流和重绘

css3 硬件加速（GPU 加速）

六.【DOM 优化】

1、缓存 DOM2、减少 DOM 深度及 DOM 数量 3、批量操作 DOM4、批量操作 CSS 样式 5、在内存中操作 DOM6、DOM 元素离线更新 7、DOM 读写分离 8、事件代理 9、防抖和节流 10、及时清理环境

###### 13.static 有什么特性

new 出来一个实例对象是否带有 static 属性 static 用 ES5 怎么写

没有创建对象，也能使用属性和调用方法

用来形成静态代码块以优化程序性能。因为只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在 static 代码块中进行。

static 块可以置于类中的任何地方，类中可以有多个 static 块。在类初次被加载的时候，会按照 static 块的顺序来执行每个 static 块，并且只会执行一次

被 static 修饰的变量或者方法是独立于该类的任何对象，也就是说，**这些变量和方法不属于任何一个实例对象**，而是被类的实例对象所共享。

类第一次加载初始化的时候就去加载 static 部分,后面可以重新赋值

static 用 ES5 怎么写:静态是通过类名直接调用 class A staticB

直接用 A.B 将 B 绑定在 A 上

###### 14.async await

await 后面有个接口 接口要 2S 才能完成 接口 2S 才会执行

await 是同步还是异步:await 同步 async 异步

async 和 await 有两个关键字,一个写在函数外面,一个写在函数里面,函数外面是异步的 函数里面是同步的 调用函数的那一行其实是异步的,下一行

函数里面转成阻塞的

###### async await promise 改写

async 函数中

let a=await promise 的 a 函数

let b=await promise 的 b 函数

promise.all 改写 Promise.allSettled Promise.any

promise 实现 promise.all 的方法

async 使用的时候报错,如何捕获 try...catch

var test3 = async function () &#123;
try &#123;
await p1();
await p2();
p3();
&#125; catch (e) &#123;
console.log(&#39;p1 失败了&#39;, e)
&#125;
&#125;

###### 15.$.ajax 中 async:false 的阻塞和 await 这种阻塞有什么区别

没区别

###### 16.怎么携带 cookie 发送给后端

设置请求头 请求头中携带 cookie

###### 17.项目上线怎么解决跨域

aginx 上线前设置好了 上线后不存在跨域

###### 18.如何扩展数组,让他拥有新的方法

Array.prototype.

###### 19.原型和原型链的关系

const a=new Fn a 里面有什么属性指向 Fn \_\_proto a 里面有没有属性值就是 Fn

通过什么方法判断 a 的构造器就是 Fn a.constructor==fn

prototype 原型对象中的 constructor 属性 指向的是 prototype 自己所在的构造函数

###### 20.前端堆 栈 深拷贝浅拷贝

浅拷贝只能拷贝一层, obj 的第一层 a 改变,newObj 不变

浅拷贝: obj 的第二层改变,newObj 也会变化

Object.create(obj)
Object.assign(&#123;&#125;, obj)
&#123; ...obj &#125;

map set

深拷贝,obj 和 newObj 改变,互相不影响

手动封装递归实现深拷贝 loadsh const newObj = \_.cloneDeep(obj);

JSON 序列化 JSON.stringfy(state) JSON.parse() immutable

堆--引用类型地址传递
堆：动态分配的内存，大小不定，不会自动释放。存放引用类型的值 先进后出 FILO

栈--基本类型值传递
栈：自动分配内存空间，系统自动释放，存放基本类型的值和引用类型的地址 先进先出 FIFO

###### 对象浅拷贝在 react 中用到哪些地方,为什么

为什么在 react 中要使用浅拷贝

redux 中要求:状态是只读的,唯一且不可修改的,reducer 必须是一个纯函数

-因为 redux 中数据不可更改,所以 redux 中的数据应该要拷贝 返回一个新值

###### 21.class 中 super 作用是什么

es5 的继承是先创建子类的 this，然后将父类的方法添加到子类的 this 上去；
es6 的继承是创建父类的 this 对象，然后再对 this 对象添加方法/属性。
而 super 方法就是用来创建父类 this 对象的。

实际上执行的是 super.sport.call(this);

###### 22.闭包

1、闭包:打破了作用域链的规则 闭包就是能够读取其他函数内部变量的函数

2、用途：a:可以读取函数内部的局部变量 b:让这些变量始终保持在内存当中

3、注意：由于闭包会使得函数中的变量都被保存在内存当中，内存会消耗很大，所以不能够滥用
闭包，否则会造成网⻚性能的问题 闭包 内存泄漏 意外的全局变量 被遗忘的定时器 没有清除的 dom 应用 ，故要及时清除，清除内存泄漏方法有两种，一是标记清除，二便是引用计数清除。 4.使用闭包的好处是不会污染全局环境，方便进行模块化开发，减少形参个数，延长了形 参的生命周期，坏处就是不恰当使用会造成内存泄漏 5 闭包的常用场景有一是函数作为返回值，二是函数作为参数来传递。不适用于返回闭包的 函数是个特别大的函数,很多高级应用都要依靠闭包实现. 闭包经典使用场景一：通过循环给页面上多个 dom 节点绑定事件 闭包使用场景二：封装变量 闭包使用场景三：延续局部变量的寿命

###### 23.普通构造函数 constructor 与 class 的区别?

传统的 javascript 中只有对象，没有类的概念。它是基于原 型的面向对象语言。原型对象特点就是将自身的属性共享给新对象。 ES6 引入了 Class（类）这个概念，通过 class 关键字可以 定义类。该关键字的出现使得其在对象写法上更加清晰，更像是一种面向对象的语言

constructor： constructor()方法是类的默认方法，通过 new 命令生成对象实例 时，自动调用该方法。一个类必须有 constructor()方法，如果没有显式定义，一个空的 constructor()方法会被默认添加。

# React

###### **1.父子组件传信**

**（父组件获取子组件有哪几种方式，子组件获取父组件有那几种方式）**

父组件获取子组件:父组件定义获取数据的方法 ,绑定在子组件身上,子组件调用这个方法并传参

子组件获取父组件:

类组件中:子组件身上绑定属性

函数组件中:传 props 参数

跨组件通信:ref ref 不能绑定函数组件 高阶组件

redux

###### **2.react（生命周期，最新版本改动，知道哪有新特性）**

初始化--

constructor:属性的继承 ,定义状态,绑定方法

类组件有 constructor 的 constructor 执行顺序 class 中 new 实例对象的时候执行 constructor

componentWillMount-17 弃用
UNSAFE_componentWillMount:组件即将挂载,初始化事件,为挂载做准备,内部操作
render:解析 this.state,this.props,将 jsx 型的 vdom 渲染为对象类型的 vdom,render 函数中不允许使用 this.setState()

componentDidMount:1.组件挂载结束 2.vdom-&gt;真实 dom3.发送数据请求,赋值给 state4.真实 dom 操作,第三方库实例化

更新阶段---

**componentWillReceiveProps-17 弃用**:1.用于接收新的 props 值 2.这个钩子的实际作用:判断组件身上的 props 是否改变

这里面做哪些事情比较好 判断组件身上的 props 是否改变

shouldComponentUpdate:1.可以决定组件是否要重新渲染 2.接收新旧状态,用于做对比(浅对比)

componentWillUpdate-17 弃用:1.表示组件更新前的准备

render

componentDidUpdate

--销毁阶段

componentWillUnmount:组件销毁,清除无用的实例,事件,定时器等

componentDidCatch:用于捕获组件 throw 的错误,然后显示回退 UI,网络有延迟等

17 版本 废弃 omponentWillMount componentWillReceiveProps componentWillUpdate

static getDerivedStateFromProps 1.这是一个静态方法,不能使用 this 2.提供了一次修改 state 的机会

getSnapshotBeforeUpdate 1.快照 2.用于传递一个值给 componentDidUpdate

15 版本 getDefaultProps 定义属性 , getInitialState 定义状态

###### **3.组件按需加载**

**（实现方式，需要的依赖） **懒加载

1、vue 异步组件技术
vue-router 配置路由，使用 vue 的异步组件技术，可以实现按需加载。
但是，这种情况下一个组件生成一个 js 文件。

2.import()

3.webpack 提供的 require.ensure()

4.第三方库比如 react-loadable

5.lazy-loader

###### **4.react 新特性，hooks ** 16.8 版本出 19 年

useState:定义状态 修改状态

useEffect:相当于 componentDidMount , componentDidUpdate ,同 useLayoutEffect
componentWillUnmount 三个钩子的组合 DOM 操作 第三方实例化可以做 清除无用实例和事件

useContext:跨组件通信 createContext 创建一个组件 &lt;numContext.Provider value=&#123;num&#125;&gt;

useDebugValue:自定义 hook 的标签 方便调试台查看

useMemo:记忆组件 动态缓存 新值和旧值一样,不重新渲染页面,优化作用,类似于 shouldComponentUpdate useCallBack

useRef:返回一个可变的 ref 对象

useImperativeHandle:将组件中的方法放到外面使用 搭配 React.forwardRef

###### 自定义 hook 封装过组件吗

1.将 Hello 组件和 App 组件中共用的逻辑放在统一的自定义 hook 中写 2.自定义 hook,hook 名以 use 开头

3.其他组件通过 import 引入自定义 hook,就可以使用了

###### **5.是否看过 react 源码**

看过 说一说 setState redux 原理

###### **6.vue 对比 react**

相同点:1.都使用了 vdom 虚拟 dom,如果需要改变任何元素的状态,先改 vdom,当有变化产生时,会创建新的 vdom,通过 diff 算法对比新旧 vdom 的差异,只需要渲染差异部分就行

2.都使用组件化

不同点:1.react 中有新语法 jsx,vue 用普通的 html

2.vue 中父组件和子组件有通信的时候,父组件数据改变引起子组件改变,,子组件会重新渲染 如果父子组件没有通信,父组件改变子组件不会渲染

react 中不管是否有数据通信,父组件改变子组件都会渲染

3.react:create-react-app vue : vue-cli

4.react 中用 redux 管理状态,state 通过 setState 更新

vue 中数据由 vuex 管理

###### React Native

React Native 能在手机上创建原生应用，React 在这方面处于领先位置。使用 JavaScript, CSS 和 HTML 创建原生移动应用，这是一个重要的革新。Vue 社区与阿里合作开发 Vue 版的 React Native——Weex 也很不错，但仍处于开发状态且并没经过实际项目的验证。

既拥有 Native 的用户体验、又保留 React 的开发效率

React Native 与 React.js 的主要区别还是 JSX,它使用 XML 标记的方式去直接声明界面，将 HTML 直接嵌入到 JavaScript 代码中

###### **7.react 优缺点**

优点:1.vdom react 速度更快 2.react 不用考虑浏览器兼容问题 3.组件化 模块化 4.单向数据流:指父组件可以向子组件传递数据，但子组件不可以修改这些数据，否则会报错。

劣势: react 只是视图 view 需要引入很多第三方插件

###### **8.redux 流程 ** redux 的原理

1)首先先把 redux 相关工具安装好
yarn add redux react-redux redux-thunk redux-devtools-extension -D

2)通过创建一个 store 实例 createStore,接收一个 rootReducer 和中间件执行函数 **一个组件只能有一个 store 实例**

3)创建分块的数据 rootReducer,通过 combineReducers 打造 rootReducer,里面放分块的数据

4)在组件中通过高阶组件 connect 函数,
接收 store 里的数据,
把 ActionCreators 里的方法绑定到组件身上,并且可以发送动作 action 给 reducer

5)在 reductor 中根据 action 中的 type 动作类型,判断动作修改数据

redux-saga namespace state effects subscriptions 事件订阅 监听路由变化 键盘变化鼠标变化 reducers

redux-saga

namespace 命名空间 数据只在此组件中使用

state 定义状态

effects 调用数据请求 发送 action 给 reducer

subscription 监听事件变化 键盘变化 鼠标变化 根据条件触发 dispatch 需要的 action

reducers 修改状态

###### **9.setState**

**setState 在合成事件和钩子函数中是异步的 **

**在原生事件和 setTimeout 中是同步的**

setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的 callback 拿到更新后的结果。

setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和 setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。

第一个参数可以是对象或者函数 是更新 state 第二个参数获取最新的 state,副作用操作 dom 操作事件触发声明 数据获取

###### **10.Alibaba fusion design**

完整的中后台设计系统解决方案

Alibaba Fusion Design 最初来源于一个阿里巴巴内部的中台项目

###### antv

npm install @antv/g2

G2 G6 关系数据可视化图表分析工具 F2 移动端可视化 L7 地图空间数据可视化

###### **11.react 路由传参**

params:

优势 ： 刷新地址栏，参数依然存在
缺点:只能传字符串，并且，如果传的值太多的话，url 会变得长而丑陋。

query:

优势：传参优雅，传递参数可传对象；
缺点：刷新地址栏，参数丢失

state:同 query this.props.location.query.state

search:同 search this.props.location.search

###### 13.react 中的路由模式有哪些？有什么区别？

    1.browerHistory   (推荐)    ：它使用History API用于处理URL、创建像xxx.com/login/xxx这样的URL实例
    2.hashHistory     ：使用URL中的hash(#)部分去创建形如xxx.com/#/login/xxx    类似于vue中hash路由
    3.createMemoryHistory    ：不会在地址栏被操作或读取。和另外两种histoty的不同点是必须创建它，这种方法    便于测试
    4、NativeRouter：经常配合ReactNative使用，多用于移动端
    5、StaticRouter：设置静态路由，需要和后台服务器配合设置，比如设置服务端渲染时使用

###### 14.mobx

改变了 store 中的值 发现页面没有更新,是为什么 如果想要更新怎么做

1.  组成部分
    actions-&gt;state-&gt;computed values-&gt;Reactions
2.  工作流
    在 mobx 中， 数据是通过加 @observable 作为可监测的被观察者， 在 view 层中， 你可以通过添加@observer 将 view 作为观察者，对数据进行监测， 如果要触发改变数据，则使用@action, 事实上，你可以直接在 view 层改变数据， 但这种方式不便监控数据，因此不推荐直接改变数据。 而@computed 可以用来计算数据， 也可以是计算多个数据之后返回新的数据， 如果其中数据改变， @computed 也会触发改变
3.  优点
    不同于 redux 的单一数据流， mobx 中，你可以同时在各个地方使用同一份 state, 也可以在一个页面中使用多个 store 文件

###### 15.react-router 原理

react-router 依赖基础 - history

history 是一个独立的第三方 js 库，可以用来兼容在不同浏览器、不同环境下对历史记录的管理

老浏览器的 history: 主要通过 hash 来实现，对应 createHashHistory

高版本浏览器: 通过 html5 里面的 history，对应 createBrowserHistory

node 环境下: 主要存储在历史记录 memeory 里面，对应 createMemoryHistory

抽象了一个公共的文件 createHistory:

此时的 location 跟浏览器原生的 location 是不相同的，最大的区别就在于里面多了 key 字段，history 内部通过 key 来进行 location 的操作

原理:

1.1 执行 URL 前进

createBrowserHistory: pushState、replaceState

createHashHistory: location.hash=\*\*\* location.replace()

createMemoryHistory: 在内存中进行历史记录的存储

1.2 检测 URL 回退

createBrowserHistory: popstate

createHashHistory: hashchange

createMemoryHistory: 因为是在内存中操作，跟浏览器没有关系，不涉及 UI 层面的事情，所以可以直接进行历史信息的回退

1.3state 的存储

为了维护 state 的状态，将其存储在 sessionStorage 里面:

**基本原理:实现 URL 与 UI 可视化界面的同步。其中在 react-router 中，URL 对应 Location 对象，而 UI 是由 react components 来决定的，这样就转变成 location 与 components 之间的同步问题。**

在 react-router 中最主要的 component 是 Router RouterContext Link，history 库起到了中间桥梁的作用。

安装 react-router-dom

-Link 组件用于点击链接跳转其他页面，没有路由激活
-NavLink 用于有路由激活效果的

1.Switch:表示一次只渲染一个组件
2.Route:路由组件,用于展示一个组件 同 router-view
3.Redirect:重定向
4.lazy + Suspense :实现路由懒加载
5.exact:路径完全匹配
6.fallback:组件切换时候的转场组件

###### react-router-dom 和 react-router 的区别

在 V3 中，我们 是将整个庞大的 router 直接丢给 DOM，而在 V4 中，除了 BrowserRouter， 我们丢给 DOM 的是我们的应用程序本身 另外，V4 中，我们不再使用 &#123;props.children&#125; 来嵌套组件了，替代的 &lt;Route&gt;，当 route 匹配时，子组件会被渲染到 &lt;Route&gt; 书写的地方 （router3 需要进行集中式管 理,router4 的话哪里需要在哪里配置就可以了）

###### 16.react 原理

1.1setState

setState 在合成事件和钩子函数中是异步的

在原生事件和 setTimeout 中是同步的

setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，

第一个参数可以是对象或者函数 是更新 state 第二个参数获取最新的 state,副作用操作 dom 操作事件触发声明 数据获取

1.2 JSX 语法的转化

JSX 仅仅是 createElement() 方法的语法糖（简化语法）
JSX 语法被 @babel/preset-react 插件编译为 createElement() 方法

react.createElement()

React 元素：是一个对象，用来描述你希望在屏幕上看到的内容

1.3 组件更新机制

setState() 的两个作用： 1. 修改 state 2. 更新组件（UI）
过程：父组件重新渲染时，也会重新渲染子组件。但只会渲染当前组件子树（当前组件及其所有子组件）

1.4 组件性能优化

减轻 state：只存储跟组件渲染相关的数据

避免不必要的重新渲染 : shouldComponentUpdate(nextProps, nextState) 通过返回值决定该组件是否重新渲染，返回 true 表示重新渲染，false 表示不重新渲染 起到优化作用

1.5 纯组件 PureComponent

PureComponent 内部自动实现了 shouldComponentUpdate 钩子，不需要手动比较

纯组件内部通过分别 对比 前后两次 props 和 state 的值，来决定是否重新渲染组件

纯组件内部的对比是 shallow compare（浅层对比）

1.6 虚拟 DOM 和 Diff 算法

数据改变视图更新

初次渲染时，React 会根据初始 state（Model），创建一个虚拟 DOM 对象（树）。
根据虚拟 DOM 生成真正的 DOM，渲染到页面中。
当数据变化后（setState()），重新根据新的数据，创建新的虚拟 DOM 对象（树）。
与上一次得到的虚拟 DOM 对象，使用 Diff 算法 对比（找不同），生成 patch 补丁对象,得到需要更新的内容。
最终，React 只将变化的内容更新（patch）到 DOM 中，重新渲染到页面。

###### 17.connect 的实现, 如何在全局中取得 store

连接 React 组件与 Redux store。

connect:connect 函数的返回值是一个高阶组件,通过高阶组件来获取 store 中的数据 connect 底层原理:是闭包

mapStateFromProps:从 countReducer 中解构出 num 数据,用来获取数据

mapDispatchFromProps:将 ActionCreators 中的方法绑定到组件上,并且发送 action

**connect 实现原理:**

首先 connect 之所以会成功，是因为 Provider 组件：

在原应用组件上包裹一层，使原来整个应用成为 Provider 的子组件
接收 Redux 的 store 作为 props，通过 context 对象传递给子孙组件上的 connect
那 connect 做了些什么呢？
它真正连接 Redux 和 React，它包在我们的容器组件的外一层，它接收上面 Provider 提供的 store 里面的 state 和 dispatch，传给一个构造函数，返回一个对象，以属性形式传给我们的容器组件。

关于它的源码
connect 是一个高阶函数，首先传入 mapStateFromProps、mapDispatchFromProps，然后返回一个生产 Component 的函数(wrapWithConnect)，然后再将真正的 Component 作为参数传入 wrapWithConnect，这样就生产出一个经过包裹的 Connect 组件，该组件具有如下特点:

通过 props.store 获取祖先 Component 的 store
props 包括 stateProps、dispatchProps、parentProps,合并在一起得到 nextState，作为 props 传给真正的 Component
componentDidMount 时，添加事件 this.store.subscribe(this.handleChange)，实现页面交互
shouldComponentUpdate 时判断是否有避免进行渲染，提升页面性能，并得到 nextState
componentWillUnmount 时移除注册的事件 this.handleChange

###### 18.webpack 打包 vue,react,与自己的源代码分离使用**splitchunks**

###### 19.react 的版本 15 和 16 的区别

1.1 生命周期不同

15 和 16 版本不一样的地方只有初始化阶段 getDefaultProps,getInitialState,

用 constructor 代替

###### 20.react 组件的时候,经常写 class 组件,class 没有的时候怎么写

React.createClass 我们最早使用这个方法来构建一个组件“类”，它接受一个对象为参数，对象中必须声明一个 render 方法，render 返回一个组件实例

###### 21.生命周期 钩子函数用 es5 怎么定义

protoType.componentDidMount

###### 22.为什么使用 hook

不必写 class 组件就可以用 state 和其他的 React 特性；

自定义 hook 实现组件的复用 用 useEffects 代替生命周期方法 代码更加简洁

###### 23.useEffect

第二个参数可以支持数组中有几个函数吗 不可以

依赖性可以是一些 props 的属性

1)相当于 componentDidMount , componentDidUpdate ,
componentWillUnmount 三个钩子的组合

2)数据请求,DOM 操作 第三方实例化可以做 清除无用实例和事件

3)参数 第一个参数是回调函数，用于执行副作用操作 第二个参数就是定义的 state 返回值:是一个函数 return ()=&gt;&#123;&#125; 用来清除无用的组件

4)数据更新触发这个函数
第二个参数是空数组[],数据更新只执行一次,相当于 componentDidMount

第二个参数是[a],只有 a 数据更新才会触发这个函数,b 数据改变不会触发

第二个参数不写,所有数据更新都触发这个函数,执行多次的,相当于 componentDidUpdate+componentDidMount

###### 24.react 中的 key

diff 算法同层级对比需要根据 key 来

每一个 key 都是独一无二的，为的是方便 React 的和解过程中，方便元素树进行比对。key 不仅可以使这个过程更有效率，如果没有 key 时，React 不知道那个本地状态对应于移动中的哪个项目

组件 a 里面嵌套组件 b 给组件 b 上加了 key 组件 a 中 state 改变了 组件 b 会发生什么行为

如果 a b 有数据通信 b 的数据也会改变 并且 b 下面的子组件都会重新渲染

###### 25.组件销毁怎么做 componentWillUnmount

定义 state flag:false 作为开关 定义方法 if 判断是否为 1,改变 state flag:true

将方法绑定组件上 可以用三目或者短路原则&amp;&amp;控制组件的显示隐藏

###### 26.封装过 react 组件吗

###### 27antv 中 input 输入框三个属性怎么实现

onChange 输入框内容改变时候回调 value 输入的内容 defaultValue 输入框默认值

input 默认值在 input 中绑定 value 定义一个 state 和 input 双向数据绑定 做成受控组件 定义一个事件 改变的时候获取 e.target.value

###### 29.函数组件和类组件区别

相同点:无论是使用函数或是类来声明一个组件，它决不能修改它自己的 props。
所有 React 组件都必须是纯函数，并禁止修改其自身 props 。
React 是单项数据流，父组件改变了属性，那么子组件视图会更新。
属性 props 是外界传递过来的，状态 state 是组件本身的，状态可以在组件中任意修改
组件的属性和状态改变都会更新视图。

不同点:

函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。

类组件有 this state 定义 state 修改 state 生命周期 ES6 的 class 创建组件

函数组件 没有 函数组件用 hooks useState JS 函数创建组件 函数组件必须有返回值

###### 30.受控组件和非受控组件

如果组件或是元素并不是由自己来控制的，那么它就是受控组件

如果组件或是元素自己的状态自己管理，那么它就是非受控组件

1. 子组件的渲染收到父组件的控制【父组件传递数据给子组件，子组件使用了这个数据】
2. 在一个组件中，如果我们让这个组件的 state 来控制表单元素的值，那么这个组件就是受控组件【几乎所有的表单都会被控制的】

###### 31.redux 中间件的实现

中间件的执行时机在 aciton 发出到 reducer 执行之间

redux 中间件的实质是对 redux 中 store.dispath 函数的再封装

当中间件被 rudex 初始化完成后，每次调用 store.dispatch 都会执行一遍每个中间件，他们之间是链式关系

###### 32.高阶组件

复用组件逻辑的一种高级技巧。

1. 高阶组件是一个函数
2. 高阶组件接收一个组件作为参数进行使用,返回值是一个类组件
3. 高阶组件的目的是为了： 复用组件,将多个组件都要使用的类似逻辑放在同一个地方进行处理
   1. 高阶组件返回的一个类组件，而自定义 Hook 可以返回任何东西
   2. 高阶组件必须传递一个组件作为参数，而自定义 Hook 不需要

###### 33.单页面应用这么实现

路由实现 react-router -dom react-router 实现原理看题目



###### 35.react 合成事件

1. 合成事件原理
   如果 DOM 上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响。React 为了避免这类 DOM 事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，实现了一个中间层——SyntheticEvent。

当用户在为 onClick 添加函数时，React 并没有将 Click 时间绑定在 DOM 上面。
而是在 document 处监听所有支持的事件，当事件发生并冒泡至 document 处时，React 将事件内容封装交给中间层 SyntheticEvent（负责所有事件合成）
所以当事件触发的时候，对使用统一的分发函数 dispatchEvent 将指定函数执行。

2. 与原生事件的区别
   React 合成事件一套机制：React 并不是将 click 事件直接绑定在 dom 上面，而是采用事件冒泡的形式冒泡到 document 上面，然后 React 将事件封装给正式的函数处理运行和处理。

###### 36.flux

flux 是 react 中的类似于 vuex 的公共状态管理方案，它是 Facebook 官方给出的应用架构，利用数据的单向流动的形式对公共状态进行管理。现已不推荐使用。但是为了能更好的理解 Redux 方案，还是有必要熟悉 flux 的工作流程滴~
使用 cnpm i flux -S 的方式进行安装。
flux 的组成
flux 是 react 中的类似于 vuex 的公共状态管理方案，它是 Facebook 官方给出的应用架构，利用数据的单向流动的形式对公共状态进行管理。现已不推荐使用。但是为了能更好的理解 Redux 方案，还是有必要熟悉 flux 的工作流程滴~
View：视图层
Action：视图发出的消息
Dispatcher：派发者，用来接收 Action，执行回调函数
Store：数据层，存放状态，一旦发生改动
flux 在进行数据更新时，会经历以下几步：
用户与 View 层交互，触发 Action
Action 使用 dispatcher.dispatch 将 Action 自己的状态发送给 dispatcher
dispatcher 通过 register 注册事件，再通过 Action 传入的类型来触发对应的 Store 回调进行更新
Store 里进行相应的数据更新，并触发 View 层事件使试图也同步更新
View 层 收到信号进行更新

###### 37.redux 与 react-reudx 的关系

redux 是独立的应用状态管理工具。它是可以独立于 react 之外的。如果我们需要在 react 当中运用它，那么我们需要手动订阅 store 的状态变化，来对我们的 react 组件进行更新。那么 react-reudx 这个工具，就帮我们实现了这个功能，我们只需对 store 进行处理，react 组件就会有相应的变化。
Redux 的核心由三部分组成：Store, Action, Reducer。
Store : 是个对象，贯穿你整个应用的数据都应该存储在这里。
Action： 是个对象，必须包含 type 这个属性，reducer 将根据这个属性值来对 store 进行相应的处理。除此之外的属性，就是进行这个操作需要的数据。
Reducer: 是个函数。接受两个参数：要修改的数据(state) 和 action 对象。根据 action.type 来决定采用的操作，对 state 进行修改，最后返回新的 state。
总结
Redux: store, action, reducer
store: getState, dispatch, subscribe
combineReducers
createStore
store ️ dispatch ️ action ️ reducer
react-redux:
connect: 将 store 作为 props 注入
Provider: 使 store 在子孙组件的 connect 中能够获取到

###### 38.redux-thunk redux-saga

好处
可以进行前后端数据交互
缺点
将带有数据请求的 action 和没有带有数据请求的 action 混在一起了
缺点解决： 弃用 redux-thunk,使用 redux-saga
redux-saga 可以将异步 action 和普通 action 区别开来

redux-saga 可以将异步 action 和普通 action 区别开来，控制器与更优雅的异步处理

而 redux-saga 就是用 Generator 来处理异步。

redux-saga 文档并没有说自己是处理异步的工具，而是说用来处理边际效应（side effects），这里的边际效应你可以理解为程序对外部的操作，比如请求后端，比如操作文件。

redux-saga 同样是一个 redux 中间件，它的定位就是通过集中控制 action，起到一个类似于 MVC 中控制器的效果。

同时它的语法使得复杂异步操作不会像 promise 那样出现很多 then 的情况，更容易进行各类测试。

这个东西有它的好处，同样也有它不好的地方，那就是比较复杂，有一定的学习成本。

###### 39.DVA 与 CRA 相比的优点

dva： dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架。--- 来自官方。相比于 cra 只是多了内置的 redux 和 redux-saga，帮我们处理了数据流这方面的需求而已。如果只是想要达到这个效果的话，直接在 cra 中增加 dva-core 的依赖也是可以做到的。
umi：是一个可插拔的企业级 react 应用框架。umi 和 cra 都是应用框架，可能相比 cra 来说 umi 的功能点更多一些，只能说是功能性的话 umi 要相对来说更胜一筹

###### 40.React 新特性

render
支持返回这五类：React elements, 数组,Fragments，Portal，String/numbers,boolean/null。基础数据类型
Fiber
React Fiber 的方法其实很简单——分片。把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会。
新的生命周期函数
由于异步渲染的改动，componentWillMount, componentWillReceiveProps,componentWillUpdate 三个函数将被废弃。
由于这是一个很大的改变会影响很多现有的组件，所以需要慢慢的去改。
目前 react 16 只是会报 warning，在 react 17 就只能在前面加 UNSAFE\_ 的前缀来使用

diff 算法的作用计算出 Virtual DOM 中真 正变化的部分，并只针对该部分进行原生 DOM 操作，而非重新渲染整个页面

分层对比,把 DOM 树按层级拆分,简化了 复杂度,只比较同级元素,只匹配相同组件名字的组件,给列表结构的每个单元添加唯一的 key 属性,方便比较(为什么不用 index,如果用 index 的话追加在后面不会影响,如果追加到前面会 影响性能)

getDerivedStateFromProps
static getDerivedStateFromProps(props, state)在调用 render 方法之前调用，无论是在初始安装还是后续更新。它应返回一个对象来更新状态，或者返回 null 以不更新任何内容。

根据 props 更新 state
这个生命周期可用于替代 componentWillReceiveProps

getSnapshotBeforeUpdate()
getSnapshotBeforeUpdate(prevProps, prevState)在最近呈现的输出被提交到例如 DOM 之前调用。它使组件可以在可能更改之前从 DOM 捕获一些信息（例如滚动位置）。此生命周期返回的任何值都将作为参数传递给 componentDidUpdate()。

hooks

lazy、suspense
lazy 需要跟 Suspence 配合使用。
lazy 实际上是帮助我们实现代码分割的功能。

由于有些内容，并不一定要在首屏展示，所以这些资源没有必要一开始就要去获取，那么这些资源就可以动态获取。
这样的话，相当于把不需要首屏展示的代码分割出来，减少首屏代码的体积，提升性能。

Suspence 很像 Error Boundary，不同的是 Error Boundary 是用来捕获错误，显示相应的 callback 组件。而 Suspence 是用来捕获还没有加载好的组件，并暂停渲染，显示相应的 callback。

# Webpack

webpack 打包 react vue,与自己的源代码分离使用 splitchunks

webpack 热更新:不用刷新浏览器而将新变更的模块替换掉旧的模块。

###### 1.Webpack Loader Plugin

**（loader ， plugin 分别什么作用，哪个配置可以把依赖包抽离出来，不打包进去）**

**【Loader】**：用于对模块源码的转换，loader 描述了 webpack 如何处理非 javascript 模块，并且在 buld 中引入这些依赖。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或者将内联图像转换为 data URL。比如说：CSS-Loader，Style-Loader 等。babel-loader 优雅降级配置 ES 高版本转成低版本

**【Plugin】**：是用于在 webpack 打包编译过程里，在对应的事件节点里执行自定义操作，比如资源管理、bundle 文件优化等操作,

**依赖包抽离** const ExtractTextWebapckPlugin= require(&quot;**extract-text-webpack-plugin**&quot;) module exclude node_modules

排除 excloude 排除 node_modules

loader 的使用很简单：

在 webpack.config.js 中指定 loader。module.rules 可以指定多个 loader，对项目中的各个 loader 有个全局概览。

loader 是运行在 NodeJS 中，可以用 options 对象进行配置。plugin 可以为 loader 带来更多特性。loader 可以进行压缩，打包，语言翻译等等。

loader 从模板路径解析，npm install node_modules。也可以自定义 loader，命名 XXX-loader。

语言类的处理器 loader：CoffeeScript，TypeScript，ESNext（Bable）,Sass,Less,Stylus。任何开发技术栈都可以使用 webpack。

**webpack 常用的 loader**

- 样式：style-loader、css-loader、less-loader、sass-loader 等

- 文件：raw-loader、file-loader 、url-loader 等

- 编译：babel-loader、coffee-loader 、ts-loader 等

- 校验测试：mocha-loader、jshint-loader 、eslint-loader 等

目的在于解决 loader 无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack 提供了很多开箱即用的插件：CommonChunkPlugin 主要用于提取第三方库和公共模块，避免首屏加载的 bundle 文件，或者按需加载的 bundle 文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建 bundle。

webpack 功能强大，难点在于它的配置文件，webpack4 默认不需要配置文件，可以通过 mode 选项为 webpack 指定了一些默认的配置，mode 分为：development/production，默认是 production。

插件可以携带参数，所以在 plugins 属性传入 new 实例。

**webpack 常用的 plugin**

webpack 内置`UglifyJsPlugin`，压缩和混淆代码。

webpack 内置`CommonsChunkPlugin`，提高打包效率，将第三方库和业务代码分开打包。

`ProvidePlugin`：自动加载模块，代替 require 和 import

html-webpack-plugin`可以根据模板自动生成html代码，并自动引用css和js文件`extract-text-webpack-plugin` 将 js 文件中引用的样式单独抽离成 css 文件

DefinePlugin` 编译时配置全局变量，这对开发模式和发布模式的构建允许不同的行为非常有用。

**【Mode】**可以在 config 文件里面配置，也可以在 CLI 参数中配置：webpack --mode=production（一般会选择在 CLI，也就是 npm scripts 里面进行配置）。

在 webpack4 以下版本，webpack3.XX，通过 plugins 进行环境变量的配置。

**【resolve】**模块，resolver 是个库，帮助 webpack 找到 bundle 需要引入的模块代码，打包时，webpack 使用 enhanced-resolve 来解析路径。

**2.webpack 优化**

多进程打包 安装插件 thread-loader parallel-webpack HappyPack

多进程压缩 parallel-uglify-plugin terser-webpack-plugin
资源 CDN 公用代码提取，使用 CDN 加载
动态 polyfill 动态 polyfill 指的是根据不同的浏览器，动态载入需要的 polyfill。

3.版本号上加一个^是什么意思

升级到最新的版本

# CSS Less

###### **1.flex 布局**

**（有个布局是：右边是固定宽度，左边是自适应，如何实现，如果是答了 flex：1，那么是 flex 下面的那个属性设置 1）**

flex 是由 flex-grow:1 父容器在主轴上还有多少剩余空间，

flex-shrink 当父元素的宽度大于所有子元素的宽度的和时（即父元素会有剩余空间），子元素如何分配父元素的剩余空间

flex-basis 基准值组成

###### **2.如果有个导航的吸顶效果，你这边如何实现**

设置 css:fixed 固定定位

判断滚动条滚动的距离大于导航条距顶部的距离,来判断是否实现吸顶,然后 addClass 添加样式

###### 3.less 的 hover 怎么简写

a&#123;
&amp;:hover &#123;&#125; //这里&amp;代表它的上一级就是 a
&#125;

###### 4.css 伪类 ::after,before 的应用场景

::before 和::after 必须配合 content 属性来使用，content 用来定义插入的内容，content 必须有值，至少是空。默认情况下，伪类元素的 display 是默认值 inline，可以通过设置 display:block 来改变其显示。

1.清除浮动 : 在浮动元素后面添加一个空的 Div 标签，然后在设置它的清除浮动要是，使用 after 伪元素

2.常见消息框 : 伪类 content:&#39; &#39; 伪类 4 条边必须宽度相同，而且其他三条边为 transparent 可以通过设置定位元素 left,top 值为 50%,translate(-50%,-50%) 来使任意宽高的元素居中。

div::before&#123;
content:&#39; &#39;;

3.阴影 : 通过设置 before，after 不同位置，不同旋转角度,要保证伪类的颜色及 z-index

div.outer::before,div.outer::after&#123;content:&#39;&#39;;
z-index:1;
width:50%;
height:3px;
position:absolute;
left:10px;
bottom:7px;
background-color:transparent;
box-shadow:5px 5px 10px rgba(0,0,0,0.5);
-webkit-transform:rotate(-3deg);

4.做出各种图形效果

#star-five:before &#123;
border-bottom: 80px solid red;
border-left: 30px solid transparent;
border-right: 30px solid transparent;
position: absolute;
height: 0;
width: 0;
top: -45px;
left: -65px;
content: &#39;&#39;;
transform: rotate(-35deg);
&#125;
#star-five:after &#123;
width: 0;
height: 0;
border-left: 100px solid transparent;
border-right: 100px solid transparent;
border-bottom: 70px solid yellow;
top: 7px;
left: -110px;
position: absolute;
display: block;
content: &#39;&#39;;
transform: rotate(-70deg);
&#125;

###### 5.弹性盒

display:flex 设置成弹性盒后，里面的子元素在一行显示

flex-direction:row 水平 | row-reverse | column 垂直 | column-reverse

flex-wrap:nowrap|wrap|wrap-reverse 换行，第一行在下方

flex-flow:是 flex-direction 和 flex-wrap 的简写形式。默认值为：row nowrap。

justify-content:flex-start|flex-end|center|space-between|space-around; 水平方向

align-items:flex-start|flex-end|center|baseline|stretch; 垂直方向

flex: order 排列顺序|flex-grow 放大比例|flex-shrink 缩小|flex-basis|flex|align-self

flex 属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。后两个属性可选 flex:1 flex-grow

align-self: auto | flex-start | flex-end | center | baseline | stretch;

###### 6.css 权重的计算

![1596852700371](C:\Users\28913\AppData\Roaming\Typora\typora-user-images\1596852700371.png)

权重叠加 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0， 所以不会存在 10 个 div 能赶上一个类选择器的情况

继承的权重是 0 1)如果选中了，那么以上面的公式来计权重。谁大听谁的。
2） 如果没有选中，那么权重是 0，因为继承的权重为 0.

当选择器冲突时，权重高的生效；当权重相同时，写在后头的会把前面的覆盖。

# 其他技术

###### **1.跨域**

**（是什么策略的显示，讲一下这个策略，再说一下解决方式）**

浏览器的同源策略

浏览器阻止从一个域去获取或者操作另外一个域上的文件

&gt; 1.后端代理（后端不存在跨域）

&gt; 2.CORS 解决跨域(xhr2)
&gt;
&gt; CORS 是一个 W3C 标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）。 它允许浏览器向跨源(协议 + 域名 + 端口)服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。
&gt;
&gt; 需要服务器(提供接口的源码里面)添加下面两句话。
&gt;
&gt; header(&#39;Access-Control-Allow-Origin:\*&#39;);
&gt;
&gt; header(&#39;Access-Control-Allow-Method:POST,GET&#39;);

&gt; **3.jsonp(json with padding)----前端常用的**

&gt; 4.其他跨域介绍--nginx(反向代理)

###### **2.WebSocket 是否有了解， 和普通接口 http 有什么区别**

**socket 是传输控制层协议，webSocket 是应用层协议**

WebSocket protocol 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信(full-duplex)。一开始的握 手需要借助 HTTP 请求完成。

HTTP 请求缺点：会导致过多不必要的请求，浪费流量和服务器资源，每一次请求、应答，都浪费了一定流量在 相同的头部信息上

然而 WebSocket 的出现可以弥补这一缺点。在 WebSocket 中，只需要服务器和浏览器通过 HTTP 协议进行一个握 手的动作，然后单独建立一条 TCP 的通信通道进行数据的传送。

**原理：（webSocket）**

WebSocket 同 HTTP 一样也是应用层的协议，但是它是一种双向通信协议，是建立在 TCP 之上的。

1. 浏览器、服务器建立 TCP 连接，三次握手。这是通信的基础，传输控制层，若失败后续都不执行。
2. TCP 连接成功后，浏览器通过 HTTP 协议向服务器传送 WebSocket 支持的版本号等信息。（开始前的 HTTP 握手）
3. 服务器收到客户端的握手请求后，同样采用 HTTP 协议回馈数据。
4. 当收到了连接成功的消息后，通过 TCP 通道进行传输通信。
   WebSocket 与 HTTP 的关系

**相同点:**

1. 都是一样基于 TCP 的，都是可靠性传输协议。

   2. 都是应用层协议

   不同点:

   3. WebSocket 是双向通信协议，模拟 Socket 协议，可以双向发送或接受信息。HTTP 是单向的。
   4. WebSocket 是需要握手进行建立连接的。

###### 3.错误调试工具

F12 断点 错误附近输出打印 火狐中的 firebug IE 开发者工具 Emmet

# 开发环境

###### **1.eslint 规则**

**（你怎么修改某些规则）**https://www.jianshu.com/p/f8d2ef372adf

Eslint 是一个 JavaScript 验证工具,有了它可以让你的编辑器像 ide 一样进行一些静态的错误提示功能.

npm install eslint -g

某些文件关闭 eslint 检测 在文件的最顶端加上注释/_eslint-disable_/

关闭某一行代码的 eslint 检查 // eslint-disable-next-line

.eslintrc.json 配置 rules 选项

###### **2.git**

**（版本回退是什么命令，哪个命令查看已删除的提交 commitId）**

git-reset 版本回退

git reset --hard xxx 回到上一个版本

git reset --soft xxx 该命令将最近一次提交节点的提交记录回退到暂存区

git reset --mixed xxx 是将最近一次提交节点记录回退到工作区

git log 与 git reflog 查看历史记录（被删除的历史 commit ID）

**Git 常用命令**

git branch 查看本地所有分支
git status 查看当前状态 
git commit 提交 
git branch -a 查看所有的分支
git branch -r 查看本地所有分支
git commit -am &quot;init&quot; 提交并且加注释 
git remote add origin git@192.168.1.119:ndshow
git push origin master 将文件给推到服务器上 
git remote show origin 显示远程库origin里的资源 
git push origin master:develop
git push origin master:hb-dev 将本地库与服务器上的库进行关联 
git checkout --track origin/dev 切换到远程dev分支
git branch -D master develop 删除本地库develop
git checkout -b dev 建立一个新的本地分支dev
git merge origin/dev 将分支dev与当前分支进行合并
git checkout dev 切换到本地dev分支
git remote show 查看远程库
git add .
git rm 文件名(包括路径) 从git中删除指定文件
git clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来
git config --list 看所有用户
git ls-files 看已经被提交的
git rm [file name] 删除一个文件
git commit -a 提交当前repos的所有的改变
git add [file name] 添加一个文件到git index
git commit -v 当你用－v参数的时候可以看commit的差异
git commit -m &quot;This is the message describing the commit&quot; 添加commit信息
git commit -a -a是代表add，把所有的change加到git index里然后再commit
git commit -a -v 一般提交命令
git log 看你commit的日志
git diff 查看尚未暂存的更新
git rm a.a 移除文件(从暂存区和工作区中删除)
git rm --cached a.a 移除文件(只从暂存区中删除)
git commit -m &quot;remove&quot; 移除文件(从Git中删除)
git rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)
git diff --cached 或 $ git diff --staged 查看尚未提交的更新
git stash push 将文件给push到一个临时空间中
git stash pop 将文件从临时空间pop下来
\---------------------------------------------------------
git remote add origin git@github.com:username/Hello-World.git
git push origin master 将本地项目给提交到服务器中
\-----------------------------------------------------------
git pull 本地与服务器端同步
\-----------------------------------------------------------------
git push (远程仓库名) (分支名) 将本地分支推送到服务器上去。
git push origin serverfix:awesomebranch
\------------------------------------------------------------------
git fetch 相当于是从远程获取最新版本到本地，不会自动merge
git commit -a -m &quot;log_message&quot; (-a是提交所有改动，-m是加入log信息) 本地修改同步至服务器端 ：
git branch branch_0.1 master 从主分支master创建branch_0.1分支
git branch -m branch_0.1 branch_1.0 将branch_0.1重命名为branch_1.0
git checkout branch_1.0/master 切换到branch_1.0/master分支
du -hs

###### git 场景问题

提交暂存区 git add 出错 git reset HEAD &lt;文件名&gt; 回退

提交本地仓库 git commit 出错 : 1.更改 commit 信息:git commit --amend -m“新提交消息” 2.漏提交 : git add missed-file // missed-file 为遗漏提交文件
git commit --amend --no-edit //--no-edit 提交消息不会更改

3.git reset --hard commit_id git log 查看提交的版本

git revert 是提交一个新的版本

git fetch 将远程主机的更新全部放到本地中

**git revert 和 git reset 的区别**

(1)git revert 是用一次新的 commit 来回滚之前的 commit，git reset 是直接删除指定的 commit。

(2)git revert 是用一次逆向的 commit“中和”之前的提交 ,合并的时候回滚的变化不会出现

git reset 是之间把某些 commit 在某个 branch 上删除 合并时候回滚的 commit 会被引入

###### **3.nodejs,**

1.Node 不是一个后端语言，但是它可以做类似后端语言的功能 2. Node 是使用谷歌 V8 引擎 3. Node 是 js 的一个运行环境 4. Node 具有非阻塞 I/O 特点 5. Node 采用了 Common.js 规范

node+koa2 node+express

用于快速构建 Node.js 项目

node.js 是一个基于 Chrome V8 引擎的 JavaScirpt 运行环境。

Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型,使其轻量又高效\*\*

Node.js 基于 commonjs 规范

事件驱动： 任务执行，发布者，订阅者，事件驱动 .

异步（非阻塞）： 执行某一个任务的同时也可以执行其他任务

同步（阻塞）： 执行某一个任务，这个任务如果没有执行完成，其他任务必须等待

I/O: 输入/输出（ 数据库操作，文件系统操作等 ） - 服务器的环境

非阻塞 I/O 模型： 当使用 Node.js 来实现数据库操作、文件系统等操作时，要进行的异步操作，异步操作的核心传统实现方式就是回调函数和事件。

Node.js 的包管理工具 npm

优点：Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，异步编程，使其轻量又高效。

缺点：单进程，单线程，只支持单核 cpu，不能充分的利用多核 cpu 服务器。一旦这个进程崩掉，那么整个 web 服务就崩掉了。

内置模块 http 是用于创建一个能够处理和响应 http 响应的服务

fs 用于对系统文件及目录进行读写操作。

path 提供了一些用于处理文件路径的小工具

Url：帮助我们对提交上来的 url 进行解析处理

querystring 提供用于解析和格式化 URL 查询字符串的工具。qs.parse() qs.stringify()

###### **4.typescript 语法**

TypeScript 具有类型系统，且是 JavaScript 的超集。 它可以编译成普通的 JavaScript 代码。 TypeScript 支持任意浏览器，任意环境，任意系统并且是开源的。

npm install -g typescript

tsc --init 生成 tsconfig.json 配置文件

基础数据类型
_ number、string、boolean、null 、undefined
_ any 表示任意类型 \* void 表示空类型

- 内置对象类型

  - Array Boolean
  - HTMLElement
  - HTMLDivElement

- 自定义类型

  - 接口 interface

  - 类

  - 泛型 未来的类型定义的时候不知道是什么类型，调用的时候才知道

  - 枚举 enum 类型是对 JavaScript 标准数据类型的一个补充

  - never 类型表示的是那些永不存在的值的类型。

    readonly :只读属性,不可修改

    sex? :表示 sex 是一个可传属性,可以有也可以没有

    [propName: string]: any; 表示新增的属性可以是任意类型

    arr3: Array&lt;number&gt; 数组类型定义

    arr2: (number | string)[]

    fn (a: number, b: number) : number 函数类型定义

###### **5.linux 命令**

pwd:输入 pwd 命令，Linux 会输出当前目录。

ls 命令用来查看目录的内容。

cd 命令用来改变所在目录。

cat 命令可以用来合并文件，也可以用来在屏幕上显示整个文件的内容。

grep 命令的最大功能是在一堆文件中查找一个特定的字符串。

**touch 命令用来创建新文件**

cp 命令用来拷贝文件

mv 命令用来移动文件

rm 命令用来删除文件。

mkdir 创建文件夹创建目录

# http

###### 1.http2.0，https 连接，对称加密非对称加密

https://blog.csdn.net/qq_33203555/article/details/85211595

http 概述:超文本传输协议,是互联网上应用最为广泛的一种网络协议

http 的缺点 1.通信使用明文可能会被窃听。 2.不验证通信方的身份可能遭遇伪装。 3.无法证明报文的完整性，可能已遭篡改。

https 就是在安全的传输层上发送的 http。它在将 http 报文发送给 TCP 之前，先将其发送给了一个安全层 ，对其进行加密。http 安全层是通过 ssl 及其现代替代协议 TSL 来实现的。

https 的优点
（1）使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；
（2）HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。

https 的缺点
但是 https 因为加了层 ssl，所以在效率方面比较低，会使页面加载的时长延长近 50%,也会增加 10-20%的耗电。
需要安装证书，在一定基础上增加部署费用，并且报文加密解密对数据传递有一点的效率影响。

http/2.0 的目标是改善用户加载页面的时候更快

HTTP/2 采用二进制格式而非文本格式

HTTP/2 是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行

对称密钥加密是指加密和解密使用同一个密钥的方式 , 一方通过密钥将信息加密后，把密文传给另一方，另一方通过这个相同的密钥将密文解密，转换成可以理解的明文

非对称加密是加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。

# 项目

###### **注册登录是怎么实现的**

1.登陆注册要做成受控组件，组件定义 state，和表单绑定

2.redux-saga 调用数据请求，发送 action 修改数据，useEffect 中 dispatch 发送数据请求，后端比对用户名是否重复，返回 status

3.前端根据返回的信息成功跳转登陆页

4.登陆发送数据请求，数据库对比用户名密码是否正确 根据后端返回的结果进入首页

5.setCookie 将用户登录名密码 token 存 cookie 中 通过 JWT(Json web token)

6.免密登陆 getCookie 获取 token 发给后端对比 根据返回结果是否自动登陆

7.注册通过 Ant Design ，validator 中进行表单正则的验证

8.用户体验 注册的时候跳转其他页面的时候给用户提示是否需要跳转，避免因为跳转后导致注册信息没有了 用组件内后置守卫做

如果输入框都没有填信息,不拦截跳转 如果用户输入信息,弹窗提示,点确定,跳转,点取消,不跳转

###### **项目中遇到什么困难,怎么解决的?**

1.react 中配置二级路由 地址变化 但是界面不更新

使用 dva/router 中的 withRouter 高阶组件

2.图表联动怎么实现

我们只需要把当前被选中图表的事件，直接发给其他图表即可，然后判断被选中的图表是哪个作为区分，功能即可实现

onTouchEvent(event) 普通事件传递

3.产品经理要求智能匹配产品

找网上类似功能的网站 查看源码 和主管讨论

-需要一个设计一个投资习惯和风险承受能力测试,

-从后端获取这个客户测试的结果 以及客户平常投资的习惯 生成不同的关键字

-根据关键字从数据库中匹配产品 展示界面

4.后台管理系统遇到遇到什么奇葩的需求

###### 后台管理系统和普通 App 面向用户的区别

toB 和 toC 的项目

面向企业内部和面向用户的项目的区别

后台管理系统权限比较细 App 高并发比较多 做性能优化

###### 自我介绍

您好经理 我叫黄润 今天来贵公司面试前端工程师岗位 有 3 年的开发经验

之前在复融科技有限公司,做前端开发的,做过的项目有

独立开发 PC 端的后台管理系统,是一个从申请贷款到贷款审批再到签约的一套流程,项目中用到的技术栈主要有 React+TS, dva 脚手架,less 编写样式,Ant Design UI 框架,redux 状态管理,antv 组件库 G2 和 G6 可视化工具,webpack 包管理工具,gitlab 代码管理工具

移动端代贝贝 App 的开发,代贝贝是一款商城项目,包含信用贷 税贷等多种贷款,主要负责首页 ,订单页面的逻辑实现,项目中用到 React 框架, 使用 TS 开发,Vant 组件库,Axios 数据请求,redux 和 redux-saga,react-router 路由实现,webpack 包管理工具,gitlab 代码管理工具

人人贷财富(人人答)微信小程序开发,独立完成每日一答小程序开发,项目中用到的技术 wxml+wxss 完成页面搭建,vant weapp UI 组件库 wx.request 封装的数据请求

另外还掌握微信小程序和微信公众号开发,

希望成为贵公司的一员 努力工作和公司一起发展的更好

wxml 小程序框架设计的标签语言 写组件的 wxss 写组件样式的

###### 阿里国际 UED 项目

一个基于 React、Redux 的 Engine 库，使用符合 Schema 规范的 Json 数据结构来描述页面 一个基于上述的 Engine 库的可视化编辑器，可以通过简单的拖拽，优雅、便捷、高效、灵活地搭建页面 一个使用 Node.js 开发的类似 falcor 的隔离现有前后端的 Request-Layer 沉淀大量地可供复用基础业务组件 一整套基于上述技术地项目开发落地方案 我们的技术栈

UI 即用户界面，也称人机界面。是指用户和某些系统进行交互方法的集合

UE 或 UX 就是用户体验

UED 即用户体验设计

UCD 即以用户为中心的设计就是在进行产品设计、开发、维护时从用户的需求和用户的感受出发，围绕使用者为中心进行产品设计、开发及维护，以产品迎合使用者，而不是让使用者去适应产品

IxD 或 IaD 就是交互设计 目的是让产品易用

GUI 即图形化使用者介面是指采用图形方式显示的操作使用者介面

# 注册登录是怎么实现的

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.登陆注册要做成受控组件，组件定义state，和表单绑定</span><br><span class="line"></span><br><span class="line">2.redux-saga调用数据请求，发送action修改数据，</span><br><span class="line">  useEffect中dispatch发送数据请求，后端比对用户名是否重复，返回state</span><br><span class="line"></span><br><span class="line">3.前端根据返回的信息成功跳转登陆页</span><br><span class="line"></span><br><span class="line">4.登陆发送数据请求，数据库对比用户名密码是否正确, 根据后端返回的结果进入首页</span><br><span class="line"></span><br><span class="line">5.setCookie将用户登录名密码token存cookie中   通过JWT(Json web token)</span><br><span class="line"></span><br><span class="line">6.免密登陆  getCookie获取token    发给后端对比    根据返回结果是否自动登陆</span><br><span class="line"></span><br><span class="line">7.注册通过Ant  Design ，validator中进行表单正则的验证</span><br><span class="line"></span><br><span class="line">8.用户体验  注册的时候跳转其他页面的时候给用户提示是否需要跳转，避免因为跳转后导致注册信息没有了</span><br><span class="line">  用组件内后置守卫做</span><br><span class="line">  如果输入框都没有填信息,不拦截跳转如果用户输入信息,弹窗提示,点确定,跳转,点取消,不跳转</span><br></pre></td></tr></table></figure>

# 项目中遇到什么困难,怎么解决的?

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.react中配置二级路由   地址变化  但是界面不更新</span><br><span class="line">	使用dva/router中的withRouter高阶组件解决的</span><br><span class="line"></span><br><span class="line">2.图表联动怎么实现</span><br><span class="line">	我们只需要把当前被选中图表的事件，直接发给其他图表即可，然后判断被选中的图表是哪个作为区分</span><br><span class="line">	onTouchEvent(event)普通事件传递</span><br><span class="line"></span><br><span class="line">3.产品经理要求智能匹配产品</span><br><span class="line">	找网上类似功能的网站  查看源码  和主管讨论</span><br><span class="line">	需要一个设计一个投资习惯和风险承受能力测试,</span><br><span class="line">	从后端获取这个客户测试的结果   以及客户平常投资的习惯   生成不同的关键字</span><br><span class="line">	根据关键字从数据库中匹配产品   展示界面</span><br><span class="line"></span><br><span class="line">4.后台管理系统遇到遇到什么奇葩的需求</span><br></pre></td></tr></table></figure>

# 后台管理系统和普通 App 面向用户的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">toB和toC的项目</span><br><span class="line"></span><br><span class="line">面向企业内部和面向用户的项目的区别</span><br><span class="line"></span><br><span class="line">后台管理系统权限比较细   App高并发比较多  做性能优化</span><br></pre></td></tr></table></figure>

# 正则表达式

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\d 匹配数字  \D 匹配非数字  \w 匹配数字字母下划线 \W 匹配非数字字母下划线</span><br><span class="line">\n 匹配一个换行符 \s 匹配任何不可见字符包括空格、制表符、换页符等等  \S 匹配任何可见字符</span><br><span class="line">^ 匹配输入字行首   $匹配输入行尾 *(0到多次)匹配前面的子表达式任意次</span><br><span class="line">+(1到多) 匹配前面的子表达式一次或多次(大于等于1次）</span><br><span class="line">?(0或1)匹配前面的子表达式零次或一次</span><br><span class="line">&#123;n&#125;n是一个非负整数，匹配确定的n次</span><br><span class="line">&#123;n,&#125;n是一个非负整数。至少匹配n次</span><br></pre></td></tr></table></figure>

# Ajax

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">我对 ajax 的理解是，它是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。</span><br><span class="line">创建步骤：创建xhr对象-&gt;配置Ajax请求地址通过open方法-&gt;发送请求通过send方法-&gt;监听请求，接收响应</span><br><span class="line">//1：创建Ajax对象</span><br><span class="line">var xhr = window.XMLHttpRequest?new XMLHttpRequest():new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;);// 兼容IE6及以下版本</span><br><span class="line">//2：配置 Ajax请求地址</span><br><span class="line">xhr.open(&#x27;get&#x27;,&#x27;index.xml&#x27;,true);</span><br><span class="line">//3：发送请求</span><br><span class="line">xhr.send(null); // 严谨写法</span><br><span class="line">//4:监听请求，接受响应</span><br><span class="line">xhr.onreadysatechange=function()&#123;</span><br><span class="line">     if(xhr.readySate==4&amp;&amp;xhr.status==200 || xhr.status==304)</span><br><span class="line">          console.log(xhr.responseXML)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

# js 延迟加载的方式

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">js 的加载、解析和执行会阻塞页面的渲染过程，因此我们希望 js 脚本能够尽可能的延迟加载，提高页面的渲染速度。</span><br><span class="line">我了解到的几种方式是：</span><br><span class="line"></span><br><span class="line">1、将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</span><br><span class="line">2、给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</span><br><span class="line">3、给 js 脚本添加 async属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</span><br><span class="line">4、动态创建 DOM 标签的方式，我们可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</span><br></pre></td></tr></table></figure>

# 模块化开发的理解

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，</span><br><span class="line">所以并没有模块的概念，但随着程序越来越复杂，代码的模块化开发变得越来越重要。</span><br><span class="line"></span><br><span class="line">由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，</span><br><span class="line">但是这种方式容易造成全局变量的污染，并且模块间没有联系。</span><br><span class="line"></span><br><span class="line">后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，</span><br><span class="line">但是这种办法会暴露所有的所有的模块成员，外部代码可以修改内部属性的值。</span><br><span class="line"></span><br><span class="line">现在最常用的是立即执行函数的写法，通过利用闭包来实现模块私有作用域的建立，同时不会对全局作用域造成污染。</span><br></pre></td></tr></table></figure>

# js 的几种模块规范

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">js 中现在比较成熟的有四种模块加载方案：</span><br><span class="line"></span><br><span class="line">第一种是 CommonJS 方案，它通过 require 来引入模块，通过 module.exports 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，它是以同步的方式来引入模块的，因为在服务端文件都存储在本地磁盘，所以读取非常快，所以以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</span><br><span class="line"></span><br><span class="line">第二种是 AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。</span><br><span class="line"></span><br><span class="line">第三种是 CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。</span><br><span class="line"></span><br><span class="line">第四种方案是 ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。</span><br></pre></td></tr></table></figure>

# AMD 和 CMD 规范的区别？

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">它们之间的主要区别有两个方面。</span><br><span class="line">第一个方面是在模块定义时对依赖的处理不同。AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require。</span><br><span class="line">第二个方面是对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句</span><br><span class="line">的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</span><br></pre></td></tr></table></figure>

# ES6 模块与 CommonJS 模块、AMD、CMD 的差异

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.CommonJS 模块输出的是一个值的拷贝，</span><br><span class="line">ES6 模块输出的是值的引用。</span><br><span class="line">CommonJS 模块输出的是值的，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</span><br><span class="line">ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</span><br><span class="line">2.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</span><br><span class="line">而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</span><br></pre></td></tr></table></figure>

# requireJS 的核心原理

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数</span><br></pre></td></tr></table></figure>

# js 的原理(运行机制)

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">首先js是单线程运行的，在代码执行的时候，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。</span><br><span class="line">在执行同步代码的时候，如果遇到了异步事件，js引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务</span><br><span class="line"></span><br><span class="line">所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。</span><br><span class="line">同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</span><br><span class="line">异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有等主线程任务执行完毕，&quot;任务队列&quot;开始通知主线程，请求执行任务，该任务才会进入主线程执行。</span><br><span class="line"></span><br><span class="line">当同步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。</span><br><span class="line">任务队列可以分为宏任务对列和微任务对列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务对列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。</span><br><span class="line">当微任务对列中的任务都执行完成后再去判断宏任务对列中的任务。</span><br><span class="line"></span><br><span class="line">异步运行机制如下：</span><br><span class="line">（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</span><br><span class="line">（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。</span><br><span class="line">	只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</span><br><span class="line">（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。</span><br><span class="line">	那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</span><br><span class="line">（4）主线程不断重复上面的第三步。</span><br></pre></td></tr></table></figure>

# arguments 的对象

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arguments对象是函数中传递的参数值的集合。它是一个类似数组的对象，因为它有一个length属性，</span><br><span class="line">我们可以使用数组索引表示法arguments[1]来访问单个值，但它没有数组中的内置方法，</span><br><span class="line">如：forEach、reduce、filter和map。</span><br><span class="line"></span><br><span class="line">我们可以使用Array.prototype.slice将arguments对象转换成一个数组。</span><br><span class="line"></span><br><span class="line">Array.prototype.slice.call(arguments)</span><br></pre></td></tr></table></figure>

# V8 引擎的垃圾回收机制

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">v8的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。</span><br><span class="line">新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。</span><br><span class="line">新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge(斯盖V橘) 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：</span><br><span class="line">（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。</span><br><span class="line">（2）如果对象不存活，则释放对象的空间。</span><br><span class="line">（3）最后将 From 空间和 To 空间角色进行交换。</span><br><span class="line">新生代对象晋升到老生代有两个条件：</span><br><span class="line">（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。</span><br><span class="line">（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。</span><br><span class="line"></span><br><span class="line">老生代采用了标记清除法和标记压缩法。</span><br><span class="line">标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。</span><br><span class="line">由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行</span><br></pre></td></tr></table></figure>

# 垃圾回收机制的两种方法

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数。</span><br><span class="line"></span><br><span class="line">1、标记清除</span><br><span class="line">　　这是javascript中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。</span><br><span class="line">　　垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</span><br><span class="line"></span><br><span class="line">2、引用计数</span><br><span class="line">　　另一种不太常见的垃圾回收策略是引用计数。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。</span><br></pre></td></tr></table></figure>

# 会造成内存泄漏的操作

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.意外的全局变量</span><br><span class="line">2.被遗忘的计时器或回调函数</span><br><span class="line">3.脱离 DOM 的引用</span><br><span class="line">4.闭包</span><br><span class="line"></span><br><span class="line">第一种情况是我们由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</span><br><span class="line">第二种情况是我们设置了setInterval定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</span><br><span class="line">第三种情况是我们获取一个DOM元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</span><br><span class="line">第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</span><br></pre></td></tr></table></figure>

# ECMAScript(ES)

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ECMAScript 是编写脚本语言的标准，ECMA（European Computer Manufacturers Association）规定一下他的标准，因为当时有java语言了，又想强调这个东西是让ECMA这个人定的规则，所以就这样一个神奇的东西诞生了，这个东西的名称就叫做ECMAScript。</span><br><span class="line">javaScript = ECMAScript + DOM + BOM</span><br></pre></td></tr></table></figure>

# ES2015(ES6)新特性

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">块作用域</span><br><span class="line">类</span><br><span class="line">箭头函数</span><br><span class="line">模板字符串</span><br><span class="line">对象解构</span><br><span class="line">Promise</span><br><span class="line">模块</span><br><span class="line">Symbol</span><br><span class="line">代理（proxy）Set</span><br><span class="line">函数默认参数</span><br><span class="line">rest</span><br><span class="line">扩展运算符</span><br><span class="line">数组和对象的扩展</span><br></pre></td></tr></table></figure>

# ES2016(ES7)新特性

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">求幂运算符（**）</span><br><span class="line">                (因颗录此)</span><br><span class="line">Array.prototype.includes()方法</span><br><span class="line">	数组原型的方法,查找一个数值是否在数组中，只能判断一些简单类型的数据，对于复杂类型的数据无法判断。</span><br><span class="line">	该方法接受两个参数，分别是查询的数据和初始的查询索引值。</span><br></pre></td></tr></table></figure>

# ES2017(ES8)新特性

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">async  await</span><br><span class="line"></span><br><span class="line">函数参数列表结尾允许逗号</span><br><span class="line">	es2017允许函数对象的定义调用时参数可以加入尾逗号，以及json对象array对象都允许</span><br><span class="line"></span><br><span class="line">Object.values()</span><br><span class="line">	values: [obj]，返回obj自身可枚举属性的属性值的集合</span><br><span class="line">	   (安吹斯)</span><br><span class="line">Object.entries()</span><br><span class="line">	entries：[obj], 与values类似，返回的一个2元素的数组</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptors()</span><br><span class="line">	getOwnpropertyDescriptors: [obj]，返回obj对象的属性描述符</span><br><span class="line">	(get 哦 泼破踢 迪斯亏不踢斯)</span><br><span class="line">String padding:</span><br><span class="line">	padStart()和padEnd()，填充字符串达到当前长度</span><br><span class="line">	在字符串首位开始添加string直到满足length为止并返回新的字符串</span><br><span class="line"></span><br><span class="line">ShareArrayBuffer和Atomics对象，用于从共享内存位置读取和写入</span><br><span class="line">(夏尔 啊锐 八法儿)	 (啊偷没此)</span><br></pre></td></tr></table></figure>

# ES2018(ES9)新特性

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">异步迭代</span><br><span class="line">Promise.finally()</span><br><span class="line">		(饭的嘞)</span><br><span class="line">Rest/Spread 属性</span><br><span class="line">(锐斯特)(斯破锐的)</span><br><span class="line">正则表达式命名捕获组（Regular Expression Named Capture Groups）</span><br><span class="line">正则表达式反向断言（lookbehind）</span><br><span class="line">正则表达式dotAll模式</span><br><span class="line">正则表达式 Unicode 转义</span><br><span class="line">		 (右内扣的)</span><br><span class="line">非转义序列的模板字符串</span><br></pre></td></tr></table></figure>

# ES2019(ES10)新特性

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">行分隔符（U + 2028）和段分隔符（U + 2029）符号现在允许在字符串文字中，与JSON匹配</span><br><span class="line">更加友好的JSON.stringify</span><br><span class="line">新增了Array的flat()方法和flatMap()方法</span><br><span class="line">新增了String的trimStart()方法和trimEnd()方法</span><br><span class="line">Object.fromEntries()</span><br><span class="line">Symbol.prototype.description</span><br><span class="line">String.prototype.matchAll</span><br><span class="line">Function.prototype.toString()现在返回精确字符，包括空格和注释</span><br><span class="line">简化try&#123;&#125; catch&#123;&#125;,修改catch绑定</span><br><span class="line">新的基本数据类型BigInt</span><br><span class="line">globalThis</span><br><span class="line">import()</span><br><span class="line">Legacy RegEx</span><br><span class="line">私有的实例方法和访问器</span><br></pre></td></tr></table></figure>

# ES2020(ES11)新特性

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">私有变量</span><br><span class="line">	ES11在类中新增私有变量控制符#，在内部变量或者函数前添加一个hash符号#，</span><br><span class="line">	可以将它们设置为私有属性，只能在类的内部可以使用。</span><br><span class="line">空值合并运算符</span><br><span class="line">	空值合并操作符就是 ?? :如果左侧的值为null或者undefined就返回左侧的值，如果没有就返回右侧的值</span><br><span class="line">可选链操作符</span><br><span class="line">	可选链操作符 (?.) :如果左侧表达式有值，就会继续访问右侧的字段</span><br><span class="line">BigInt</span><br><span class="line">	使用BigInt的方式有两种：</span><br><span class="line">		1.在数字后面加n</span><br><span class="line">		2.使用BigInt函数</span><br><span class="line">动态导入</span><br><span class="line"></span><br><span class="line">globalThis</span><br><span class="line">	提供一种标准化的方式去访问全局对象，可以在任意上下文中获取全局对象自身，并且不用担心环境的问题</span><br><span class="line">Promise.all缺陷与Promise.allSettled</span><br><span class="line">	promise.all可以并发执行异步任务,如果其中某个任务执行出现了异常，所有任务都会over，Promise会直接进入reject状态</span><br><span class="line">	使用Promise.allSettled，它会创建一个新的promise，在所有promise完成后返回一个包含每个promise结果的数组</span><br></pre></td></tr></table></figure>

# var,let 和 const 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.var声明的变量会挂载在window上，而let和const声明的变量不会：</span><br><span class="line">2.var声明变量存在变量提升，let和const不存在变量提升</span><br><span class="line">3.let和const声明形成块作用域   alera(a) var a =1    undeinend</span><br><span class="line">                            alera(a) let a = 1</span><br><span class="line">4.同一作用域下let和const不能声明同名变量，而var可以</span><br><span class="line"></span><br><span class="line">const</span><br><span class="line">	一旦声明必须赋值,不能使用null占位。</span><br><span class="line">	声明后不能再修改</span><br><span class="line">	如果声明的是复合类型数据，可以修改其属性</span><br><span class="line"></span><br><span class="line">暂存死区</span><br><span class="line">var a = 100;</span><br><span class="line">if(1)&#123;</span><br><span class="line">    a = 10;</span><br><span class="line">    //在当前块作用域中存在a使用let/const声明的情况下，给a赋值10时，只会在当前作用域找变量a，</span><br><span class="line">    // 而这时，还未到声明时候，所以控制台Error:a is not defined</span><br><span class="line">    let a = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

# 箭头函数

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">箭头函数表达式的语法比函数表达式更简洁</span><br><span class="line"></span><br><span class="line">箭头函数没有自己的this值。箭头函数里的this指向的是父级的this.</span><br><span class="line"></span><br><span class="line">箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</span><br><span class="line"></span><br><span class="line">在箭头函数版本中，当只有一个表达式或值需要返回，我们只需要()括号，</span><br><span class="line">不需要 return 语句，箭头函数就会有一个隐式的返回。</span><br><span class="line"></span><br><span class="line">如果我们在一个箭头函数中有一个参数，则可以省略括号。</span><br><span class="line"></span><br><span class="line">箭头函数不能访问arguments对象。所以调用第一个getArgs函数会抛出一个错误。</span><br><span class="line">相反，我们可以使用rest参数来获得在箭头函数中传递的所有参数。</span><br></pre></td></tr></table></figure>

# 模板字符串

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">模板字符串是在 JS 中创建字符串的一种新方法。我们可以通过使用反引号使模板字符串化。</span><br><span class="line"></span><br><span class="line">在ES5版本中，我们需要添加\n以在字符串中添加新行。在模板字符串中，我们不需要这样做。</span><br><span class="line"></span><br><span class="line">在 ES5 版本中，如果需要在字符串中添加表达式或值，则需要使用`+`运算符。</span><br><span class="line">在模板字符串s中，我们可以使用$&#123;expr&#125;嵌入一个表达式，这使其比 ES5 版本更整洁。</span><br></pre></td></tr></table></figure>

# 对象解构

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对象解构是从对象或数组中获取或提取值的一种新的、更简洁的方法</span><br><span class="line">我们还可以为属性取别名</span><br><span class="line">let &#123; firstName: fName, position &#125; = employee;</span><br><span class="line">当然如果属性值为 undefined 时，我们还可以指定默认值</span><br><span class="line">let &#123; firstName = &quot;Mark&quot; &#125; = employee;</span><br></pre></td></tr></table></figure>

# Set 及应用场景

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">一、创建Set对象实例</span><br><span class="line">Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用</span><br><span class="line">1.构造函数	 	   (伊特波)</span><br><span class="line">	语法：new Set([iterable])</span><br><span class="line">	参数：iterable 如果传递一个可迭代对象，它的所有元素将被添加到新的Set中；</span><br><span class="line">		 如果不指定此参数或其值为null，则新的 Set为空</span><br><span class="line"></span><br><span class="line">二、Set实例属性</span><br><span class="line">	size属性将会返回Set对象中元素的个数</span><br><span class="line"></span><br><span class="line">三、Set实例方法</span><br><span class="line">1.add() 方法用来向一个 Set 对象的末尾添加一个指定的值</span><br><span class="line">	语法：mySet.add(value)</span><br><span class="line">	参数：value 必需，需要添加到 Set 对象的元素的值</span><br><span class="line">2.delete() 方法可以从一个 Set 对象中删除指定的元素</span><br><span class="line">	语法：mySet.delete(value)</span><br><span class="line">	参数：value 将要删除的元素</span><br><span class="line">	返回值：成功删除返回 true，否则返回 false</span><br><span class="line">3.clear() 方法用来清空一个 Set 对象中的所有元素</span><br><span class="line">	语法：mySet.clear()</span><br><span class="line">4.has() 方法返回一个布尔值来指示对应的值value是否存在Set对象中</span><br><span class="line">	语法：mySet.has(value)</span><br><span class="line">	参数：value 必须，是否存在于Set的值</span><br><span class="line">	返回值：如果指定的值（value）存在于Set对象当中，返回true; 否则返回 false</span><br><span class="line">5.entries() (安吹斯)</span><br><span class="line">	语法：mySet.entries()</span><br><span class="line">	返回值：一个新的包含 [value, value] 形式的数组迭代器对象，value 是给定集合中的每个元素，</span><br><span class="line">		  迭代器 对象元素的顺序即集合对象中元素插入的顺序</span><br><span class="line">6.values()</span><br><span class="line">	语法：mySet.values() 或者 mySet.keys()</span><br><span class="line">	返回值：返回一个 Iterator(因特瑞特) 对象，这个对象以插入Set对象的顺序包含了原 Set 对象里的每个元素</span><br><span class="line">7.forEach()</span><br><span class="line">	语法：mySet.forEach(callback[, thisArg]) (this傲歌)</span><br><span class="line">	参数：callback 每个元素都会执行的函数</span><br><span class="line">     	 thisArg 当执行callback函数时候，可以当作this来使用</span><br><span class="line">5、什么是WeakSet()？</span><br><span class="line">和Set结构类似，也是不重复的值的集合，但WeakSet的成员只能是对象(null 除外)。</span><br><span class="line">而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</span><br><span class="line"></span><br><span class="line">应用场景:</span><br><span class="line">1、简单数组去重</span><br><span class="line">2、JSON数组去重</span><br><span class="line">	JSON数组是比较常见的一种数据结构，形如[&#123;…&#125;,…&#123;…&#125;]</span><br><span class="line">	假如你需要统计某个属性中不同的值。</span><br><span class="line">	step1:先使用.map将JSON数组变成简单数组，然后用set执行去重</span><br><span class="line">	step2: 由于生成的Set属于可迭代对象，所以可以使用数组解构符进行解构</span><br><span class="line">3、二维数组去重</span><br><span class="line">	我们可以将Set用作存储每项的唯一值，结合reduce进行对比，得出无重复的项目。</span><br><span class="line">	当然，上面的代码缺点还是不少的。因为只是简单地将其转变成字符串作为对比的键，</span><br><span class="line">	所以不能区分[1,2]、[‘1’ ,‘2’]、[‘1,2’]等子数组。</span><br><span class="line">4、数组之间的对比</span><br><span class="line">	Set的特性不单单可以可以用于单数组，对于数组之间的比较也是十分在行。</span><br><span class="line"></span><br><span class="line">什么是WeakSet()？</span><br><span class="line">	和Set结构类似，也是不重复的值的集合，但WeakSet的成员只能是对象。</span><br><span class="line"></span><br><span class="line">WeakSet的API：</span><br><span class="line">	add() 	 //增</span><br><span class="line">	delete() //删</span><br><span class="line">	has() 	 //是否存在</span><br><span class="line"></span><br><span class="line">为什么WeakSet不可遍历？</span><br><span class="line">	因为WeakSet的成员都是弱引用，随时可能消失，成员是不稳定的。</span><br><span class="line"></span><br><span class="line">WeakSet的用处：</span><br><span class="line">	使用ws储存DOM节点，就不用担心节点从文档移除时，会引发内存泄漏(即在被移除的节点上绑定的click等事件)。</span><br></pre></td></tr></table></figure>

# Proxy

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”</span><br></pre></td></tr></table></figure>

# 函数式编程

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数式编程（通常缩写为FP）是通过编写纯函数，避免共享状态、可变数据、副作用 来构建软件的过程。数式编程是声明式 的而不是命令式 的，应用程序的状态是通过纯函数流动的。与面向对象编程形成对比，面向对象中应用程序的状态通常与对象中的方法共享和共处。</span><br><span class="line">函数式编程是一种编程范式 ，这意味着它是一种基于一些基本的定义原则（如上所列）思考软件构建的方式。当然，编程范式的其他示例也包括面向对象编程和过程编程。</span><br><span class="line">函数式的代码往往比命令式或面向对象的代码更简洁，更可预测，更容易测试</span><br></pre></td></tr></table></figure>

# 高阶函数

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先高阶函数肯定是函数，不同的是输入的参数和返回的值这两项中的一项必须是函数才能叫高阶函数。</span><br><span class="line">这个问题在回答的时候可以稍微拓展一下，介绍一下常用的的高阶函数，</span><br><span class="line">比如：map、flatMap、filter、reduce、fold。</span><br></pre></td></tr></table></figure>

# 为什么函数被称为一等公民

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在JavaScript中，函数不仅拥有一切传统函数的使用方式（声明和调用），而且可以做到像简单值一样:</span><br><span class="line"></span><br><span class="line">赋值（var func = function()&#123;&#125;）、</span><br><span class="line">传参(function func(x,callback)&#123;callback();&#125;)、</span><br><span class="line">返回(function()&#123;return function()&#123;&#125;&#125;)，</span><br><span class="line"></span><br><span class="line">这样的函数也称之为第一级函数（First-class Function）。不仅如此，JavaScript中的函数还充当了类的构造函数的作用，同时又是一个Function类的实例(instance)(因斯疼斯)。这样的多重身份让JavaScript的函数变得非常重要。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

# . new 操作符的实现

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、创建一个空对象 &#123;&#125;</span><br><span class="line">2、将构造函数中的this指向新创建的对象 (原型链)</span><br><span class="line">	obj.__proto__ = Dog.prototype // 设置原型链</span><br><span class="line">3、链接该对象到另一个对象 __proto__</span><br><span class="line">4、如果该函数没有返回对象，则返回this</span><br></pre></td></tr></table></figure>

# 回调函数？回调函数有什么缺点

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">回调函数是一个匿名函数，它作为一个参数传递给其他的代码，其作用是在需要的时候方便调用这段（回调函数）代码。可以让异步代码同步执行。</span><br><span class="line">回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）</span><br></pre></td></tr></table></figure>

# instanceof 的原理

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。</span><br><span class="line">实现 instanceof：</span><br><span class="line"></span><br><span class="line">首先获取类型的原型</span><br><span class="line">然后获得对象的原型</span><br><span class="line">然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null</span><br><span class="line"></span><br><span class="line">function myInstanceof(left, right) &#123;</span><br><span class="line">  let prototype = right.prototype</span><br><span class="line">  left = left.__proto__</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (left === null || left === undefined)</span><br><span class="line">      return false</span><br><span class="line">    if (prototype === left)</span><br><span class="line">      return true</span><br><span class="line">    left = left.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

# 设计模式

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。</span><br><span class="line">1、单例模式</span><br><span class="line">2、工厂模式</span><br><span class="line">3、观察者模式</span><br><span class="line">4、代理模式</span><br><span class="line">5、策略模式</span><br><span class="line">6、迭代器模式</span><br><span class="line"></span><br><span class="line">单例模式（Singleton Pattern）</span><br><span class="line">	单例模式中Class的实例个数最多为1。当需要一个对象去贯穿整个系统执行某些任务时，单例模式就派上了用场。而除此之外的场景尽量避免单例模式的使用，因为单例模式会引入全局状态，而一个健康的系统应该避免引入过多的全局状态。</span><br><span class="line"></span><br><span class="line">工厂模式</span><br><span class="line">	工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。</span><br><span class="line">使用场景：如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择</span><br><span class="line">class Product &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    init() &#123;</span><br><span class="line">        console.log(&#x27;init&#x27;)</span><br><span class="line">    &#125;&#125;</span><br><span class="line">class Factory &#123;</span><br><span class="line">    create(name) &#123;</span><br><span class="line">        return new Product(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// use</span><br><span class="line">let factory = new Factory()</span><br><span class="line">let p = factory.create(&#x27;p1&#x27;)</span><br><span class="line">p.init()</span><br><span class="line">https://juejin.im/post/6844904200917221389#heading-81</span><br></pre></td></tr></table></figure>

# js 的基本数据类型、值是如何存储的

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JavaScript一共有8种数据类型    Obeject array.isaray</span><br><span class="line"></span><br><span class="line">7种基本数据类型：</span><br><span class="line">Undefined、Null、Boolean、Number、String、Symbol(es6新增，表示独一无二的值)和BigInt(es10新增)</span><br><span class="line"></span><br><span class="line">1种引用数据类型</span><br><span class="line">Object（Object本质上是由一组无序的名值对组成的）。</span><br><span class="line">里面包含 function、Array、Date等。</span><br><span class="line"></span><br><span class="line">JavaScript不支持任何创建自定义类型的机制，而所有值最终都将是上述 8 种数据类型之一。</span><br><span class="line">原始数据类型：直接存储在栈（stack）中，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。</span><br><span class="line">引用数据类型：同时存储在栈（stack）和堆（heap）中，占据空间大、大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</span><br></pre></td></tr></table></figure>

# &amp;&amp; 、||和!! 运算符

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp; 叫逻辑与，在其操作数中找到第一个虚值表达式并返回它，如果没有找到任何虚值表达式，则返回最后一个真值表达式。它采用短路来防止不必要的工作。</span><br><span class="line">|| 叫逻辑或，在其操作数中找到第一个真值表达式并返回它。这也使用了短路来防止不必要的工作。在支持 ES6 默认函数参数之前，它用于初始化函数中的默认参数值。</span><br><span class="line">!! 运算符可以将右侧的值强制转换为布尔值，这也是将值转换为布尔值的一种简单方法</span><br></pre></td></tr></table></figure>

# js 的数据类型的转换

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在 JS 中类型转换只有三种情况，分别是：</span><br><span class="line"></span><br><span class="line">转换为布尔值（调用Boolean()方法）</span><br><span class="line">转换为数字（调用Number()、parseInt()和parseFloat()方法）</span><br><span class="line">转换为字符串（调用.toString()或者String()方法）</span><br></pre></td></tr></table></figure>

# js 内置对象

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">js 中的内置对象主要指的是</span><br><span class="line">在程序执行前存在全局作用域里的由 js定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。</span><br><span class="line">一般我们经常用到的如全局变量值 NaN、undefined，</span><br><span class="line">全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，</span><br><span class="line">还有提供数学计算的单体内置对象如 Math 对象。</span><br></pre></td></tr></table></figure>

# null 和 undefined 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</span><br><span class="line">undefined 代表的含义是未定义，</span><br><span class="line">null 代表的含义是空对象（其实不是真的对象，请看下面的注意！）。一般变量声明了但还没有定义的时候会返回 undefined，null</span><br><span class="line">主要用于赋值给一些可能会返回对象的变量，作为初始化。</span><br><span class="line">当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等 号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

# &#123;&#125;和[]的 valueOf 和 toString 的结果

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125; 的 valueOf 结果为 &#123;&#125; ，toString 的结果为 &quot;[object Object]&quot;</span><br><span class="line">[] 的 valueOf 结果为 [] ，toString 的结果为 &quot;&quot;</span><br></pre></td></tr></table></figure>

# js 的作用域和作用域链

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">作用域：</span><br><span class="line">	作用域是定义变量的区域，它有一套访问变量的规则，这套规则来管理浏览器引擎如何在当前作用域以及嵌套的作用域中根据变量（标识符）进行变量查找。</span><br><span class="line"></span><br><span class="line">作用域链：</span><br><span class="line">	作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。</span><br><span class="line">	作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</span><br><span class="line">当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向后查找。</span><br></pre></td></tr></table></figure>

# js 创建对象的方式

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象创建方式，我了解到的方式有这么几种：</span><br><span class="line"></span><br><span class="line">（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</span><br><span class="line"></span><br><span class="line">（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此我们可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此我们可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次我们都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</span><br><span class="line"></span><br><span class="line">（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此我们可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</span><br><span class="line"></span><br><span class="line">（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此我们可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</span><br><span class="line"></span><br><span class="line">（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</span><br><span class="line"></span><br><span class="line">（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</span><br></pre></td></tr></table></figure>





# 什么是 DOM 和 BOM

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DOM指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</span><br><span class="line">BOM指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。</span><br><span class="line"></span><br><span class="line">BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，</span><br><span class="line">又是一个 Global（全局）(歌楼波)对象。</span><br><span class="line">这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。</span><br><span class="line">window 对象含有 location 对象、navigator(那V给特)对象、screen(斯歌锐)对象等子对象，</span><br><span class="line">并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。</span><br></pre></td></tr></table></figure>

# 三种事件模型

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">事件 是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型。</span><br><span class="line">DOM0级模型：</span><br><span class="line">	这种模型不会传播，所以没有事件流的概念，同元素 绑定多个事件，只会绑定最后一次的事件，前面的会被覆盖。</span><br><span class="line"></span><br><span class="line">IE 事件模型：</span><br><span class="line">	在该事件模型中，一次事件共有两个过程，事件处理阶段，和事件冒泡阶段。</span><br><span class="line">	事件处理阶段会首先执行目标元素绑定的监听事件。</span><br><span class="line">	然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，</span><br><span class="line">	依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</span><br><span class="line">	这种模型通过 attachEvent 来添加监听函数，可以添加多个监听函数，</span><br><span class="line">	会按顺序依次执行。detachEvent删除事件</span><br><span class="line"></span><br><span class="line">DOM2 级事件模型：</span><br><span class="line">	在该事件模型中，一次事件共有三个过程，</span><br><span class="line">	第一个过程是事件捕获阶段事件处理阶段，和事件冒泡阶段。</span><br><span class="line">	捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，</span><br><span class="line">	如果有则执行。。</span><br><span class="line">	这种事件模型，事件绑定的函数是 addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</span><br><span class="line">	取消事件removeEventListener</span><br></pre></td></tr></table></figure>

# 事件委托(代理)

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">本质上是利用了事件冒泡的机制。</span><br><span class="line">并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，</span><br><span class="line">由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托</span><br><span class="line">支持为同一个DOM元素注册多个同类型事件，可将事件分成事件捕获和事件冒泡机制</span><br></pre></td></tr></table></figure>

# 事件传播

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">事件传播有三个阶段：</span><br><span class="line">捕获阶段–事件从 window 开始，然后向下到每个元素，直到到达目标元素事件或event.target。</span><br><span class="line">目标阶段–事件已达到目标元素。</span><br><span class="line">冒泡阶段–事件从目标元素冒泡，然后上升到每个元素，直到到达 window。</span><br><span class="line"></span><br><span class="line">什么是事件捕获</span><br><span class="line">当事件发生在 DOM 元素上时，该事件并不完全发生在那个元素上。在捕获阶段，事件从window开始，一直到触发事件的元素。</span><br><span class="line">什么是事件冒泡？</span><br><span class="line">事件冒泡刚好与事件捕获相反，当前元素----&gt;body ----&gt; html----&gt;document ----&gt;window。当事件发生在DOM元素上时，该事件并不完全发生在那个元素上。在冒泡阶段，事件冒泡，或者事件发生在它的父代，祖父母，祖父母的父代，直到到达window为止。</span><br></pre></td></tr></table></figure>

# DOM 操作

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">（1）创建新节点</span><br><span class="line"> 	createDocumentFragment()    //创建一个DOM片段 (科瑞A特)(法歌们特)</span><br><span class="line"> 	createElement()             //创建一个具体的元素</span><br><span class="line"> 	createTextNode()   		    //创建一个文本节点</span><br><span class="line"></span><br><span class="line">（2）添加、移除、替换、插入</span><br><span class="line">	appendChild(node)</span><br><span class="line">	removeChild(node)</span><br><span class="line">	replaceChild(new,old) (锐普利斯)</span><br><span class="line">	insertBefore(new,old) (因色特比佛)</span><br><span class="line"></span><br><span class="line">（3）获取、查找</span><br><span class="line">	getElementById();</span><br><span class="line">	getElementsByName();</span><br><span class="line">	getElementsByTagName();</span><br><span class="line">	getElementsByClassName();</span><br><span class="line">	querySelector(); (斯来科特)</span><br><span class="line">	querySelectorAll();</span><br><span class="line"></span><br><span class="line">（4）属性操作</span><br><span class="line">	getAttribute(key); (去比又特)</span><br><span class="line">	setAttribute(key, value);</span><br><span class="line">	hasAttribute(key);</span><br><span class="line">	removeAttribute(key);</span><br></pre></td></tr></table></figure>

# 数据检测类型判断

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">检测方法4种</span><br><span class="line"></span><br><span class="line"> 1、Object.prototype.toString.call()</span><br><span class="line">    作用: 可以检测所有数据类型</span><br><span class="line">    所有数据类型都可以检测,而且非常正确</span><br><span class="line">    语法: Object.prototype.toString.call( &#x27;xxx&#x27;/11/[ ] )</span><br><span class="line">    返回值: [object Xxx], Xxx 就是对象的类型</span><br><span class="line"> 2、constructor</span><br><span class="line">    作用: 可以检测基本数据类型和引用数据类型</span><br><span class="line">    弊端: 把类的原型进行重写, 很有可能把之前的constructor覆盖 检测出来的结果就会不准确</span><br><span class="line">    语法: (&quot;xx&quot;)/([])/(function()&#123;&#125;).constructor === String/Array/Function</span><br><span class="line">    返回值: true/false</span><br><span class="line">3、instanceOf</span><br><span class="line">    原理: 判断对象类型，基于原型链去判断(obj instanceof Object)</span><br><span class="line">    左边对象的原型链proto上是否有右边构造函数的proptotype属性</span><br><span class="line">    作用: 判断左边的对象是否是右边构造函数的实例</span><br><span class="line">    弊端: 用于引用类型的检测, 对于基本数据类型不生效</span><br><span class="line">    语法: &quot; &quot;/[ ]/true instanceOf String/Array/Boolean</span><br><span class="line">    返回值: true/false</span><br><span class="line">4、typeOf</span><br><span class="line">    作用: 用于检测基本数据类型和函数</span><br><span class="line">    弊端: 引用数据类型(Arrary/function/object)只会返回Object, 不起作用</span><br><span class="line">    语法: typeOf &quot; &quot;/[ ]/xx</span><br><span class="line">    返回值: &quot;string&quot;/&quot;boolean&quot;/&quot;object&quot; (无法区分)</span><br></pre></td></tr></table></figure>

# 原型/原型链

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">原型：</span><br><span class="line">Javascript规定，每一个函数都有一个prototype对象属性，指向另一个对象</span><br><span class="line">prototype就是调用构造函数所创建的那个实例对象的原型</span><br><span class="line"></span><br><span class="line">原型链：</span><br><span class="line">实例对象与原型之间的连接，叫做原型链。</span><br><span class="line">JS在创建对象的时候，都有一个叫做__proto__的内置属性，用于指向创建它的函数对象的原型对象prototype。</span><br><span class="line"></span><br><span class="line">获取原型的方法</span><br><span class="line">p.proto</span><br><span class="line">p.constructor.prototype</span><br><span class="line">Object.getPrototypeOf(p)</span><br></pre></td></tr></table></figure>

# prototype、proto、constructor 三者的关系

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、prototype:</span><br><span class="line">每一个函数都有一个prototype这个属性，而这个属性指向一个对象，这个对象我们叫做原型对象</span><br><span class="line">作用：节约内存扩展属性和方法可以实现类之间的继承</span><br><span class="line">2、__proto__:</span><br><span class="line">每一个对象都有一个__proto__属性,__proto__指向创建自己的那个构造函数的原型对象对象可以直接访问__proto__里面的属性和方法</span><br><span class="line">3、constructor：</span><br><span class="line">指向创建自己的那个构造函数 ，是原型上的方法</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">当我们创建一个构造函数的时候这个构造函数自带了一个prototype属性，而这个属性指向一个对象，也就是原型对象。 这个原型对象里面有一个constructor构造器，它的作用是指向创建自己的构造函数。</span><br><span class="line">除此之外 prototype还可以存放公共的属性和方法。</span><br><span class="line">当我们实例化一个对象的时候(被new调用的时候)，这个对象自带了一个 proto 属性，</span><br><span class="line">这个proto 指向创建自己的构造函数的原型对象。可以使用这个原型对象里面的属性和方法</span><br></pre></td></tr></table></figure>

# constructor 与 class 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">传统的javascript中只有对象，没有类的概念。它是基于原型的面向对象语言。</span><br><span class="line">原型对象特点就是将自身的属性共享给新对象。</span><br><span class="line"></span><br><span class="line">ES6引入了Class（类）这个概念，通过class关键字可以定义类。</span><br><span class="line">该关键字的出现使得其在对象写法上更加清晰，更像是一种面向对象的语言c</span><br><span class="line"></span><br><span class="line">constructor：</span><br><span class="line">constructor()方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。</span><br><span class="line">一个类必须有constructor()方法，如果没有显式定义，一个空的 constructor()方法会被默认添加。</span><br></pre></td></tr></table></figure>

# 构造函数与普通函数的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 返回值类型的区别：</span><br><span class="line">	构造函数是没有返回值类型的，</span><br><span class="line">	普通函数是有返回值类型的，即使函数没有返回值，返回值类型也要写上void。</span><br><span class="line">2. 函数名的区别：</span><br><span class="line">	构造函数的函数名必须要与类名一致，</span><br><span class="line">	普通函数的函数名只要符合标识符的命名规则即可。</span><br><span class="line">3. 调用方式的区别：</span><br><span class="line">	构造函数是在创建对象的时候由jvm调用的。</span><br><span class="line">	普通函数是由我们使用对象调用的，一个对象可以对象多次普通的函数，</span><br><span class="line">4. 作用上的区别：</span><br><span class="line">	构造函数的作用用于初始化一个对象。</span><br><span class="line">	普通函数是用于描述一类事物的公共行为的。</span><br></pre></td></tr></table></figure>

# 跨域出现的原因/解决方法

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">原因：由于浏览器的同源策略，即属于不同域的⻚面之间不能相互访问各自的⻚面内容。</span><br><span class="line"></span><br><span class="line">哪些情况下产生跨域</span><br><span class="line">1、域名不同</span><br><span class="line">2、端口号不同</span><br><span class="line">3、协议不同(http/https)</span><br><span class="line">4、域名和域名对应ip</span><br><span class="line">5、主域名相同(127.0.01 和 localhost) 多域名匹配一个ip地址</span><br><span class="line">6、子域名不同（一级和二级域名）</span><br><span class="line"></span><br><span class="line">解决方法</span><br><span class="line"></span><br><span class="line">1、后端代理</span><br><span class="line">后端不存在跨域（后端代码脱离浏览器，后端是服务器端）</span><br><span class="line">利用后端(自己公司的后端)去获取接口数据，将数据传给前端</span><br><span class="line">2、jsonp</span><br><span class="line">原理:</span><br><span class="line">	利用浏览器的&quot;漏洞&quot; src不受同源策略的影响，可以请求任何链接 。动态创建script标签，将事先写好的函数名传给服务器，供服务器使用</span><br><span class="line">（1）script标签src属性不存在跨域</span><br><span class="line">（2）get方式--传递函数名 --弊端</span><br><span class="line">（3）callback回调函数(传递函数名)</span><br><span class="line">3、反向代理</span><br><span class="line">proxy  webpack配置</span><br><span class="line">&quot;proxy&quot;: &#123;</span><br><span class="line">    &quot;/index.php&quot;: &#123;</span><br><span class="line">      &quot;target&quot;: &quot;http://qinqin.net&quot;,</span><br><span class="line">      &quot;changeOrigin&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">4、CORS解决跨域(xhr2)(后端)</span><br><span class="line">CORS是一个W3C标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）。它允许浏览器向跨源(协议 + 域名 + 端口)服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</span><br><span class="line">需要服务器(提供接口的源码里面)添加下面两句话。</span><br><span class="line">header(&#x27;Access-Control-Allow-Origin:*&#x27;);</span><br><span class="line">header(&#x27;Access-Control-Allow-Method:POST,GET&#x27;);</span><br><span class="line"></span><br><span class="line">jsonp是一种非正式传输协议，用于解决跨域问题流程：</span><br><span class="line">1、创建一个全局函数</span><br><span class="line">2、创建一个script标签</span><br><span class="line">3、给script添加src</span><br><span class="line">4、给src添加回调函数test(callback=test) callback是传给后端的一个参数</span><br><span class="line">5、将script放到⻚面上</span><br><span class="line">6、script请求完成，将自己从⻚面上删除</span><br></pre></td></tr></table></figure>

# 同源策略

同源策略：阻止从一个域名上加载的脚本获取或操作另一个域名上的文档属性。 阻止一个域名 操作另一个域名的
也就是说，受到请求的 URL 的域名必须与当前 Web 页面的域名相同。
同源策略是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。

3.什么情况下会产生跨域。
域名不同
端口不同
协议不同(http/https)
域名和域名对应的 ip 地址 (localhost 和 127.0.0.1 产生跨域) √
一级域名和二级域名，子域名和主域名产生跨域
同一域名，不同文件夹.
域名和域名对应 Ip

# 闭包原理/优点/缺点/使用场景

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">闭包原理：定义在一个函数内部的函数(函数嵌套函数)，闭包就是将函数内部和函数外部连接起来的一座桥梁。</span><br><span class="line">打破了作用域链的规则 闭包就是能够读取其他函数内部变量的函数</span><br><span class="line"></span><br><span class="line">用途:</span><br><span class="line">第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</span><br><span class="line">另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</span><br><span class="line"></span><br><span class="line">优点:</span><br><span class="line">1、使用闭包是不会污染全局环境，</span><br><span class="line">2、方便进行模块化开发，</span><br><span class="line">3、减少形参个数，延长了形参的生命周期，</span><br><span class="line"></span><br><span class="line">坏处:</span><br><span class="line">1、就是不恰当使用会造成内存泄漏</span><br><span class="line"></span><br><span class="line">闭包的不适用于返回闭包的函数是个特别大的函数,很多高级应用都要依靠闭包实现.</span><br><span class="line"></span><br><span class="line">使用场景</span><br><span class="line">1、通过循环给页面上多个dom节点绑定事件</span><br><span class="line">2、封装私有变量(计数器)</span><br><span class="line">3、延续局部变量的寿命</span><br><span class="line">4、高阶组件</span><br><span class="line">5、函数防抖</span><br><span class="line"></span><br><span class="line">模块化的就是以闭包为基础构建的;</span><br></pre></td></tr></table></figure>

# 内存泄漏

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、意外的全局变量</span><br><span class="line">2、被遗忘的定时器</span><br><span class="line">3、没有清除的dom应用 ，故要及时清除，</span><br><span class="line">4、滥用闭包</span><br><span class="line"></span><br><span class="line">清除内存泄漏方法有两种，一是标记清除，二便是引用计数清除。</span><br></pre></td></tr></table></figure>

# promise/async&amp;await

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">PR</span><br><span class="line"></span><br><span class="line">    一：resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</span><br><span class="line">    二：reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</span><br><span class="line">    三：Promise.prototype.finally</span><br><span class="line">    finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</span><br><span class="line"></span><br><span class="line">promise的静态方法</span><br><span class="line">    Promise.all():用于将多个 Promise 实例，包装成一个新的 Promise 实例，接受一个数组作为参数，只有数组里面的每个状态都变成resolve，则新的 Promise 实例状态才会变成resolve.</span><br><span class="line">    Promise.race():将Promise对象数组中最先执行完成的内容通过后面then传出</span><br><span class="line"></span><br><span class="line">promise的基本使用：</span><br><span class="line">通过new promise创建一个promise对象，里面有一个参数，参数是一个回调函数，</span><br><span class="line">回调函数中有2个参数：resolve、reject</span><br><span class="line">	resolve()当异步执行成功的时候调用的方法，reject()当异步失败的时候调用的方法。</span><br><span class="line">除此之外promise有一个then方法，当成功的时候执行第一个回调函数，当失败的时候执行第二个回调函数。</span><br><span class="line">第二个回调函数也可以通过promise对象.catch调用</span><br><span class="line"></span><br><span class="line">Promise.all():当所有的异步代码都执行完毕以后才会执行.then中的操作</span><br><span class="line">Promise.race():只要有一个promise执行完毕后就会执行.then操作</span><br><span class="line"></span><br><span class="line">promise的三种状态：</span><br><span class="line">1.pending - 进行中</span><br><span class="line">2.fulfilled - 成功</span><br><span class="line">3.rejected - 失败</span><br><span class="line"></span><br><span class="line">链式调用:</span><br><span class="line">promise俗称链式调用，它是es6中最重要的特性之一</span><br><span class="line">简单的说可以不停的then调用嵌套在调用（异步之后，链式调用方式执行回调），这种操作方式称为promise</span><br><span class="line"></span><br><span class="line">async异步能干什么？</span><br><span class="line">就是用来修饰函数，使该函数异步执行，不阻碍后续函数的执行</span><br><span class="line">同时我们注意到，async修饰的函数也带有then catch方法，</span><br><span class="line">因此，经async修饰的函数也 是一个promise await只能放在async中，且只能修饰promise对象</span><br><span class="line">	1. promise的诞生是为了简化函数嵌套调用流程，也便于后续维护</span><br><span class="line">	2. async/await定义了异步函数，并在其内部可通过await等待promise对象，阻塞后 续的执行</span><br><span class="line"></span><br><span class="line">await关键字必须在async函数里面</span><br><span class="line">await会阻塞当前直到完成 async返回reject的方法,当抛出异常等同于reject</span><br><span class="line"></span><br><span class="line">async / await与 Promise的主要区别是：</span><br><span class="line">Promise代码完全都是Promise的API（then、catch等等），操作本身的语义反而不容易看出来,</span><br><span class="line">async / await函数的实现最简洁，最符合语义，几乎没有语义不相关的代码</span><br><span class="line">async / await 函数就是 Generator 函数的语法糖</span><br><span class="line"></span><br><span class="line">async/await函数的优势</span><br><span class="line">1. 使用async函数可以让代码简洁很多，不需要像Promise一样需要些then，不需要写匿名函数处理Promise的resolve值，也不需要定义多余的data变量，还避免了嵌套代码</span><br><span class="line">2. 使用aync/await的话，catch能处理JSON.parse错误 promise中不能处理</span><br><span class="line">3. 条件语句也和错误捕获是一样的，在 Async 中也可以像平时一般使用条件语句</span><br><span class="line"></span><br><span class="line">promise的状态处理的原理:</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

# promise.all 和 promise.race

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pomise.all的使用</span><br><span class="line">	Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。</span><br><span class="line">	Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，在前端开发请求数据的过程中，偶尔会遇到发送多个请求并根据请求顺序获取和使用数据的场景，使用Promise.all毫无疑问可以解决这个问题。</span><br><span class="line"></span><br><span class="line">Promise.race的使用</span><br><span class="line">	Promise.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。</span><br></pre></td></tr></table></figure>

# Generator

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Generator 的中文名称是生成器，它是ECMAScript6中提供的新特性。</span><br><span class="line">在过去，封装一段运算逻辑的单元是函数。函数只存在“没有被调用”或者“被调用”的情况，</span><br><span class="line">不存在一个函数被执行之后还能暂停的情况，而Generator的出现让这种情况成为可能。</span><br><span class="line"></span><br><span class="line">通过 function* 来定义的函数称之为“生成器函数”（generator function），它的特点是可以中断函数的执行，</span><br><span class="line">每次执行yield语句之后，函数即暂停执行，直到调用返回的生成器对象的next()函数它才会继续执行。</span><br><span class="line"></span><br><span class="line">也就是说 Generator 函数是一个状态机，封装了多个内部状态。</span><br><span class="line">执行 Generator 函数返回一个遍历器对象（一个指向内部状态的指针对象），</span><br><span class="line">调用遍历器对象的next方法，使得指针移向下一个状态。每次调用next方法，</span><br><span class="line">内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。</span><br><span class="line"></span><br><span class="line">yield关键字</span><br><span class="line">真正让Generator具有价值的是yield关键字，这个yield关键字让 Generator内部的逻辑能够切割成多个部分。</span><br><span class="line">发现函数执行到第一个yield关键字的时候就停止了。要让业务逻辑继续执行完，需要反复调用.next()</span><br><span class="line">可以简单地理解为yield关键字将程序逻辑划分成几部分，每次.next()执行时执行一部分。</span><br><span class="line">这使得程序的执行单元再也不是函数，复杂的逻辑可以通过yield来暂停。</span><br><span class="line"></span><br><span class="line">.next()调用时，返回一个对象，这个对象具备两个属性。</span><br><span class="line">其中一个属性是布尔型的done。它表示这个Generator对象的逻辑块是否执行完成。</span><br><span class="line">另一个属性是value，它来自于yield语句后的表达式的结果。</span><br><span class="line"></span><br><span class="line">通过.next()传递参数，可以赋值给yield关键字前面的变量声明。</span><br></pre></td></tr></table></figure>

# 堆/栈

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1、堆——引用类型地址传递</span><br><span class="line">	堆：动态分配的内存，大小不定，不会自动释放。存放引用类型的值 先进后出FILO</span><br><span class="line">	引用类型: Object(Arrary, Date, Math,Function, Object)</span><br><span class="line">	访问方法: JS不能直接访问内存中的值, 只能操作对象的地址, 所以产生深/浅拷贝问题</span><br><span class="line">	栈--基本类型值传递</span><br><span class="line">2、栈——自动分配内存空间，系统自动释放，存放基本类型的值和引用类型的地址先进先出FIFO</span><br><span class="line">    基本类型: Undefined、Null、Boolean、Number 和 String, Symbol(ES6新增)</span><br><span class="line">    访问方法: 按值访问, 直接操作内存中的值</span><br></pre></td></tr></table></figure>

# 深/浅拷贝及方法

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">深/浅拷贝针对的是引用类型</span><br><span class="line"></span><br><span class="line">浅拷贝</span><br><span class="line">浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。</span><br><span class="line">新旧互相影响,改变的是地址</span><br><span class="line">新值===原值,只能拷贝一层</span><br><span class="line"></span><br><span class="line">数组方法: slice截取, concat拼接, filter过滤, map</span><br><span class="line">对象方法: Object.assign(&#123;&#125;,obj), Object.create(obj)</span><br><span class="line"></span><br><span class="line">展开运算符: &#123;...obj&#125;,[...arr]</span><br><span class="line"></span><br><span class="line">深拷贝</span><br><span class="line">深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象</span><br><span class="line">新旧互不影响,改变的是值</span><br><span class="line">新值=/=原值,可以拷贝多层</span><br><span class="line"></span><br><span class="line">1、JSON序列化</span><br><span class="line">    JSON.parse(JSON.stringify(obj))对象--&gt;字符串--&gt;对象</span><br><span class="line">    这个方式的弊端：</span><br><span class="line">    1、如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式，而不是对		象的形式</span><br><span class="line">    2、如果obj里有RegExp(正则表达式的缩写)、Error对象，则序列化的结果将只得到空对象；</span><br><span class="line">    3、如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失；</span><br><span class="line">    4、如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null</span><br><span class="line">    5、JSON.stringify()只能序列化对象的可枚举的自有属性，不可枚举的不能被复制</span><br><span class="line"></span><br><span class="line">    可枚举:可枚举性（enumerable）用来控制所描述的属性，是否将被包括在for...in循环之中。具体来说，如果一个属性的enumerable为false，下面三个操作不会取到该属性。</span><br><span class="line">    for..in循环、Object.keys方法、JSON.stringify方法</span><br><span class="line">2、原生实现</span><br><span class="line">	递归+浅拷贝</span><br><span class="line"></span><br><span class="line">3、工具实现【第三方封装库】</span><br><span class="line">loadsh _.cloneDeep(obj)</span><br><span class="line">	.DeepClone()</span><br><span class="line">	用于 Model / Entity / ... ... 等引用类型对象的深度克隆</span><br><span class="line">		特性说明</span><br><span class="line">		1.不需要对对象做任何特殊处理，直接 .DeepClone() 即可得到该对象的深度克隆</span><br><span class="line">		2.不受对象层次深度限制，均可实现深度克隆（下面会给出几个简单示例 ... ...）</span><br><span class="line">Immutable</span><br><span class="line">Object.create()</span><br></pre></td></tr></table></figure>

# set 和 map

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Set:它类似于数组，但是成员的值都是唯一的，没有重复的值。</span><br><span class="line">Set本身是一个构造函数，用来生成 Set 数据结构，数组作为参数。</span><br><span class="line"></span><br><span class="line">不说set  数据结构Set   new set()存储数据   set.size得到存储的数据长度</span><br><span class="line"></span><br><span class="line">has()判断某个值是否存在set中   foreach遍历set</span><br><span class="line"></span><br><span class="line">不说map : new  map      map.set   map.get   map.delete</span><br><span class="line"></span><br><span class="line">都是用来存储数据用的，但是存储的数据格式不同</span><br><span class="line">set 直接存储 任意类型数据</span><br><span class="line">map 存储数据的时候，必须以key，value的形式，</span><br><span class="line">set 使用forEach 遍历的时候，key和value值是一样的</span><br><span class="line">而map 遍历的时候，key就是存进去的对象的key，value就是存在的值</span><br><span class="line"></span><br><span class="line">for循环这种写法比较麻烦，因此数组提供内置的forEach方法。</span><br><span class="line"></span><br><span class="line">forEach没有返回值，无法中途跳出forEach循环，break命令或return命令都不能奏效。</span><br><span class="line"></span><br><span class="line">for...in循环主要是为遍历对象而设计的，不适用于遍历数组**</span><br><span class="line"></span><br><span class="line">for...of循环相比上面几种做法，有一些显著的优点。</span><br><span class="line">有着同for...in一样的简洁语法，但是没有for...in那些缺点。</span><br><span class="line">不同于forEach方法，它可以与break、continue和return配合使用。</span><br><span class="line">提供了遍历所有数据结构的统一操作接口。</span><br></pre></td></tr></table></figure>

# **宏任务和微任务**

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">js 是单线程执行的，js中的任务按顺序一个一个的执行，但是一个任务耗时太长，那么后面的任务就需要等待，为了解决这种情况，将任务分为了同步任务和异步任务，而异步任务又可以分为微任务和宏任务</span><br><span class="line"></span><br><span class="line">概念</span><br><span class="line">1.宏任务：当前调用栈中执行的代码成为宏任务。（主代码快，定时器等等）浏览器api。</span><br><span class="line">2.微任务：当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务,可以理解为回调事件。 ES6语法规定的（promise.then，proness.nextTick等等）。</span><br><span class="line">3.宏任务中的事件放在callback queue中，由事件触发线程维护；微任务的事件放在微任务队列中，由js引擎线程维护。</span><br><span class="line">4.清空队列的时候，然后再dom 渲染</span><br><span class="line"></span><br><span class="line">运行机制</span><br><span class="line">1. 在执行栈中执行一个宏任务。</span><br><span class="line">2. 执行过程中遇到微任务，将微任务添加到微任务队列中。</span><br><span class="line">3. 当前宏任务执行完毕，立即执行微任务队列中的任务。</span><br><span class="line">4. 当前微任务队列中的任务执行完毕，检查渲染，GUI线程接管渲染。</span><br><span class="line">5. 渲染完毕后，js线程接管，开启下一次事件循环，执行下一次宏任务（事件队列中取）。</span><br><span class="line"></span><br><span class="line">微任务：process.nextTick、MutationObserver、Promise.then catch finally  DOM渲染前触发</span><br><span class="line">宏任务：I/O、setTimeout、setInterval、setImmediate、requestAnimationFrame DOM渲染后除非</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">js执行顺序，（先执行宏任务列，微任务队列）</span><br><span class="line">先同步再异步，在此基础上先宏任务再微任务</span><br><span class="line"></span><br><span class="line">流程：</span><br><span class="line">	同步和异步任务分别进入不同的执行“场所”，同步进入主线程，异步进入Event Table并注册函数。当指定的事情完成时，Event Table会将这个函数移入Event Queue。主线程内的任务执行完毕为空，回去了Event Queue读取对应的函数，进入主线程。</span><br><span class="line">	上述过程会不断重复，也就是常说的Event Loop（事件循环）。</span><br><span class="line">	但是，JS异步还有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入event queue，然后再执行微任务，将微任务放入eventqueue，但是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回调函数，然后再从宏任务的queue拿宏任务的回调函数，</span><br></pre></td></tr></table></figure>

# js 异步操作

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、定时器都是异步操作</span><br><span class="line">2、事件绑定都是异步操作</span><br><span class="line">3、AJAX中一般我们都采取异步操作（也可以同步）</span><br><span class="line">4、回调函数可以理解为异步（不是严谨的异步操作）</span><br><span class="line">5、promise</span><br><span class="line">6、generator（ES6）</span><br><span class="line">   通过yield关键字可以让任务在需要的地方暂停,每一步的值可以通过next获取</span><br><span class="line">7、async/await(ES7)</span><br><span class="line">   await得到的就是async异步返回值,底层原理还是promise中的resolve方法</span><br><span class="line">8、设计模式-发布订阅模式</span><br><span class="line">9、事件监听</span><br></pre></td></tr></table></figure>

# 表单只能输入数字

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正则   type number</span><br></pre></td></tr></table></figure>

# Proxy 和 Reflect

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Proxy用于修改某些操作的默认行为，即对编程语言层面进行修改，属于“元编程”，Proxy意思为“代理”，即在访问对象之前建立一道“拦截”，任何访问该对象的操作之前都会通过这道“拦截”，即执行Proxy里面定义的方法</span><br><span class="line"></span><br><span class="line">let pro = new Proxy(target,handler)</span><br><span class="line"></span><br><span class="line">其中 new Proxy相当于创建了一个Proxy实例，target为所要拦截的目标对象，handler也是一个对象，里面定义的是对拦截对象所要进行的拦截方法</span><br><span class="line"></span><br><span class="line">Proxy也可以作为其他对象的原型对象使用</span><br><span class="line"></span><br><span class="line">上述实例将pro作为obj的原型对象使用，虽然obj本身没有name这个属性，但是根据原型链，会在pro上读取到name属性，之后会执行相对应的拦截操作。</span><br><span class="line"></span><br><span class="line">let pro = new Proxy(target,handler);</span><br><span class="line">let obj = Object.create(pro);</span><br></pre></td></tr></table></figure>

# Proxy 常用的拦截方法

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">get(target,name,property)方法</span><br><span class="line">用于拦截某个读取属性的操作,第一个参数为目标对象，第二个参数为属性名称，第三个属性为操作所针对的对象（可选参数）</span><br><span class="line"></span><br><span class="line">set(target,name,value,property)</span><br><span class="line">用于拦截某个属性的赋值操作，第一个参数为目标对象，第二个参数为属性名，第三个参数为属性值，第四个参数为操作行为所针对的对象（可选参数）</span><br><span class="line"></span><br><span class="line">has(target,key)</span><br><span class="line">用来拦截对象是否具有某个属性值的操作，第一个参数为目标对象，第二个参数为属性名</span><br><span class="line"></span><br><span class="line">Reflect(锐付莱克特)对象:</span><br><span class="line">Reflect设计的目的是为了优化Object的一些操作方法以及合理的返回Object操作返回的结果，对于一些命令式的Object行为，Reflect对象可以将其变为函数式的行为</span><br><span class="line"></span><br><span class="line">Reflect(target,name,property)  Reflect.has(obj,&quot;name&quot;)  Reflect.get(target,name,property)</span><br></pre></td></tr></table></figure>

# 浏览器优化

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">减少请求数量</span><br><span class="line"></span><br><span class="line">图片处理</span><br><span class="line">	雪碧图</span><br><span class="line">	gulp</span><br><span class="line">	Base64</span><br><span class="line">	使用字体图标来代替图片 - 自定义字体 @font-face&#123;&#125;</span><br><span class="line">	在安卓下可以使用webp格式的图片</span><br><span class="line"></span><br><span class="line">减小资源大小 - grunt  gulp webpack</span><br><span class="line">	HTML压缩</span><br><span class="line">	CSS压缩</span><br><span class="line">	JS压缩与混乱</span><br><span class="line">	图片压缩</span><br><span class="line"></span><br><span class="line">优化网络连接</span><br><span class="line">	cdnCDN即内容分发网络，它能够实时地根据网络流量和各节点的连接、负载状</span><br><span class="line">	用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度</span><br><span class="line"></span><br><span class="line">优化资源加载</span><br><span class="line">	资源加载位置</span><br><span class="line">		1、CSS文件放在head中，先外链，后本页</span><br><span class="line">		2、JS文件放在body底部，先外链，后本页</span><br><span class="line">		3、body中间尽量不写style标签和script标签</span><br><span class="line">	资源加载时机</span><br><span class="line">		1、异步script标签</span><br><span class="line">		2、模块按需加载需要根据路由来加载当前页面需要的业务模块</span><br><span class="line">		3、资源懒加载与资源预加载</span><br><span class="line"></span><br><span class="line">减少重绘回流</span><br><span class="line">	当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流</span><br><span class="line">	当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如		background-color。则就叫称为重绘。</span><br><span class="line">	回流必将引起重绘，而重绘不一定会引起回流。</span><br><span class="line">减少回流和重绘</span><br><span class="line">	css3硬件加速（GPU加速）</span><br><span class="line"></span><br><span class="line">六.【DOM优化】</span><br><span class="line">1、缓存DOM</span><br><span class="line">2、减少DOM深度及DOM数量</span><br><span class="line">3、批量操作DOM</span><br><span class="line">4、批量操作CSS样式</span><br><span class="line">5、在内存中操作DOM</span><br><span class="line">6、DOM元素离线更新</span><br><span class="line">7、DOM读写分离</span><br><span class="line">8、事件代理</span><br><span class="line">9、防抖和节流</span><br><span class="line">10、及时清理环境</span><br></pre></td></tr></table></figure>

# 请求头

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Accept(艾可塞克特)</span><br><span class="line">告诉WEB服务器自己接受什么介质类型，*/* 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。</span><br><span class="line">　　</span><br><span class="line">Accept-Charset(恰斯特)</span><br><span class="line">浏览器告诉服务器自己能接收的字符集。</span><br><span class="line"></span><br><span class="line">Accept-Encoding(因扣定)</span><br><span class="line">浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate）</span><br><span class="line"></span><br><span class="line">Accept-Language</span><br><span class="line">浏览器申明自己接收的语言。语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。</span><br><span class="line">　　</span><br><span class="line">Authorization(哦瑟惹C逊)</span><br><span class="line">当客户端接收到来自WEB服务器的 WWW-Authenticate 响应时，用该头部来回应自己的身份验证信息给WEB服务器。</span><br><span class="line">　　</span><br><span class="line">If-Match</span><br><span class="line">如果对象的 ETag 没有改变，其实也就意味著对象没有改变，才执行请求的动作，获取文档。</span><br><span class="line"></span><br><span class="line">If-None-Match</span><br><span class="line">如果对象的 ETag 改变了，其实也就意味著对象也改变了，才执行请求的动作，获取文档。</span><br><span class="line">   (莫得反得)</span><br><span class="line">If-Modified-Since(森恩斯)</span><br><span class="line">如果</span><br><span class="line">nishi nishi hsihi hshishhjshkkhjhkash is niasdadkjas 请求的对象在该头部指定的时间之后修改了，才执行请求的动作（比如返回对象），否则返回代码304，告诉浏览器该对象没有修改。例如：If-Modified-Since：Thu, 10 Apr 2008 09:14:42 GMT</span><br><span class="line"></span><br><span class="line">If-Unmodified-Since</span><br><span class="line">如果请求的对象在该头部指定的时间之后没修改过，才执行请求的动作（比如返回对象）。</span><br><span class="line"></span><br><span class="line">If-Range /reinge/</span><br><span class="line">浏览器告诉 WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分给我，如果对象改变了，就把整个对象给我。浏览器通过发送请求对象的ETag 或者自己所知道的最后修改时间给 WEB 服务器，让其判断对象是否改变了。总是跟 Range 头部一起使用。</span><br><span class="line"></span><br><span class="line">Range</span><br><span class="line">浏览器（比如 Flashget 多线程下载时）告诉 WEB 服务器自己想取对象的哪部分。例如：Range: bytes=1173546</span><br><span class="line"></span><br><span class="line">Proxy-Authenticate(噢三特K特)</span><br><span class="line">代理服务器响应浏览器，要求其提供代理身份验证信息。</span><br><span class="line"></span><br><span class="line">Proxy-Authorization</span><br><span class="line">浏览器响应代理服务器的身份验证请求，提供自己的身份信息。</span><br><span class="line"></span><br><span class="line">Host</span><br><span class="line">客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。如Host：rss.sina.com.cn</span><br><span class="line"></span><br><span class="line">Referer(锐佛尔)</span><br><span class="line">浏览器向WEB 服务器表明自己是从哪个网页URL获得点击当前请求中的网址/URL，</span><br><span class="line">例如：Referer：http://www.ecdoer.com/</span><br><span class="line"></span><br><span class="line">User-Agent(A就特)</span><br><span class="line">浏览器表明自己的身份（是哪种浏览器）。</span><br><span class="line">例如：User-Agent：Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN;rv:1.8.1.14) Gecko/20080404 Firefox/2.0.0.14</span><br></pre></td></tr></table></figure>

# static 有什么特性

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">new出来一个实例对象是否带有static属性   static用ES5怎么写</span><br><span class="line"></span><br><span class="line">没有创建对象，也能使用属性和调用方法</span><br><span class="line"></span><br><span class="line">用来形成静态代码块以优化程序性能。因为只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</span><br><span class="line"></span><br><span class="line">static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次</span><br><span class="line"></span><br><span class="line">被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。</span><br><span class="line"></span><br><span class="line">类第一次加载初始化的时候就去加载static部分,后面可以重新赋值</span><br><span class="line"></span><br><span class="line">static用ES5怎么写: 静态是通过类名直接调用 class A staticB</span><br><span class="line"></span><br><span class="line">直接用A.B    将B绑定在A上</span><br></pre></td></tr></table></figure>

# async await

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">同步还是异步</span><br><span class="line">	await同步</span><br><span class="line">	async异步</span><br><span class="line"></span><br><span class="line">async和await有两个关键字,一个写在函数外面,一个写在函数里面,函数外面是异步的，函数里面是同步的，调用函数的那一行其实是异步的,下一行</span><br><span class="line">函数里面转成阻塞的</span><br><span class="line"></span><br><span class="line">async  await =&gt; promise 改写</span><br><span class="line"></span><br><span class="line">async函数中</span><br><span class="line">let  a=await promise  的a函数</span><br><span class="line">let  b=await promise  的b函数</span><br><span class="line"></span><br><span class="line">promise.all改写</span><br><span class="line">Promise.allSettled   Promise.any</span><br><span class="line"></span><br><span class="line">promise实现promise.all的方法</span><br><span class="line"></span><br><span class="line">async使用的时候报错,如何捕获try...catch</span><br><span class="line"></span><br><span class="line">var test3 = async function () &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      await p1();</span><br><span class="line">      await p2();</span><br><span class="line">      p3();</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      console.log(&#x27;p1失败了&#x27;, e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">await后面有个接口</span><br><span class="line">接口要2S才能完成    接口2S才会执行</span><br></pre></td></tr></table></figure>

# $.ajax 中 async:false 的阻塞和 await 这种阻塞有什么区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">没区别</span><br></pre></td></tr></table></figure>

# 怎么携带 cookie 发送给后端

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置请求头   请求头中携带cookie</span><br></pre></td></tr></table></figure>

# 对象浅拷贝在 react 中用到哪些地方,为什么

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">为什么在react中要使用浅拷贝</span><br><span class="line"></span><br><span class="line">redux中要求:状态是只读的,唯一且不可修改的,reducer必须是一个纯函数</span><br><span class="line"></span><br><span class="line">因为redux中数据不可更改,所以redux中的数据应该要拷贝  返回一个新值</span><br></pre></td></tr></table></figure>

# ajax、axios、fetch 之间的详细区别以及优缺点

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">1.jQuery ajax</span><br><span class="line">	$.ajax(&#123;</span><br><span class="line">		type: &#x27;POST&#x27;,</span><br><span class="line">		url: url,</span><br><span class="line">		data: data,</span><br><span class="line">		dataType: dataType,</span><br><span class="line">		success: function () &#123;&#125;,</span><br><span class="line">		error: function () &#123;&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">优缺点：</span><br><span class="line">	是对原生XHR的封装，除此以外还增添了对JSONP的支持。</span><br><span class="line">	本身是针对MVC的编程,不符合现在前端MVVM的浪潮</span><br><span class="line">	基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案</span><br><span class="line">	JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理</span><br><span class="line">	（采取个性化打包的方案又不能享受CDN服务）</span><br><span class="line"></span><br><span class="line">2.axios</span><br><span class="line">	axios(&#123;</span><br><span class="line">		method: &#x27;post&#x27;,</span><br><span class="line">		url: &#x27;/user/12345&#x27;,</span><br><span class="line">		data: &#123;</span><br><span class="line">			firstName: &#x27;Fred&#x27;,</span><br><span class="line">			lastName: &#x27;Flintstone&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	.then(function (response) &#123;</span><br><span class="line">		console.log(response);</span><br><span class="line">	&#125;)</span><br><span class="line">	.catch(function (error) &#123;</span><br><span class="line">		console.log(error);</span><br><span class="line">	&#125;);</span><br><span class="line">优缺点：</span><br><span class="line">	Axios本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，</span><br><span class="line">	从它的官网上可以看到它有以下几条特性：</span><br><span class="line">		从 node.js 创建 http 请求</span><br><span class="line">		支持 Promise API</span><br><span class="line">		客户端支持防止CSRF</span><br><span class="line">		提供了一些并发请求的接口（重要，方便了很多的操作）</span><br><span class="line"></span><br><span class="line">3.fetch</span><br><span class="line">	try &#123;</span><br><span class="line">		let response = await fetch(url);</span><br><span class="line">		let data = response.json();</span><br><span class="line">		console.log(data);</span><br><span class="line">	&#125; catch(e) &#123;</span><br><span class="line">		console.log(&quot;Oops, error&quot;, e);</span><br><span class="line">	&#125;</span><br><span class="line">优缺点：</span><br><span class="line">	符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里</span><br><span class="line">	更好更方便的写法</span><br><span class="line">	更加底层，提供的API丰富（request, response）</span><br><span class="line">	脱离了XHR，是ES规范里新的实现方式</span><br><span class="line"></span><br><span class="line">fetch是一个低层次的API，你可以把它考虑成原生的XHR，所以使用起来并不是那么舒服，</span><br><span class="line">需要进行封装，例如：</span><br><span class="line">1）fetch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理</span><br><span class="line">2）fetch默认不会带cookie，需要添加配置项</span><br><span class="line">3）fetch不支持abort，不支持超时控制，</span><br><span class="line">   使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费</span><br><span class="line">4）fetch没有办法原生监测请求的进度，而XHR可以</span><br><span class="line"></span><br><span class="line">为什么要用axios?</span><br><span class="line">axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征：</span><br><span class="line">	从浏览器中创建 XMLHttpRequest</span><br><span class="line">	从 node.js 发出 http 请求</span><br><span class="line">	支持 Promise API</span><br><span class="line">	拦截请求和响应</span><br><span class="line">	转换请求和响应数据</span><br><span class="line">	取消请求</span><br><span class="line">	自动转换JSON数据</span><br><span class="line">	客户端支持防止CSRF/XSRF</span><br></pre></td></tr></table></figure>

# 事件循环 Event Loop

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Event Loop 即事件循环</span><br><span class="line">是指浏览器或者Node的一种解决JavaScript单线程运行时不阻塞的一种机制，单线程的是所有任务都在主线程上完成,任务太多的时候,页面卡死,eventLoop可以解决单线程阻塞问题,程序中会有两个线程,一个主线程,一个eventLoop线程,负责主线程和其他进程之间的通信,遇到I/O的时候,主线程会让eventLoop线程通知对应的程序,主线程的任务会继续往后执行,等I/O程序执行完了,eventLoop线程会把结果返回给主线程,主线程利用回调函数调用结果,完成任务</span><br><span class="line">（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</span><br><span class="line">（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</span><br><span class="line">（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</span><br><span class="line">（4）主线程不断重复上面的第三步。</span><br><span class="line"></span><br><span class="line">宏任务和微任务的执行顺序</span><br><span class="line">	一次事件循环中，先执行宏任务队列里的一个任务，再把微任务队列里的所有任务执行完毕，再去宏任务队列取下一个宏任务执行。</span><br></pre></td></tr></table></figure>

# 宏任务和微任务

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">js 是单线程执行的，js中的任务按顺序一个一个的执行，但是一个任务耗时太长，那么后面的任务就需要等待，为了解决这种情况，将任务分为了同步任务和异步任务，而异步任务又可以分为微任务和宏任务</span><br><span class="line"></span><br><span class="line">概念</span><br><span class="line">1.宏任务：当前调用栈中执行的代码成为宏任务。（主代码快，定时器等等）浏览器api。</span><br><span class="line">2.微任务：当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务,可以理解为回调事件。 ES6语法规定的（promise.then，proness.nextTick等等）。</span><br><span class="line">3.宏任务中的事件放在callback queue中，由事件触发线程维护；微任务的事件放在微任务队列中，由js引擎线程维护。</span><br><span class="line">4.清空队列的时候，然后再dom 渲染</span><br><span class="line"></span><br><span class="line">运行机制</span><br><span class="line">1. 在执行栈中执行一个宏任务。</span><br><span class="line">2. 执行过程中遇到微任务，将微任务添加到微任务队列中。</span><br><span class="line">3. 当前宏任务执行完毕，立即执行微任务队列中的任务。</span><br><span class="line">4. 当前微任务队列中的任务执行完毕，检查渲染，GUI线程接管渲染。</span><br><span class="line">5. 渲染完毕后，js线程接管，开启下一次事件循环，执行下一次宏任务（事件队列中取）。</span><br><span class="line"></span><br><span class="line">微任务：process.nextTick、MutationObserver、Promise.then catch finally  DOM渲染前触发</span><br><span class="line">宏任务：I/O、setTimeout、setInterval、setImmediate、requestAnimationFrame DOM渲染后除非</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">js执行顺序，（先执行宏任务列，微任务队列）</span><br><span class="line">先同步再异步，在此基础上先宏任务再微任务</span><br><span class="line"></span><br><span class="line">流程：</span><br><span class="line">	同步和异步任务分别进入不同的执行“场所”，同步进入主线程，异步进入Event Table并注册函数。当指定的事情完成时，Event Table会将这个函数移入Event Queue。主线程内的任务执行完毕为空，回去了Event Queue读取对应的函数，进入主线程。</span><br><span class="line">	上述过程会不断重复，也就是常说的Event Loop（事件循环）。</span><br><span class="line">	但是，JS异步还有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入event queue，然后再执行微任务，将微任务放入eventqueue，但是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回调函数，然后再从宏任务的queue拿宏任务的回调函数，</span><br></pre></td></tr></table></figure>

# 同步异步的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在js中，所有任务都分为同步任务和异步任务两大类。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</span><br><span class="line"></span><br><span class="line">（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</span><br><span class="line">（2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。只要异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。</span><br><span class="line">（3）一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;任务队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</span><br><span class="line">（4）主线程不断重复上面的第三步。</span><br><span class="line"></span><br><span class="line">有时候 setTimeout明明写的延时3秒，实际却5，6秒才执行函数，这又是因为什么？</span><br><span class="line"></span><br><span class="line">答：setTimeout 并不能保证执行的时间，是否及时执行取决于 JavaScript 线程是拥挤还是空闲。</span><br><span class="line">浏览器的JS引擎遇到setTimeout，拿走之后不会立即放入异步队列，同步任务执行之后，timer模块会到设置时间之后放到异步队列中。js引擎发现同步队列中没有要执行的东西了，即运行栈空了就从异步队列中读取，然后放到运行栈中执行。所以setTimeout可能会多了等待线程的时间。</span><br><span class="line">这时setTimeout函数体就变成了运行栈中的执行任务，运行栈空了，再监听异步队列中有没有要执行的任务，如果有就继续执行，如此循环，就叫Event Loop。</span><br></pre></td></tr></table></figure>

# node 中的事件循环

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Node.js 采用事件驱动和异步 I/O 的方式，实现了一个单线程、高并发的 JavaScript 运行时环境，而单线程就意味着同一时间只能做一件事，那么 Node.js 如何通过单线程来实现高并发和异步 I/O？本文将围绕这个问题来探讨 Node.js 的单线程模型 。</span><br><span class="line"></span><br><span class="line">高并发策略</span><br><span class="line">一般来说，高并发的解决方案就是提供多线程模型，服务器为每个客户端请求分配一个线程，使用同步 I/O，系统通过线程切换来弥补同步 I/O 调用的时间开销。比如 Apache 就是这种策略，由于 I/O 一般都是耗时操作，因此这种策略很难实现高性能，但非常简单，可以实现复杂的交互逻辑。</span><br><span class="line"></span><br><span class="line">而事实上，大多数网站的服务器端都不会做太多的计算，它们接收到请求以后，把请求交给其它服务来处理（比如读取数据库），然后等着结果返回，最后再把结果发给客户端。因此，Node.js 针对这一事实采用了单线程模型来处理，它不会为每个接入请求分配一个线程，而是用一个主线程处理所有的请求，然后对 I/O 操作进行异步处理，避开了创建、销毁线程以及在线程间切换所需的开销和复杂性。</span><br><span class="line"></span><br><span class="line">事件循环</span><br><span class="line">Node.js 在主线程里维护了一个事件队列，当接到请求后，就将该请求作为一个事件放入这个队列中，然后继续接收其他请求。当主线程空闲时(没有请求接入时)，就开始循环事件队列，检查队列中是否有要处理的事件，这时要分两种情况：如果是非 I/O 任务，就亲自处理，并通过回调函数返回到上层调用；如果是 I/O 任务，就从 线程池 中拿出一个线程来处理这个事件，并指定回调函数，然后继续循环队列中的其他事件。</span><br><span class="line"></span><br><span class="line">当线程中的 I/O 任务完成以后，就执行指定的回调函数，并把这个完成的事件放到事件队列的尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用。 这个过程就叫 事件循环 (Event Loop)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这个图是整个 Node.js 的运行原理，从左到右，从上到下，Node.js 被分为了四层，分别是 应用层、V8引擎层、Node API层 和 LIBUV层。</span><br><span class="line"></span><br><span class="line">应用层：   即 JavaScript 交互层，常见的就是 Node.js 的模块，比如 http，fs</span><br><span class="line"></span><br><span class="line">V8引擎层：  即利用 V8 引擎来解析JavaScript 语法，进而和下层 API 交互</span><br><span class="line"></span><br><span class="line">NodeAPI层：  为上层模块提供系统调用，一般是由 C 语言来实现，和操作系统进行交互 。</span><br><span class="line"></span><br><span class="line">LIBUV层： 是跨平台的底层封装，实现了 事件循环、文件操作等，是 Node.js 实现异步的核心 。</span><br><span class="line"></span><br><span class="line">无论是 Linux 平台还是 Windows 平台，Node.js 内部都是通过 线程池 来完成异步 I/O 操作的，而 LIBUV 针对不同平台的差异性实现了统一调用。因此，Node.js 的单线程仅仅是指 JavaScript 运行在单线程中，而并非 Node.js 是单线程。</span><br><span class="line"></span><br><span class="line">工作原理</span><br><span class="line">Node.js 实现异步的核心是事件，也就是说，它把每一个任务都当成 事件 来处理，然后通过 Event Loop 模拟了异步的效果，为了更具体、更清晰的理解和接受这个事实，下面我们用伪代码来描述一下其工作原理 。</span><br></pre></td></tr></table></figure>

# 数据请求设置请求数据格式 Content-Type

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.浏览器默认的 application/x-www-form-urlencoded(url因扣得的)</span><br><span class="line">这应该是最常见的 POST 提交数据的方式了。浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。</span><br><span class="line"></span><br><span class="line">2.multipart(莫踢怕特)/form-data</span><br><span class="line">这也是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，就要让 form 的 enctype 等于这个值</span><br><span class="line"></span><br><span class="line">3.application/json</span><br><span class="line">除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify</span><br><span class="line"></span><br><span class="line">4.text/xml</span><br><span class="line">相比于JSON，不能更好的适用于数据交换，它包含了太多的包装, 而且它跟大多数编程语言的数据模型不匹配，让大多数程序员感到诧异，XML是面向数据的，JSON是面向对象和结构的，JSON会给程序员一种更加亲切的感觉。</span><br></pre></td></tr></table></figure>

# 数组扁平化

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">1. reduce</span><br><span class="line"></span><br><span class="line">遍历数组每一项，若值为数组则递归遍历，否则concat。</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;  </span><br><span class="line">    return arr.reduce((result, item)=&gt; &#123;</span><br><span class="line">        return result.concat(Array.isArray(item) ? flatten(item) : item);</span><br><span class="line">    &#125;, []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reduce是数组的一种方法，它接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</span><br><span class="line">reduce包含两个参数：回调函数，传给total的初始值</span><br><span class="line"></span><br><span class="line">// 求数组的各项值相加的和： </span><br><span class="line">arr.reduce((total, item)=&gt; &#123;  // total为之前的计算结果，item为数组的各项值</span><br><span class="line">    return total + item;</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. toString &amp; split</span><br><span class="line">调用数组的toString方法，将数组变为字符串然后再用split分割还原为数组</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return arr.toString().split(&#x27;,&#x27;).map(function(item) &#123;</span><br><span class="line">        return Number(item);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">因为split分割后形成的数组的每一项值为字符串，所以需要用一个map方法遍历数组将其每一项转换为数值型</span><br><span class="line"></span><br><span class="line">3. join &amp; split</span><br><span class="line">和上面的toString一样，join也可以将数组转换为字符串</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return arr.join(&#x27;,&#x27;).split(&#x27;,&#x27;).map(function(item) &#123;</span><br><span class="line">        return parseInt(item);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4. 递归</span><br><span class="line"></span><br><span class="line">递归的遍历每一项，若为数组则继续遍历，否则concat</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    var res = [];</span><br><span class="line">    arr.map(item =&gt; &#123;</span><br><span class="line">        if(Array.isArray(item)) &#123;</span><br><span class="line">            res = res.concat(flatten(item));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            res.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5. 扩展运算符</span><br><span class="line">es6的扩展运算符能将二维数组变为一维</span><br><span class="line"></span><br><span class="line">[].concat(...[1, 2, 3, [4, 5]]);  // [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">根据这个结果我们可以做一个遍历，若arr中含有数组则使用一次扩展运算符，直至没有为止。</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    while(arr.some(item=&gt;Array.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

# 如何扩展数组,让他拥有新的方法

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.push.apply(a,b)</span><br></pre></td></tr></table></figure>

# class 中 super 作用是什么

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">es5 的继承是先创建子类的this，然后将父类的方法添加到子类的this上去；</span><br><span class="line">es6 的继承是创建父类的this对象，然后再对this对象添加方法/属性。</span><br><span class="line">而super方法就是用来创建父类this对象的。</span><br><span class="line"></span><br><span class="line">实际上执行的是 super.sport.call(this);</span><br></pre></td></tr></table></figure>

# xss 攻击和 csrf 攻击是什么

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">1、CSRF（Cross-site request forgery）：跨站请求伪造。</span><br><span class="line">（1）登录受信任网站A，并在本地生成Cookie。</span><br><span class="line">	（如果用户没有登录网站A，那么网站B在诱导的时候，请求网站A的api	接口时，会提示你登录）</span><br><span class="line">（2）在不登出A的情况下，访问危险网站B（其实是利用了网站A的漏洞）</span><br><span class="line"></span><br><span class="line">CSRF如何防御</span><br><span class="line">方法一: Token 验证：（用的最多）</span><br><span class="line">	（1）服务器发送给客户端一个token；</span><br><span class="line">	（2）客户端提交的表单中带着这个token。</span><br><span class="line">	（3）如果这个 token 不合法，那么服务器拒绝这个请求。</span><br><span class="line">方法二: 隐藏令牌：</span><br><span class="line">	把 token 隐藏在 http 的 head头中。</span><br><span class="line">	方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。</span><br><span class="line">方法三: Referer(锐服尔) 验证：</span><br><span class="line">	Referer 指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截。</span><br><span class="line"></span><br><span class="line">2、XSS（Cross Site Scripting）：跨站脚本攻击。</span><br><span class="line">XSS攻击的核心原理是：</span><br><span class="line">	不需要你做任何的登录认证，它会通过合法的操作（比如在url中输入、在评论框中输入），</span><br><span class="line">	向你的页面注入脚本（可能是js、hmtl代码块等）。</span><br><span class="line">最后导致的结果可能是：</span><br><span class="line">	盗用Cookie破坏页面的正常结构，插入广告等恶意内容D-doss攻击</span><br><span class="line">XSS的攻击方式</span><br><span class="line">1、反射型</span><br><span class="line">	发出请求时，XSS代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，</span><br><span class="line">	XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS。</span><br><span class="line">2、存储型存</span><br><span class="line">	储型XSS和反射型XSS的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），</span><br><span class="line">	下次请求时目标页面时不用再提交XSS代码。</span><br><span class="line"></span><br><span class="line">XSS的防范措施（encode + 过滤）主要有三个：</span><br><span class="line">1、编码：</span><br><span class="line">	对用户输入的数据进行HTML Entity(安特踢) 编码。</span><br><span class="line">2、过滤：</span><br><span class="line">	移除用户输入的和事件相关的属性。如onerror可以自动触发攻击，还有onclick等。</span><br><span class="line">	（总而言是，过滤掉一些不安全的内容）移除用户输入的Style节点、Script节点、Iframe节点。</span><br><span class="line">	（尤其是Script节点，它可是支持跨域的呀，一定要移除）。</span><br><span class="line">3、校正</span><br><span class="line">	避免直接对HTML Entity进行解码。</span><br><span class="line">	使用DOM Parse转换，校正不配对的DOM标签。</span><br><span class="line">		这个概念，它的作用是把文本解析成DOM结构。</span><br><span class="line">		比较常用的做法是，通过第一步的编码转成文本，然后第三步转成DOM对象，然后经过第二步的过滤。</span><br><span class="line">	还有一种简洁的答案：</span><br><span class="line">	首先是encode，如果是富文本，就白名单。</span><br><span class="line"></span><br><span class="line">3、CSRF 和 XSS 的区别:</span><br><span class="line">区别一：</span><br><span class="line">	CSRF：需要用户先登录网站A，获取 cookie。</span><br><span class="line">	XSS：不需要登录。</span><br><span class="line">区别二：（原理的区别）</span><br><span class="line">	CSRF：是利用网站A本身的漏洞，去请求网站A的api。</span><br><span class="line">	XSS：是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。</span><br></pre></td></tr></table></figure>

# webapp 和小程序有什么区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">首先，微信小程序已经提供了一套 view, data, model, router 层的开发工具，</span><br><span class="line">对于开发简单应用，小程序是可以比 webapp 更加快速的。</span><br><span class="line"></span><br><span class="line">但是实际上微信小程序提供的这一套开发框架，要开发一些复杂应用，是很困难的，</span><br><span class="line">因为：小程序不支持 npm 等 package manager(麦呢橘)无法复用社区中已经很成熟的 web 框架和工具组件只能封装 view 和 style，无法封装行为（handler），行为只能定义在 page 上小程序有 1mb 的限制，所以我们只能将图片之类的静态资源事先放在服务器上</span><br><span class="line"></span><br><span class="line">其次，微信小程序是由微信自己来 host，开发者只需要上传就好，</span><br><span class="line">而微信 webapp 需要开发者自己 host，还需要注册域名甚至备案才可以调用微信接口以及跟公众号集成。</span><br><span class="line">所以微信小程序降低了开发者的门槛。</span><br><span class="line"></span><br><span class="line">综上，对于简单的工具型应用，微信小程序可以让开发者加快开发速度，降低发布门槛，</span><br><span class="line">这种类型的应用比较适合微信小程序。对于复杂的应用，webapp 是更适合的形式。</span><br></pre></td></tr></table></figure>

# react 优缺点

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">优点：</span><br><span class="line">1、采用虚拟 DOM，它并不直接对DOM进行操作，安插在javascript逻辑和实际的DOM之间，性能好</span><br><span class="line">2、跨浏览器兼容：虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没问题的。</span><br><span class="line">3、一切都是组件：代码更加 模块化 ，重用代码更容易，可维护性高。</span><br><span class="line">4、单向数据流：redux 实现是一个用于在JavaScript应用中创建单向数据层的架构，它随着React视图库的开发而被Facebook概念化。</span><br><span class="line">5、同构、纯粹的javascript：因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化。</span><br><span class="line">6、兼容性好：比如使用RequireJS来加载和打包，而Browserify(不弱瑟)和Webpack适用于构建大型应用。它们使得那些艰难的任务不再让人望而生畏。</span><br><span class="line">7、JSX语法：为了更加便利的模拟DOM结构，我们使用了JSX语法，可以让我们在JS中编译DOM结构                 </span><br><span class="line">8、函数式编程：JS的最大特点就是函数式编程，在React中，函数式编程可谓式无处不见</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">不适合单独做一个完整的框架：react是视图层框架，大型项目想要一套完整的框架的话，也许还需要引入Flux和route相关的东西。</span><br></pre></td></tr></table></figure>

# react 生命周期

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">16版本：</span><br><span class="line">初始阶段:</span><br><span class="line">constructor</span><br><span class="line">	定义state</span><br><span class="line">componentWillMount(这个钩子函数在将来会被弃用)</span><br><span class="line">	为挂载做准备工作</span><br><span class="line">render</span><br><span class="line">	解析 this.state 和 this.props</span><br><span class="line">	将jsx型的虚拟dom渲染为对象类型的虚拟dom</span><br><span class="line">	render 中不允许使用 this.setState() 如何你使用了，就会栈溢出</span><br><span class="line">componentDidMount</span><br><span class="line">	表示组件挂载结束</span><br><span class="line">	虚拟dom -&gt; Real dom</span><br><span class="line">	可以获取真实dom</span><br><span class="line">	数据请求 -&gt; 赋值给state</span><br><span class="line">	第三方库实例化/DOM操作</span><br><span class="line"></span><br><span class="line">更新阶段:</span><br><span class="line">componentWillReceiveProps(在17版本中被弃用)</span><br><span class="line">	这个钩子实际作用是判断组件身上的props是否发生改变</span><br><span class="line">shouldComponentUpdate</span><br><span class="line">	可以决组件是否要更新渲染 return true/false</span><br><span class="line">	接收新旧状态，用于作对比（浅对比）</span><br><span class="line">	一般需要我们手动作深对比</span><br><span class="line">	这个钩子函数是React组件性能优化的一种方式</span><br><span class="line">componentWillUpdate</span><br><span class="line">	表示组件更新前的准备</span><br><span class="line">	这个钩子函数在未来版本被弃用</span><br><span class="line">render</span><br><span class="line">	和初始化阶段的作用一致</span><br><span class="line">componentDidUpdate</span><br><span class="line">	对Real dom 作操作</span><br><span class="line">	注意：父组件数据更新，子组件会重新运行render，反之不行</span><br><span class="line">	每次都要运行子组件render，会造成react性能浪费</span><br><span class="line">	粗略解决方案：</span><br><span class="line">		在shouldComponentUpdate中，可判断哪些数据改变从而来控制return true/false</span><br><span class="line">		继而决定是否需要更新render渲染</span><br><span class="line">	更好的解决方案：</span><br><span class="line">    1.引用PureComponent，让类组件继承（extends）PureComponent</span><br><span class="line">      如：class App extends  PureComponent&#123;&#125;</span><br><span class="line">    2.引用memo，让函数组件写在memo（）里 如：const memoApp =memo（function App() &#123;&#125;）</span><br><span class="line">    3.除了memo之外，更细致的是函数组件中还可以用useCallback（方法）和useMemo（对象和数组）两个钩子阻止组件render</span><br><span class="line"></span><br><span class="line">销毁阶段:</span><br><span class="line">componentWillUnmount</span><br><span class="line">	销毁组件</span><br><span class="line">	清除无用实例和事件</span><br><span class="line">错误捕获:</span><br><span class="line">	componentDidCatch</span><br><span class="line">	用户捕获子组件throw的错误，然后显示回退UI</span><br><span class="line"></span><br><span class="line">15版本：</span><br><span class="line">相对于16版本，初始化阶段（constructor钩子变成下列两个）：</span><br><span class="line"></span><br><span class="line">定义于初始化props的 getDefalutProps 钩子函数</span><br><span class="line"></span><br><span class="line">定义于初始化state的 getInitialState 钩子函数</span><br><span class="line">没有错误捕获阶段</span><br><span class="line"></span><br><span class="line">17版本：</span><br><span class="line">相对于16版本 少3多2</span><br><span class="line"></span><br><span class="line">少了componentWillMount，componentWillReceiveProps，componentWillUpdate 3个钩子函数</span><br><span class="line">   (斯塔得可)  (迪外的)</span><br><span class="line">多了static getDerivedStateFromProps钩子函数                           (破外服)</span><br><span class="line">	一个静态方法，所以不能在这个函数里面使用this，这个函数有两个参数nextProps和prevState，这个函数会返回一个对象用来更新当前的state对象，如果不需要更新可以返回null。</span><br><span class="line">	简单说就是，可以增加一次state状态</span><br><span class="line">	  (斯那坡秀的)</span><br><span class="line">多了getSnapshotBeforeUpdate钩子函数</span><br><span class="line">	快照</span><br><span class="line">	这个函数有一个返回值，会作为第三个参数传递给componentDidUpdate钩子</span><br></pre></td></tr></table></figure>

# redux 流程 redux 的原理

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">view用actionCreator(酷睿A特)创建一个action，里面可能包含一些数据</span><br><span class="line">使用store的dispatch方法将action传入store</span><br><span class="line">store将action与旧的state转发给reducer</span><br><span class="line">reducer深拷贝state,并返回一个新的state给store</span><br><span class="line">store接收并更新state</span><br><span class="line">使用store.subscribe(萨布斯快不)订阅更新,重新render组件</span><br><span class="line"></span><br><span class="line">redux组成</span><br><span class="line">	state  :用来存储数据和数据管理的、更新视图</span><br><span class="line">	reducer:是一个纯函数，接收旧 state 和 action，根据不同的 Action 做出不同的操作并返回新的 state</span><br><span class="line">	actions:发送动作给reducer,reducer接收动作，判断动作类型修改数据，修改事件后，组件重新做redux事件的订阅</span><br><span class="line"></span><br><span class="line">Redux三大原则</span><br><span class="line">单一数据源:</span><br><span class="line">	整个应用的 state 被存储在一个 Object tree 中，且只存在于唯一的Store中</span><br><span class="line"></span><br><span class="line">state 是只读的:</span><br><span class="line">	唯一改变 state 的方法就是触发 action，action 是一个用于描述发生事件的普通对象，视图部分只需要表达想要修改的意图，所有修改都会被集中化处理。</span><br><span class="line"></span><br><span class="line">状态的改变通过纯函数来完成:</span><br><span class="line">	Redux使用纯函数方式来执行状态的修改，Action表明了修改状态值的意图，而真正执行状态修改的则是Reducer。且Reducer必须是一个纯函数，当Reducer接收到Action时，Action并不能直接修改State的值，而是通过创建一个新的状态对象来返回修改的状态。</span><br></pre></td></tr></table></figure>

# redux 中间件

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在action 和 store 之间执行中间件</span><br><span class="line"></span><br><span class="line">Redux中间件机制</span><br><span class="line">	Redux本身就提供了非常强大的数据流管理功能，但这并不是它唯一的强大之处，它还提供了利用中间件来扩展自身功能，以满足用户的开发需求</span><br><span class="line"></span><br><span class="line">     (米的为尔)</span><br><span class="line">applyMiddlewares():它是 Redux 的原生方法，作用是将所有中间件组成一个数组，依次执行。</span><br><span class="line">applyMiddleware顾名思义，用于调用各种中间件；</span><br><span class="line">applyMiddleware执行后，将所有入参中间件存入一个数组，并且返回一个闭包（闭包的概念不做累述）</span><br><span class="line">闭包接受一个createStore作为入参并且执行后返回下一个闭包。</span><br></pre></td></tr></table></figure>

# redux-thunk|异步 action

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">首先检查参数 action 的类型，如果是函数的话，就执行这个 action 函数，</span><br><span class="line">并把 dispatch, getState, extraArgument(哎克斯拽埃歌门特) 作为参数传递进去，</span><br><span class="line">否则就调用 next 让下一个中间件继续处理 action</span><br><span class="line"></span><br><span class="line">好处</span><br><span class="line">	可以进行前后端数据交互</span><br><span class="line">缺点</span><br><span class="line">    将带有数据请求的action和没有带有数据请求的action混在一起了</span><br><span class="line">    缺点解决： 弃用redux-thunk,使用redux-saga</span><br><span class="line">    redux-saga可以将异步action和普通action区别开来</span><br></pre></td></tr></table></figure>

# redux-saga|集中处理异步 action

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redux-saga可以将异步action和普通action区别开来，控制器与更优雅的异步处理</span><br><span class="line">redux-saga就是用Generator(杰呢瑞特)来处理异步。</span><br><span class="line"></span><br><span class="line">redux-saga文档并没有说自己是处理异步的工具，而是说用来处理边际效应（side effects），这里的边际效应你可以理解为程序对外部的操作，比如请求后端，比如操作文件。</span><br><span class="line"></span><br><span class="line">redux-saga相当于在Redux原有数据流中多了一层，通过对Action进行监听，从而捕获到监听的Action，然后可以派生一个新的任务对state进行维护（这个看项目本身的需求），通过更改的state驱动View的变更。</span><br><span class="line"></span><br><span class="line">redux-saga同样是一个redux中间件，它的定位就是通过集中控制action，起到一个类似于MVC中控制器的效果。</span><br><span class="line">同时它的语法使得复杂异步操作不会像promise那样出现很多then的情况，更容易进行各类测试。</span><br></pre></td></tr></table></figure>

# redux 与 react-redux 的关系

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redux是独立的应用状态管理工具。它是可以独立于react之外的。如果我们需要在react当中运用它，那么我们需要手动订阅store的状态变化，来对我们的react组件进行更新。react-reudx这个工具，就帮我们实现了这个功能，我们只需对store进行处理，react组件就会有相应的变化。</span><br><span class="line"></span><br><span class="line">Redux的核心由三部分组成：Store, Action, Reducer。</span><br><span class="line">Store: 是个对象，贯穿你整个应用的数据都应该存储在这里。</span><br><span class="line">Action: 是个对象，必须包含type这个属性，reducer将根据这个属性值来对store进行相应的处理。除此之外的属性，就是进行这个操作需要的数据。</span><br><span class="line">Reducer: 是个函数。接受两个参数：要修改的数据(state) 和 action对象。根据action.type来决定采用的操作，对state进行修改，最后返回新的state。</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">Redux: store, action, reducer</span><br><span class="line">store: getState, dispatch, subscribe</span><br><span class="line">combineReducers (克木拜恩)</span><br><span class="line">createStore</span><br><span class="line">store ️ dispatch ️ action ️ reducer</span><br><span class="line"></span><br><span class="line">react-redux:</span><br><span class="line">connect : 将store作为props注入</span><br><span class="line">provider(破外的): 使store在子孙组件的connect中能够获取到</span><br></pre></td></tr></table></figure>

# react-reudx

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. UI组件|显示页面??		 				 (破森特逊弄)</span><br><span class="line">   React-Redux 将所有组件分成两大类：UI 组件（presentational component）和容器组件</span><br><span class="line">2. 容器组件|负责管理数据/复杂逻辑?</span><br><span class="line">   UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。</span><br><span class="line">3. Provider组件|容器组件获取state??</span><br><span class="line">   所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。</span><br><span class="line">4. connect()|UI组件+容器组件</span><br><span class="line">   React-Redux 提供connect方法，用于从 UI 组件生成容器组件。connect的意思，就是将这两种组件连起来。</span><br></pre></td></tr></table></figure>

# DVA 与 CRA 相比的优点

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dva:</span><br><span class="line">	dva 首先是一个基于 redux 和 redux-saga 的数据流方案，然后为了简化开发体验，dva 还额外内置了 react-router 和 fetch，所以也可以理解为一个轻量级的应用框架。--- 来自官方。</span><br><span class="line">	相比于cra只是多了内置的redux和redux-saga，帮我们处理了数据流这方面的需求而已。如果只是想要达到这个效果的话，直接在cra中增加dva-core的依赖也是可以做到的。</span><br><span class="line"></span><br><span class="line">umi:</span><br><span class="line">	是一个可插拔的企业级 react 应用框架。umi和cra都是应用框架，可能相比cra来说umi的功能点更多一些，只能说是功能性的话umi要相对来说更胜一筹</span><br></pre></td></tr></table></figure>

# flux

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">flux 是 react 中的类似于 vuex 的公共状态管理方案，它是 Facebook 官方给出的应用架构，利用数据的单向流动的形式对公共状态进行管理。现已不推荐使用。</span><br><span class="line"></span><br><span class="line">flux的组成</span><br><span class="line">	View：视图层</span><br><span class="line">	Action：视图发出的消息</span><br><span class="line">	Dispatcher：派发者，用来接收Action，执行回调函数</span><br><span class="line">	Store：数据层，存放状态，一旦发生改动</span><br><span class="line"></span><br><span class="line">flux 在进行数据更新时，会经历以下几步：</span><br><span class="line">	用户与 View 层交互，触发 Action</span><br><span class="line">	Action 使用 dispatcher.dispatch 将Action自己的状态发送给dispatcher</span><br><span class="line">	dispatcher 通过register注册事件，再通过Action传入的类型来触发对应的 Store 回调进行更新</span><br><span class="line">	Store 里进行相应的数据更新，并触发 View 层事件使试图也同步更新</span><br><span class="line">	View层 收到信号进行更新</span><br><span class="line"></span><br><span class="line">redux和flux的区别</span><br><span class="line">　　1）redux是flux中的一个实现</span><br><span class="line">　　2）在redux中我们只能定义一个store，在flux中我们可以定义多个</span><br><span class="line">　　3）在redux中，store和dispatch都放到了store，结构更加清晰</span><br><span class="line">　　4）在redux中本身就内置State对象，对仓库的管理更加明确</span><br></pre></td></tr></table></figure>

# React 中 keys 的作用

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">key是react用于追踪哪些列表被修改、被添加或者被移出的辅助标识。</span><br><span class="line"></span><br><span class="line">在开发过程中，我们需要保证某些元素在同级的元素中key是具有唯一性的特性，在react Diff算法中React会借助元素的key值来判断该元素是新创建的还是移动而来的元素，从而减少元素的不必要的重复渲染。此外，我们还需要借助key值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。</span><br><span class="line"></span><br><span class="line">react根据key来决定是销毁重新创建组件还是更新组件，原则是：</span><br><span class="line"></span><br><span class="line">key相同，组件有所变化，react会只更新组件对应变化的属性。</span><br><span class="line">key不同，组件会销毁之前的组件，将整个组件重新渲染。</span><br></pre></td></tr></table></figure>

# react 新特性

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">render</span><br><span class="line">支持返回这五类:</span><br><span class="line">React elements, 数组, Fragments, Portal, String/numbers, boolean/null, 基础数据类型</span><br><span class="line"></span><br><span class="line">Fiber</span><br><span class="line">React Fiber的方法其实很简单——分片。把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会。</span><br><span class="line"></span><br><span class="line">新的生命周期函数</span><br><span class="line">由于异步渲染的改动，componentWillMount, componentWillReceiveProps,componentWillUpdate 三个函数将被废弃。</span><br><span class="line">由于这是一个很大的改变会影响很多现有的组件，所以需要慢慢的去改。</span><br><span class="line">目前react 16 只是会报warning，在react 17就只能在前面加UNSAFE_的前缀来使用</span><br><span class="line"></span><br><span class="line">diff算法</span><br><span class="line">作用: 计算出Virtual DOM中真 正变化的部分，并只针对该部分进行原生DOM操作，而非重新渲染整个页面</span><br><span class="line"></span><br><span class="line">getDerivedStateFromProps</span><br><span class="line">static getDerivedStateFromProps(props, state)在调用render方法之前调用，</span><br><span class="line">无论是在初始安装还是后续更新。它应返回一个对象来更新状态，或者返回null以不更新任何内容。</span><br><span class="line"></span><br><span class="line">根据props更新state</span><br><span class="line">这个生命周期可用于替代componentWillReceiveProps</span><br><span class="line"></span><br><span class="line">getSnapshotBeforeUpdate()</span><br><span class="line">getSnapshotBeforeUpdate(prevProps, prevState)在最近呈现的输出被提交到例如DOM之前调用。它使组件可以在可能更改之前从DOM捕获一些信息（例如滚动位置）。此生命周期返回的任何值都将作为参数传递给componentDidUpdate()。</span><br><span class="line"></span><br><span class="line">hooks</span><br><span class="line"></span><br><span class="line">lazy、suspense</span><br><span class="line">lazy需要跟Suspence配合使用。</span><br><span class="line">lazy实际上是帮助我们实现代码分割的功能。</span><br><span class="line"></span><br><span class="line">由于有些内容，并不一定要在首屏展示，所以这些资源没有必要一开始就要去获取，那么这些资源就可以动态获取。</span><br><span class="line">这样的话，相当于把不需要首屏展示的代码分割出来，减少首屏代码的体积，提升性能。</span><br><span class="line"></span><br><span class="line">Suspence 很像Error Boundary，不同的是Error Boundary是用来捕获错误，显示相应的callback组件。而Suspence是用来捕获还没有加载好的组件，并暂停渲染，显示相应的callback。</span><br></pre></td></tr></table></figure>

# setState 概述,同步异步

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 两个参数及用法</span><br><span class="line">	第一个参数可以是对象或者函数，是更新state</span><br><span class="line">	第二个参数获取最新的state,副作用操作，dom操作事件触发声明，数据获取，第三方库实例化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. 同步/异步原理</span><br><span class="line">	setState在合成事件和钩子函数中是异步的</span><br><span class="line">	在原生事件和setTimeout中是同步的</span><br><span class="line"></span><br><span class="line">setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。</span><br><span class="line"></span><br><span class="line">setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。</span><br></pre></td></tr></table></figure>

# react 合成事件

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 合成事件原理</span><br><span class="line">   如果DOM上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响。React为了避免这类DOM事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，实现了一个中间层——SyntheticEvent。</span><br><span class="line"></span><br><span class="line">当用户在为onClick添加函数时，React并没有将Click时间绑定在DOM上面。</span><br><span class="line">而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装交给中间层SyntheticEvent（负责所有事件合成）</span><br><span class="line">所以当事件触发的时候，对使用统一的分发函数dispatchEvent将指定函数执行。</span><br><span class="line"></span><br><span class="line">2. 与原生事件的区别</span><br><span class="line">   React合成事件一套机制：React并不是将click事件直接绑定在dom上面，而是采用事件冒泡的形式冒泡到document上面，然后React将事件封装给正式的函数处理运行和处理。</span><br></pre></td></tr></table></figure>

# react 路由传参和读参

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.params</span><br><span class="line">&lt;Route path=&#x27;/path/:name&#x27; component=&#123;Path&#125;/&gt;</span><br><span class="line">&lt;link to=&quot;/path/2&quot;&gt;xxx&lt;/Link&gt;</span><br><span class="line">this.props.history.push(&#123;pathname:&quot;/path/&quot; + name&#125;);</span><br><span class="line">读取参数用:this.props.match.params.name</span><br><span class="line">优势:刷新地址栏，参数依然存在</span><br><span class="line">缺点:只能传字符串，并且，如果传的值太多的话，url会变得长而丑陋。</span><br><span class="line"></span><br><span class="line">2.query</span><br><span class="line">&lt;Route path=&#x27;/query&#x27; component=&#123;Query&#125;/&gt;</span><br><span class="line">&lt;Link to=&#123;&#123; path : &#x27; /query&#x27; , query : &#123; name : &#x27;sunny&#x27; &#125;&#125;&#125;&gt;</span><br><span class="line">this.props.history.push(&#123;pathname:&quot;/query&quot;,query: &#123; name : &#x27;sunny&#x27; &#125;&#125;);</span><br><span class="line">读取参数用: this.props.location.query.name</span><br><span class="line">优势: 传参优雅，传递参数可传对象；</span><br><span class="line">缺点: 刷新地址栏，参数丢失</span><br><span class="line"></span><br><span class="line">3.state</span><br><span class="line">&lt;Route path=&#x27;/sort &#x27; component=&#123;Sort&#125;/&gt;</span><br><span class="line">&lt;Link to=&#123;&#123; path : &#x27; /sort &#x27; , state : &#123; name : &#x27;sunny&#x27; &#125;&#125;&#125;&gt;</span><br><span class="line">this.props.history.push(&#123;pathname:&quot;/sort &quot;,state : &#123; name : &#x27;sunny&#x27; &#125;&#125;);</span><br><span class="line">读取参数用: this.props.location.query.state</span><br><span class="line">优缺点同query</span><br><span class="line"></span><br><span class="line">4.search</span><br><span class="line">&lt;Route path=&#x27;/web/departManange &#x27; component=&#123;DepartManange&#125;/&gt;</span><br><span class="line">&lt;link to=&quot;web/departManange?tenantId=12121212&quot;&gt;xxx&lt;/Link&gt;</span><br><span class="line">this.props.history.push(&#123;pathname:&quot;/web/departManange?tenantId&quot; + row.tenantId&#125;);</span><br><span class="line">读取参数用: this.props.location.search</span><br><span class="line">优缺点同params</span><br></pre></td></tr></table></figure>

# redux 和 mobx(类似双向数据绑定)区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 组成部分</span><br><span class="line">   actions-&gt;state-&gt;computed values-&gt;Reactions</span><br><span class="line">2. 工作流</span><br><span class="line">   在mobx中， 数据是通过加 @observable 作为可监测的被观察者， 在view层中， 你可以通过添加@observer 将view作为观察者，对数据进行监测， 如果要触发改变数据，则使用@action, 事实上，你可以直接在view层改变数据， 但这种方式不便监控数据，因此不推荐直接改变数据。 而@computed可以用来计算数据， 也可以是计算多个数据之后返回新的数据， 如果其中数据改变， @computed也会触发改变</span><br><span class="line">3. 优点</span><br><span class="line">   不同于redux的单一数据流， mobx中，你可以同时在各个地方使用同一份state, 也可以在一个页面中使用多个store文件</span><br></pre></td></tr></table></figure>

# react 组件通信 5 种

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1.父组件向子组件通信</span><br><span class="line">React数据流动是单向的,父组件向子组件通信也是最常见的;父组件通过props向子组件传递需要的信息</span><br><span class="line"></span><br><span class="line">2.子组件向父组件通信</span><br><span class="line">利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。</span><br><span class="line"></span><br><span class="line">3.非嵌套组件间通信</span><br><span class="line">非嵌套组件，就是没有任何包含关系的组件，包括兄弟组件以及不在同一个父级中的非兄弟组件。对于非嵌套组件，可以采用下面两种方式：</span><br><span class="line">	利用二者共同父组件的 context 对象进行通信</span><br><span class="line">	使用自定义事件的方式</span><br><span class="line">如果采用组件间共同的父级来进行中转，会增加子组件和父组件之间的耦合度，如果组件层次较深的话，找到二者公共的父组件不是一件容易的事，当然还是那句话，也不是不可以。</span><br><span class="line"></span><br><span class="line">4.跨组件通信</span><br><span class="line">所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：</span><br><span class="line">	中间组件层层传递 props</span><br><span class="line">	使用 context 对象</span><br><span class="line">中间组件层层传递 props:</span><br><span class="line">    如果父组件结构较深，那么中间的每一层组件都要去传递 props，增加了复杂度，并且这些 props 并不是这些中间组件自己所需要的。不过这种方式也是可行的，当组件层次在三层以内可以采用这种方式，当组件嵌套过深时，采用这种方式就需要斟酌了。</span><br><span class="line"></span><br><span class="line">使用 context 对象:</span><br><span class="line">	context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。</span><br><span class="line">使用 context 也很简单，需要满足两个条件：</span><br><span class="line">	上级组件要声明自己支持 context，并提供一个函数来返回相应的 context 对象</span><br><span class="line">	子组件要声明自己需要使用 context</span><br><span class="line"></span><br><span class="line">5.redux</span><br><span class="line">首先由view dispatch拦截action，然后执行对应reducer并更新到store中，最终views会根据store数据的改变执行界面的刷新渲染操作。</span><br><span class="line">	1)首先先把redux相关工具安装好</span><br><span class="line">	2)通过创建一个store实例createStore,接收一个rootReducer和中间件执行函数</span><br><span class="line">	3)创建分块的数据rootReducer,通过combineReducers打造rootReducer,里面放分块的数据</span><br><span class="line">	4)在组件中通过高阶组件connect函数,接收store里的数据,把ActionCreators里的方法绑定到组件身上,</span><br><span class="line">	  并且可以发送动作action给reducer</span><br><span class="line">	5)在reductor中根据action中的type动作类型,判断动作修改数据</span><br></pre></td></tr></table></figure>

# 组件按需加载

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">（实现方式，需要的依赖）懒加载</span><br><span class="line"></span><br><span class="line">1、vue异步组件技术</span><br><span class="line">	vue-router配置路由，使用vue的异步组件技术，可以实现按需加载。</span><br><span class="line">	但是，这种情况下一个组件生成一个js文件。</span><br><span class="line"></span><br><span class="line">2.import()</span><br><span class="line"></span><br><span class="line">3.webpack提供的require.ensure()</span><br><span class="line"></span><br><span class="line">4.第三方库比如react-loadable</span><br><span class="line"></span><br><span class="line">5.lazyload-loader</span><br></pre></td></tr></table></figure>

# 组件销毁

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount</span><br><span class="line"></span><br><span class="line">定义state  flag:false   作为开关   定义方法if判断是否为1,改变state    flag:true</span><br><span class="line"></span><br><span class="line">将方法绑定组件上  可以用三目或者短路原则&amp;&amp;控制组件的显示隐藏</span><br></pre></td></tr></table></figure>

# Ant D 中 input 输入框三个属性怎么实现

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onChange输入框内容改变时候回调    value输入的内容   defaultValue输入框默认值</span><br><span class="line"></span><br><span class="line">input默认值在input中绑定value    定义一个state   和input双向数据绑定    做成受控组件    定义一个事件   改变的时候获取e.target.value</span><br></pre></td></tr></table></figure>

# Hooks

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">为什么使用hook</span><br><span class="line">	不必写class组件就可以用state和其他的React特性；</span><br><span class="line">	自定义hook  实现组件的复用    用useEffects代替生命周期方法   代码更加简洁</span><br><span class="line"></span><br><span class="line">出现原因3点</span><br><span class="line">    为了让函数组件拥有类组件的功能。</span><br><span class="line">    	原因</span><br><span class="line">    	比如useState、useReducer  状态定义</span><br><span class="line">    	比如useEffect、useLayoutEffect 生命周期功能</span><br><span class="line">    	比如useRef useImperativeHandle 替代了类组件的 Ref</span><br><span class="line">    为了优化函数组件，比如useMemo、useCallback</span><br><span class="line">	函数组件添加新的方法,如</span><br><span class="line">    	useDebugValue显示自定义hook，自己添加hook类名</span><br><span class="line">    	自定义hooks来复用状态</span><br><span class="line"></span><br><span class="line">优点4点</span><br><span class="line">1.让函数组件可以定义状态</span><br><span class="line">	让函数组件可以使用生命周期、监听数据</span><br><span class="line">	让函数组件可以有Ref的功能（父组件获取子组件）</span><br><span class="line">	优化函数组件 useMemo、useCallback</span><br><span class="line">	自定义hooks来复用状态,</span><br><span class="line">	代码量比类组件更少，更清爽。</span><br><span class="line">2.使用规则2点</span><br><span class="line">	不要在循环，条件或嵌套函数中调用 Hook</span><br><span class="line">	只在函数组件中使用 Hooks</span><br><span class="line">3.常用Hook</span><br><span class="line">	useState:</span><br><span class="line">		定义状态 修改状态</span><br><span class="line">		返回一个数组，其中第一项是状态值，第二项是一个更新状态的函数。</span><br><span class="line">		状态一旦改变，React 就会重新渲染组件，变量获取新的状态值。</span><br><span class="line">	useEffect:</span><br><span class="line">		相当于componentDidMount,componentDidUpdate,componentWillUnmount三个钩子的组合</span><br><span class="line">		参数一：执行的回调函数；</span><br><span class="line">		参数二：该useEffect在哪些state发生变化时，才重新执行；</span><br><span class="line">		第二个参数是空数组的时候执行一次,相当于componentDidMount,不加的时候执行多次</span><br><span class="line">		第二个参数的作用就是 仅在更改时更新，实现性能的优化</span><br><span class="line">		DOM操作 第三方实例化可以做 清除无用实例和事件</span><br><span class="line">		useEffect传入的回调函数本身可以有一个返回值，</span><br><span class="line">		这个返回值是另外一个回调函数，来模拟componentWillUnmount</span><br><span class="line">	useLayoutEffect:</span><br><span class="line">		布局副作用</span><br><span class="line">			useEffect 在浏览器渲染完成后执行</span><br><span class="line">			useLayoutEffect 在浏览器渲染前执行</span><br><span class="line">		useLayoutEffect 里的任务最好影响了 Layout</span><br><span class="line">		为了用户体验，优先使用 useEffect (优先渲染)</span><br><span class="line">	useContext:</span><br><span class="line">		跨组件通信 createContext创建一个组件 &lt;numContext.Provider value=&#123;num&#125;&gt;</span><br><span class="line">	useDebugValue:</span><br><span class="line">		自定义 hook 的标签 方便调试台查看</span><br><span class="line">	useMemo:</span><br><span class="line">		记忆组件 动态缓存 新值和旧值一样,不重新渲染页面,优化作用,类似于shouldComponentUpdate     	useCallBack:</span><br><span class="line">		作用和 useMemo 一样</span><br><span class="line">		useMemo和useCallback都会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行</span><br><span class="line">		并且这两个hooks都返回缓存的值，useMemo返回缓存的变量，useCallback返回缓存的函数。</span><br><span class="line">		useCallback(x =&gt; console.log(x), [m]) 等价于</span><br><span class="line">		useMemo( () =&gt; x =&gt; console.log(x), [m])</span><br><span class="line">	useRef:</span><br><span class="line">		返回一个可变的ref对象</span><br><span class="line">	useImperativeHandle:</span><br><span class="line">		将组件中的方法放到外面使用</span><br><span class="line">		搭配React.forwardRef</span><br><span class="line"></span><br><span class="line">5.自定义hook</span><br><span class="line">   类似于高阶组件</span><br><span class="line">   高阶组件返回的一个类组件，而自定义Hook可以返回任何东 西</span><br><span class="line">   高阶组件必须传递一个组件作为参数，而自定义Hook不需要</span><br><span class="line">   function useFriendStatus(friendID) &#123;</span><br><span class="line">      const [isOnline, setIsOnline] = useState(null);</span><br><span class="line">      // 在开发者工具中的这个 Hook 旁边显示标签</span><br><span class="line">      // e.g. &quot;FriendStatus: Online&quot;</span><br><span class="line">      useDebugValue(isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;);</span><br><span class="line">      return isOnline;</span><br><span class="line">   &#125;</span><br><span class="line">可以理解为数据的操作都在hook里进行，而外部只关心自己想要的。我只要数据列表，获取产品钩子（可能并不需要，可通过参数变更从而触发重新获取数据）、删除产品钩子</span><br><span class="line">为了封装方法：节流；</span><br></pre></td></tr></table></figure>

# react useState() Hook

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.使用 useState() 进行状态管理</span><br><span class="line">	调用useState() Hook 来启用函数组件中的状态。</span><br><span class="line">	useState(initialValue)的第一个参数initialValue是状态的初始值。</span><br><span class="line">	[state, setState] = useState(initialValue)返回一个包含2个元素的数组:状态值和状态更新函数。</span><br><span class="line">	使用新值调用状态更新器函数setState(newState)更新状态。或者，可以使用一个回调setState(prev =&gt; next)来调用状态更新器，该回调将返回基于先前状态的新状态。</span><br><span class="line">	调用状态更新器后，React 确保重新渲染组件，以使新状态变为当前状态。</span><br><span class="line">2.多种状态</span><br><span class="line">	通过多次调用useState()，一个函数组件可以拥有多个状态。</span><br><span class="line">	需要注意的，要确保对useState()的多次调用在渲染之间始终保持相同的顺序。</span><br><span class="line">3.状态的延迟初始化</span><br><span class="line">	每当 React 重新渲染组件时，都会执行useState(initialState)。如果初始状态是原始值（数字，布尔值等），则不会有性能问题。</span><br><span class="line">	当初始状态需要昂贵的性能方面的操作时，可以通过为useState(computeInitialState)提供一个函数来使用状态的延迟初始化，该函数仅在初始渲染时执行一次，以获得初始状态。在以后的组件渲染中，不会再调用该函数，从而跳过昂贵的操作。</span><br><span class="line">4.调用 useState()</span><br><span class="line">在使用useState() Hook 时，必须遵循 Hook 的规则：</span><br><span class="line">1.仅顶层调用Hook:不能在循环，条件，嵌套函数等中调用useState()。在多个useState()调用中，渲染之间的调用顺序必须相同。</span><br><span class="line">2.仅从React 函数调用 Hook:必须仅在函数组件或自定义钩子内部调用useState()。</span><br></pre></td></tr></table></figure>

# 高阶组件 HOC

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.名词解释/作用</span><br><span class="line">    使函数复用，可以通过给组件传递方法来复用高阶组件中的函数方法。</span><br><span class="line">    高阶组件特点</span><br><span class="line">    高阶组件是一个函数</span><br><span class="line">    高阶组件接收一个组件作为参数进行使用，且需要在render函数中return返回这个组件</span><br><span class="line">    高阶组件的目的是为了： 复用组件,将多个组件都要使用的类似逻辑放在同一个地方进行处理，类似于在Vue中封装cookie以供重复使用</span><br><span class="line"></span><br><span class="line">2.常用高阶组件4个</span><br><span class="line">	React.memo()</span><br><span class="line">	connect()</span><br><span class="line">	provider()</span><br><span class="line">	withRouter()  // 可以使用</span><br><span class="line">3.有自己封装过吗</span><br><span class="line">    拖拽封装，给组件里面的标签添加方法就可以实现拖拽，并返回标签的x与y坐标。</span><br><span class="line">	深对比，深复制封装、正则封装、页面路由跳转、路由数据接收解析。</span><br></pre></td></tr></table></figure>

# 拖拽封装思路

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">重点：</span><br><span class="line">1、一定要绝对定位，脱离文档流才可以移动。</span><br><span class="line">2、绑定拖拽的元素，移动和鼠标松开后是对document的绑定，因为移动的是整个div。</span><br><span class="line">3、点击：a= 获取当前鼠标坐标、b =div距浏览器距离、c = 鼠标在div内部距离=a-b。</span><br><span class="line">   移动：通过  a - c 建立鼠标与div的关系，防止鼠标超出div。</span><br><span class="line"></span><br><span class="line">拖拽状态 = 0鼠标在元素上按下的时候&#123;</span><br><span class="line">	拖拽状态 = 1</span><br><span class="line">	记录下鼠标的x和y坐标</span><br><span class="line">	记录下元素的x和y坐标</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">鼠标在元素上移动的时候&#123;</span><br><span class="line">	如果拖拽状态是0就什么也不做。</span><br><span class="line">	如果拖拽状态是1，那么</span><br><span class="line">	元素y = 现在鼠标y - 原来鼠标y + 原来元素y</span><br><span class="line">	元素x = 现在鼠标x - 原来鼠标x + 原来元素x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">鼠标在任何时候放开的时候&#123;</span><br><span class="line">	拖拽状态 = 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



# 自定义 hook 封装过组件吗

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.将Hello组件和App组件中共用的逻辑放在统一的自定义hook中写</span><br><span class="line">2.自定义hook,hook名以use开头</span><br><span class="line">3.其他组件通过import引入自定义hook,就可以使用了</span><br></pre></td></tr></table></figure>

# react 和 vue 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">相同点:</span><br><span class="line">1.都使用了虚拟dom,如果需要改变任何元素的状态,先改虚拟dom,当有变化产生时,会创建新的虚拟dom,通过diff算法对比新旧虚拟dom的差异,只需要渲染差异部分就行</span><br><span class="line">2.都使用组件化</span><br><span class="line"></span><br><span class="line">不同点:</span><br><span class="line">1.react中有新语法jsx,vue用普通的html</span><br><span class="line">2.vue中父组件和子组件有通信的时候,父组件数据改变引起子组件改变,子组件会重新渲染，如果父子组件没有通信,父组件改变子组件不会渲染，react中不管是否有数据通信,父组件改变子组件都会渲染</span><br><span class="line">3.react:create-react-app</span><br><span class="line">  vue  :vue-cli</span><br><span class="line">4.react中用redux管理状态,state通过setState更新</span><br><span class="line">  vue中数据由vuex管理</span><br></pre></td></tr></table></figure>

# react 的 class 组件,没有 class 的时候怎么写

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">React.createClass</span><br><span class="line">我们最早使用这个方法来构建一个组件“类”，它接受一个对象为参数，</span><br><span class="line">对象中必须声明一个render方法，render返回一个组件实例</span><br></pre></td></tr></table></figure>

# 生命周期 钩子函数用 es5 怎么定义

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoType.componentDidMount</span><br></pre></td></tr></table></figure>

# react Native

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React Native(内特服)能在手机上创建原生应用，React在这方面处于领先位置。使用JavaScript, CSS和HTML创建原生移动应用，这是一个重要的革新。Vue社区与阿里合作开发Vue版的React Native——Weex也很不错，但仍处于开发状态且并没经过实际项目的验证。</span><br><span class="line"></span><br><span class="line">既拥有Native的用户体验、又保留React的开发效率</span><br><span class="line"></span><br><span class="line">React Native与React.js的主要区别还是JSX,它使用XML标记的方式去直接声明界面，将HTML直接嵌入到JavaScript代码中</span><br></pre></td></tr></table></figure>

# react-router(路由)原理

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">react-router依赖基础 - history</span><br><span class="line"></span><br><span class="line">history是一个独立的第三方js库，可以用来兼容在不同浏览器、不同环境下对历史记录的管理</span><br><span class="line"></span><br><span class="line">老浏览器的history:</span><br><span class="line">	主要通过hash来实现，对应createHashHistory</span><br><span class="line">高版本浏览器:</span><br><span class="line">	通过html5里面的history，对应createBrowserHistory</span><br><span class="line">node环境下:                         (不弱惹)</span><br><span class="line">	主要存储在历史记录memeory里面，对应createMemoryHistory</span><br><span class="line">抽象了一个公共的文件createHistory:</span><br><span class="line">	此时的location跟浏览器原生的location是不相同的，最大的区别就在于里面多了key字段，</span><br><span class="line">	history内部通过key来进行location的操作</span><br><span class="line"></span><br><span class="line">原理:</span><br><span class="line">1.执行URL前进</span><br><span class="line">	createBrowserHistory: pushState、replaceState</span><br><span class="line">	createHashHistory: location.hash=*** location.replace()</span><br><span class="line">	createMemoryHistory: 在内存中进行历史记录的存储</span><br><span class="line">1.检测URL回退</span><br><span class="line">	createBrowserHistory: popstate</span><br><span class="line">	createHashHistory: hashchange</span><br><span class="line">	createMemoryHistory: 因为是在内存中操作，跟浏览器没有关系，不涉及UI层面的事情，所以可以直接进行历史信息的回退</span><br><span class="line">1.state的存储</span><br><span class="line">	为了维护state的状态，将其存储在sessionStorage里面:</span><br><span class="line">	基本原理:实现URL与UI可视化界面的同步。其中在react-router中，URL对应Location对象，而UI是由react components来决定的，这样就转变成location与components之间的同步问题。</span><br><span class="line"></span><br><span class="line">在react-router中最主要的component是Router、RouterContext、Link，history库起到了中间桥梁的作用</span><br><span class="line"></span><br><span class="line">安装react-router-dom</span><br><span class="line">	Link组件用于点击链接跳转其他页面，没有路由激活</span><br><span class="line">	NavLink 用于有路由激活效果的</span><br></pre></td></tr></table></figure>

# react-router-dom 和 react-router 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">写法上的区别：</span><br><span class="line">import &#123;Swtich, Route, Router, HashHistory, Link&#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line"></span><br><span class="line">import &#123;Switch, Route, Router&#125; from &#x27;react-router&#x27;;</span><br><span class="line">import &#123;HashHistory, Link&#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line"></span><br><span class="line">react-router-dom:</span><br><span class="line">加入了在浏览器运行环境下的一些功能:</span><br><span class="line">	BrowserRouter和HashRouter组件，</span><br><span class="line">	前者使用pushState和popState事件构建路由，</span><br><span class="line">	后者使用window.location.hash和hashchange事件构建路由。</span><br><span class="line"></span><br><span class="line">react-router-dom是依赖于react-router的，其中Switch、Route、Router、Redirect等组件是直接引入react-router中的</span><br><span class="line"></span><br><span class="line">react-router-dom还另外新增了Link、BrowserRouter、HashRouter组件。</span><br><span class="line"></span><br><span class="line">在引入react-router-dom后不需要显性引入react-router，</span><br><span class="line">react-router-dom依赖react-router，npm都会将他们安装。</span><br><span class="line"></span><br><span class="line">react-router3.x与react-router-dom区别</span><br><span class="line">	react-router3.x版本下路由采用集中式配置，UI组件和路由是分开的。</span><br><span class="line">	react-router4.x版本下路由路由采用分散式配置，路由嵌套在UI组件当中，</span><br><span class="line">	更加契合组件化思想（组件中的路由也应该包含在组件之中）。</span><br></pre></td></tr></table></figure>

# react 路由模式

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">我们一直在使用的路由方式是BrowserRouter，也就是浏览器的路由方式，其实React还有几种路由方式：</span><br><span class="line">					 (不弱惹)</span><br><span class="line">1、BrowserRouter：浏览器的路由方式，也就是在开发中最常使用的路由方式</span><br><span class="line">2、HashRouter：在路径前加入#号成为一个哈希值，Hash模式的好处是，再也不会因为我们刷新而找不到我们的对应路径</span><br><span class="line">3、MemoryRouter：不存储history，所有路由过程保存在内存里，不能进行前进后退，因为地址栏没有发生任何变化</span><br><span class="line">4、NativeRouter：经常配合ReactNative使用，多用于移动端</span><br><span class="line">5、StaticRouter：设置静态路由，需要和后台服务器配合设置，比如设置服务端渲染时使用</span><br><span class="line">  (斯大推克)</span><br></pre></td></tr></table></figure>

# react 路由配置

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1、引入路由包</span><br><span class="line">	npm install --save react-router</span><br><span class="line">	npm install --save react-router-dom</span><br><span class="line">	react-router：是基本的router包，里边函的内容较多，</span><br><span class="line">				  但是在网页开发中有很多用不到，现在的市面上的课程讲的基本都是这个包的教程。</span><br><span class="line">	react-router-dom：随着react生态环境的壮大，后出现的包，</span><br><span class="line">					  这个包比react-router包轻巧了很多。</span><br><span class="line">2、设置路由配置文件</span><br><span class="line">	在src目录下新建一个Router/index.js文件用于管理路由，这里需要引入一些对应的组件和路由包文件。</span><br><span class="line">		Router的history是必需的props</span><br><span class="line">		Switch表示只渲染第一个与当前地址匹配的&lt;Route&gt;</span><br><span class="line">		Route的props path为路径，component为路径对应的页面</span><br><span class="line">		exact属性表示精确匹配,比如我们有多层路由进行嵌套时，exact可以帮助我们精确匹配到你想跳转的路由。		 exact的值为bool型，为true是表示严格匹配，为false时为正常匹配</span><br><span class="line"></span><br><span class="line">3、在入口文件引入路由配置文件</span><br><span class="line">	import RouterConfig from &#x27;./router/index.js&#x27;;</span><br><span class="line">	ReactDOM.render(&lt;RouterConfig/&gt;, document.getElementById(&#x27;root&#x27;));</span><br><span class="line"></span><br><span class="line">4、在各组件中使用路由</span><br><span class="line">	&lt;ul className=&quot;menu&quot;&gt;</span><br><span class="line">    	&lt;li&gt;&lt;NavLink to=&#x27;/Page1&#x27;&gt;第一个页面&lt;/NavLink&gt;&lt;/li&gt;</span><br><span class="line">    	&lt;li&gt;&lt;NavLink to=&#x27;/Page2&#x27;&gt;第二个页面&lt;/NavLink&gt;&lt;/li&gt;</span><br><span class="line">	&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">1.Switch:表示一次只渲染一个组件</span><br><span class="line">2.Route:路由组件,用于展示一个组件  同router-view</span><br><span class="line">3.Redirect:重定向(锐得埃克特)</span><br><span class="line">4.lazy + Suspense(色斯盘丝):实现路由懒加载</span><br><span class="line">5.exact:路径完全匹配</span><br><span class="line">6.fallback:组件切换时候的转场组件</span><br></pre></td></tr></table></figure>

# react 路由(router)实现异步加载

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">react-router，官网文档给出的是用webpack的bundle-loader</span><br><span class="line"></span><br><span class="line">require.ensure。这是webpack的旧式写法，现在已不推荐</span><br><span class="line"></span><br><span class="line">import()</span><br><span class="line">	符合ECMAScript提议的import()语法，该提案与普通 import 语句或 require 函数的类似，</span><br><span class="line">	但返回一个 Promise 对象。这意味着模块时异步加载的</span><br></pre></td></tr></table></figure>

# react 原理

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">1. setState</span><br><span class="line">	setState在合成事件和钩子函数中是异步的</span><br><span class="line">	在原生事件和setTimeout中是同步的</span><br><span class="line"></span><br><span class="line">	setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，</span><br><span class="line">	只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，</span><br><span class="line">	形式了所谓的“异步”，</span><br><span class="line"></span><br><span class="line">	第一个参数可以是对象或者函数  是更新state</span><br><span class="line">	第二个参数获取最新的state,副作用操作    dom操作事件触发声明  数据获取</span><br><span class="line"></span><br><span class="line">2. JSX语法的转化</span><br><span class="line">	JSX 仅仅是 createElement() 方法的语法糖（简化语法）</span><br><span class="line">	JSX 语法被 @babel/preset-react 插件编译为 createElement() 方法</span><br><span class="line">	react.createElement()</span><br><span class="line">	React 元素：是一个对象，用来描述你希望在屏幕上看到的内容</span><br><span class="line"></span><br><span class="line">3. 组件更新机制</span><br><span class="line">	setState() 的两个作用： 1. 修改 state 2. 更新组件（UI）</span><br><span class="line">	过程：父组件重新渲染时，也会重新渲染子组件。但只会渲染当前组件子树（当前组件及其所有子组件）</span><br><span class="line"></span><br><span class="line">4. 组件性能优化</span><br><span class="line">	减轻 state：只存储跟组件渲染相关的数据</span><br><span class="line">	避免不必要的重新渲染 : shouldComponentUpdate(nextProps, nextState)</span><br><span class="line">	通过返回值决定该组件是否重新渲染，返回 true 表示重新渲染，false 表示不重新渲染   起到优化作用</span><br><span class="line"></span><br><span class="line">5. 纯组件 PureComponent</span><br><span class="line">	PureComponent 内部自动实现了 shouldComponentUpdate 钩子，不需要手动比较</span><br><span class="line">	纯组件内部通过分别 对比 前后两次 props 和 state 的值，来决定是否重新渲染组件</span><br><span class="line">	纯组件内部的对比是 shallow compare（浅层对比）</span><br><span class="line"></span><br><span class="line">6. 虚拟 DOM 和 Diff 算法</span><br><span class="line">	数据改变视图更新</span><br><span class="line">	初次渲染时，React 会根据初始state（Model），创建一个虚拟 DOM 对象（树）。</span><br><span class="line">	根据虚拟 DOM 生成真正的 DOM，渲染到页面中。</span><br><span class="line">	当数据变化后（setState()，重新根据新的数据，创建新的虚拟DOM对象（树）。</span><br><span class="line">	与上一次得到的虚拟 DOM 对象，使用 Diff 算法 对比（找不同），生成patch补丁对象,得到需要更新的内容。</span><br><span class="line">	最终，React 只将变化的内容更新（patch）到 DOM 中，重新渲染到页面。</span><br></pre></td></tr></table></figure>

# react 的 connect 高阶组件实现, 如何在全局中取得 store

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">连接React组件与 Redux store。</span><br><span class="line">connect:connect函数的返回值是一个高阶组件,通过高阶组件来获取store中的数据</span><br><span class="line">connect底层原理:是闭包</span><br><span class="line"></span><br><span class="line">mapStateFromProps:从countReducer中解构出num数据,用来获取数据</span><br><span class="line">mapDispatchFromProps:将ActionCreators中的方法绑定到组件上,并且发送action</span><br><span class="line"></span><br><span class="line">connect调用的结果是返回一个高阶组件</span><br><span class="line">connect方法利用了合并分发的原理来帮助我们完成store内容的获取</span><br><span class="line"></span><br><span class="line">合并： 将store中的所有数据拿到手</span><br><span class="line">分发： 将我们UI需要的数据派发出去</span><br><span class="line"></span><br><span class="line">原理</span><br><span class="line">合并分发 ：合并的意思是：(我们项目中)redux的数据是集中在一处的</span><br><span class="line">分发的意思是：给的是所有数据中的分块的数据</span><br></pre></td></tr></table></figure>

# react 的 connect 实现原理

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">首先connect之所以会成功，是因为Provider组件：</span><br><span class="line">在原应用组件上包裹一层，使原来整个应用成为Provider的子组件</span><br><span class="line">接收Redux的store作为props，通过context对象传递给子孙组件上的connect</span><br><span class="line"></span><br><span class="line">那connect做了些什么呢？</span><br><span class="line">它真正连接 Redux 和 React，它包在我们的容器组件的外一层，</span><br><span class="line">它接收上面 Provider 提供的 store 里面的 state 和 dispatch，</span><br><span class="line">传给一个构造函数，返回一个对象，以属性形式传给我们的容器组件。</span><br><span class="line"></span><br><span class="line">关于它的源码</span><br><span class="line">connect是一个高阶函数，首先传入mapStateFromProps、mapDispatchFromProps，</span><br><span class="line">然后返回一个生产Component的函数(wrapWithConnect)，</span><br><span class="line">然后再将真正的Component作为参数传入wrapWithConnect，</span><br><span class="line">这样就生产出一个经过包裹的Connect组件，该组件具有如下特点:</span><br><span class="line"></span><br><span class="line">通过props.store获取祖先Component的store</span><br><span class="line">props包括stateProps、dispatchProps、parentProps,合并在一起得到nextState，作为props传给真正的Component</span><br><span class="line">componentDidMount时，添加事件this.store.subscribe(this.handleChange)，实现页面交互</span><br><span class="line">shouldComponentUpdate时判断是否有避免进行渲染，提升页面性能，并得到nextState</span><br><span class="line">componentWillUnmount时移除注册的事件this.handleChange</span><br></pre></td></tr></table></figure>

# react-router3 和 react-router4 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">一、V3或者说V早期版本是把router 和 layout components 分开</span><br><span class="line">　	在V4中是：</span><br><span class="line">		集中式 router</span><br><span class="line">		通过 &lt;Route&gt; 嵌套，实现 Layout 和 page 嵌套</span><br><span class="line">		Layout 和 page 组件 是作为 router 的一部分</span><br><span class="line">二、在V3中，我们是将整个庞大的router直接丢给Dom</span><br><span class="line">　　在V4中，除了BrowserRouter，我们丢给DOM的我们的程序本身</span><br><span class="line"></span><br><span class="line">　　另外，V4 中，我们不再使用 &#123;props.children&#125; 来嵌套组件了，</span><br><span class="line">　　替代的 &lt;Route&gt;，当 route 匹配时，子组件会被渲染到 &lt;Route&gt; 书写的地方</span><br><span class="line"></span><br><span class="line">三、在V3 中的 routing 规则是 exclusive，意思就是最终只获取一个 route</span><br><span class="line">　　而 V4 中的 routes 默认是 inclusive 的，这就意味着多个 &lt;Route&gt;可以同时匹配和呈现</span><br><span class="line"></span><br><span class="line">　　如果只想匹配一个路由，可以使用Switch，在 &lt;Switch&gt; 中只有一个 &lt;Route&gt; 会被渲染，</span><br><span class="line">　　同时可以再在每个路由添加exact，做到精准匹配</span><br><span class="line"></span><br><span class="line">　　Redirect，浏览器重定向，当多有都不匹配的时候，进行匹配</span><br></pre></td></tr></table></figure>

# react 中获取真实的 dom 节点

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用ref属性获取Dom元素后，再使用原生javascript获取内容</span><br></pre></td></tr></table></figure>

# react 是什么层面上的框架

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">React框架本身和我们常用的JavaScript MVC框架，如：AngularJS，Backbone，Ember等，没有直接的可比性。</span><br><span class="line">React的官方博客中明确阐述了React不是一个MVC框架，</span><br><span class="line">而是一个用于构建组件化UI的库，是一个前端界面开发工具。所以顶多算是MVC中的V（view）。</span><br></pre></td></tr></table></figure>

# react 数据流

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">React遵循从上到下的数据流向，即单向数据流。</span><br><span class="line"></span><br><span class="line">单向数据流并非‘单向绑定’，甚至单向数据流与绑定没有‘任何关系’。</span><br><span class="line">对于React来说，单向数据流（从上到下）与单一数据源这两个原则，</span><br><span class="line"></span><br><span class="line">限定了React中要想在一个组件中更新另一个组件的状态（类似于Vue的平行组件传参，或者是子组件向父组件传递参数）</span><br><span class="line">，需要进行状态提升。即将状态提升到他们最近的祖先组件中。</span><br><span class="line"></span><br><span class="line">子组件中Change了状态，触发父组件状态的变更，父组件状态的变更，</span><br><span class="line">影响到了另一个组件的显示（因为传递给另一个组件的状态变化了，这一点与Vue子组件的$emit()方法很相似）。</span><br></pre></td></tr></table></figure>

# react 数据一定要在 DidMount 里获取更新的原因

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount方法中的代码，是在组件已经完全挂载到网页上才会调用被执行，所以可以保证数据的加载。</span><br><span class="line">在这方法中调用setState方法，会触发重渲染。这个方法就是用来加载外部数据用的，或处理其他的副作用代码。</span><br><span class="line"></span><br><span class="line">constructor()</span><br><span class="line">	constructor()中获取数据的话，如果时间太长，或者出错，组件就渲染不出来，整个页面都没法渲染了。</span><br><span class="line">	constructor是作组件state初绐化工作，并不是设计来作加载数据的。</span><br><span class="line"></span><br><span class="line">componentWillMount()</span><br><span class="line">	如果使用SSR（服务端渲染）,componentWillMount会执行2次，一次在服务端，一次在客户端。</span><br><span class="line">	而componentDidMount不会。</span><br><span class="line"></span><br><span class="line">	constructor可以完成state初始化，componentWillMount使用的很少，目前16版本加入了UNSAFE来标识		componentWillMount，新的生命周期static getDerivedStateFromProps() 也会替代这个。</span><br><span class="line"></span><br><span class="line">	React16之后采用了Fiber架构，只有componentDidMount声明周期函数是确定被执行一次的，</span><br><span class="line">	类似ComponentWillMount的生命周期钩子都有可能执行多次，</span><br><span class="line">	所以不加以在这些生命周期中做有副作用的操作，比如请求数据之类。</span><br><span class="line"></span><br><span class="line">render()</span><br><span class="line">	无限render</span><br><span class="line"></span><br><span class="line">componentDidMount()</span><br><span class="line">	确保已经render过一次。提醒我们正确地设置初始状态，这样就不会得到导致错误的&quot;undefined&quot;状态。</span><br></pre></td></tr></table></figure>

# react 中的受控组件和非受控组件

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">受控组件 input 本身</span><br><span class="line">	HTML中的表单元素是可输入的，也就是有自己的可变状态</span><br><span class="line">	而React中可变状态通常保存在state中，并且只能通过setState()方法来修改</span><br><span class="line">	React讲state与表单元素值value绑定在一起，有state的值来控制表单元素的值</span><br><span class="line">	简单来说，值受到react控制的表单元素</span><br><span class="line"></span><br><span class="line">非受控组件</span><br><span class="line">	调用 React.createRef() 方法创建ref对象</span><br><span class="line">	将创建好的 ref 对象添加到文本框中</span><br><span class="line">	通过ref对象获取到文本框的值</span><br><span class="line">	简单来说，表单组件没有value prop就可以称为非受控组件</span><br></pre></td></tr></table></figure>

# react 中的 ref 的 3 种方式

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">方式1: string类型绑定</span><br><span class="line">类似于vue中的ref绑定方式，可以通过this.refs.绑定的ref的名字获取到节点dom</span><br><span class="line">注意的是 这种方式已经不被最新版的react推荐使用，有可能会在未来版本中遗弃</span><br><span class="line"></span><br><span class="line">方式2: react.CreateRef()</span><br><span class="line">通过在class中使用React.createRef()方法创建一些变量，可以将这些变量绑定到标签的ref中</span><br><span class="line">那么该变量的current则指向绑定的标签dom</span><br><span class="line"></span><br><span class="line">方式3: 函数形式</span><br><span class="line">在class中声明函数，在函数中绑定ref</span><br><span class="line">使用这种方法可以将子组件暴露给父组件以使得父组件能够调用子组件的方法</span><br><span class="line">通过函数的方法绑定ref可以将整个子组件暴露给父组件</span><br><span class="line"></span><br><span class="line">当在子组件中调用onRef函数时，正在调用从父组件传递的函数。this.props.onRef（this）这里的参数指向子组件本身，父组件接收该引用作为第一个参数：onRef = &#123;ref =&gt;（this.child = ref）&#125;然后它使用this.child保存引用。之后，可以在父组件内访问整个子组件实例，并且可以调用子组件函数。</span><br></pre></td></tr></table></figure>

# react 中的 static(静态方法)

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">静态方法和 React 没有直接关系，React 的组件都是继承自 React.Component 这个类，静态方法属于类本身。</span><br><span class="line"></span><br><span class="line">static并不是react定义的，而加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用。</span><br><span class="line"></span><br><span class="line">这里涉及到了ES6的class，我们定义一个组件的时候通常是定义了一个类，</span><br><span class="line">而static则是创建了一个属于这个类的属性或者方法。</span><br><span class="line">组件则是这个类的一个实例，component的props和state是属于这个实例的，</span><br></pre></td></tr></table></figure>

# react 的 props 与 state 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">props:</span><br><span class="line">一般用于父组件向子组件通信，在组件之间通信使用。</span><br><span class="line">state:</span><br><span class="line">一般用于组件内部的状态维护，更新组建内部的数据，状态，更新子组件的props等。</span><br></pre></td></tr></table></figure>

# 混合开发

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">1. 混合开发是介于webapp和原生app之间的一种应用，它同时具有webapp可以跨平台的特性，也具备原生app可以进行安装使用的特性</span><br><span class="line">2. webApp</span><br><span class="line">   1. 优点： 跨平台 、 维护更新、项目迭代快</span><br><span class="line">   2. 缺点： 交互体验不好 、进入应用的方式麻烦</span><br><span class="line">3. 原生app</span><br><span class="line">   1.案例： 美团、饿了吗、微信、QQ</span><br><span class="line">   2.安装在手机中使用的</span><br><span class="line">   3.优点： 手机安装、交互体验好</span><br><span class="line">   4.缺点： 维护更新、项目迭代很慢、成本太高了</span><br><span class="line">4. 混合开发： 择中方案</span><br><span class="line">   跨平台</span><br><span class="line">   维护更新快   成本低</span><br><span class="line">   手机安装，交互体验好</span><br><span class="line"></span><br><span class="line">为什么混合开发会兴起呢？</span><br><span class="line">1. 混合开发的兴起是偶然的</span><br><span class="line"></span><br><span class="line">混合开发方式</span><br><span class="line">1. h5 主导</span><br><span class="line">   - 开发思维： H5【 vue/ react/ angular 】 + 第三方可以访问原生设备的库</span><br><span class="line">     - 微信公众号： h5网页 + 微信JSSDK</span><br><span class="line">   - 历史</span><br><span class="line">      1. PhoneGap + cordva.js 淘汰</span><br><span class="line">      2. vue/react/angular + ioinc.js</span><br><span class="line">      3. vue - uni-app</span><br><span class="line">      4. h5 + h5plus.js   h5 + h5+</span><br><span class="line">      5. 微信公众号： webapp + js-jdk</span><br><span class="line">      6. vue/react + weex.js[ 阿里内部 ]</span><br><span class="line">2. React Native</span><br><span class="line">   1. facebook 团队项目  16 - 18年很热火，18年后半年开始热度下降，</span><br><span class="line">   	  facebook觉得这个框架对于开发者而言开发难度太大，维护成本也高，Facebook决定不再更新它了、</span><br><span class="line">   2. 典型应用： 饿了吗</span><br><span class="line">   3. React Native开发出来项目 - 原生app</span><br><span class="line">   4. React Native  = React + 原生js</span><br><span class="line">   5. 构建React Native项目 - 脚手架</span><br><span class="line">      1. 构建项目环境: create-react-native-app</span><br><span class="line">      2. 手机调试：expo  expo-cli</span><br><span class="line">      3. 目录解释</span><br><span class="line">         1. __test__   expo手机调试的测试文件夹，不用管</span><br><span class="line">         2. .expo  临时文件，运行项目</span><br><span class="line">         3. .expo-shared 分享</span><br><span class="line">         4. assets 静态资源</span><br><span class="line">         5. components  公共组件</span><br><span class="line">         6. constants  项目公用的常量</span><br><span class="line">         7. navigation  底部tabbar栏组件</span><br><span class="line">         8. node_modules  依赖包</span><br><span class="line">         9. screens   页面</span><br></pre></td></tr></table></figure>

# 小程序

对于路由的触发方式以及页面生命周期函数如下:

| 路由方式   | 触发时机                                                                                                                                                          | 路由前页面 | 路由后页面         |
| ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- | ------------------ |
| 初始化     | 小程序打开的第一个页面                                                                                                                                            |            | onLoad, onSHow     |
| 打开新页面 | 调用 API wx.navigateTo 或使用组件 &lt;navigator open-type=&quot;navigateTo&quot;/&gt;                                                                                             | onHide     | onLoad, onShow     |
| 页面重定向 | 调用 API wx.redirectTo 或使用组件 &lt;navigator open-type=&quot;redirectTo&quot;/&gt;                                                                                             | onUnload   | onLoad, onShow     |
| 页面返回   | 调用 API wx.navigateBack 或使用组件&lt;navigator open-type=&quot;navigateBack&quot;&gt;或用户按左上角返回按钮                                                                     | onUnload   | onShow             |
| Tab 切换   | 调用 API wx.navigateBack 或使用组件&lt;navigator open-type=&quot;navigateBack&quot;&gt;或用户按调用 API wx.switchTab 或使用组件 &lt;navigator open-type=&quot;switchTab&quot;/&gt; 或用户切换 Tab |            | 各种情况请参考下表 |
| 重启动     | 调用 API wx.reLaunch 或使用组件 &lt;navigator open-type=&quot;reLaunch&quot;/&gt;                                                                                                 | onUnload   | onLoad, onShow     |

页面跳转触发的生命周期，其实还是存在问题的，并非官方所说的那样。

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SwitchTab的跳转BUG</span><br><span class="line">首页跳转到子页面后，在子页面上使用：</span><br><span class="line">&lt;navigator type=<span class="string">&#x27;switchTab&#x27;</span> url=<span class="string">&quot;/pages/index/index&quot;</span> &gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">view</span>&gt;</span>跳转首页<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/navigator&gt;</span><br><span class="line">这种方式有问题，解决的办法是通过JS来实现跳转，代码如下：</span><br><span class="line">&lt;view <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;weui-btn-area&quot;</span>&gt;</span><br><span class="line">             <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;weui-btn&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;backIndex&quot;</span> <span class="attr">type</span>=<span class="string">&quot;default&quot;</span>&gt;</span>返回主页<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">            &lt;/view&gt;</span><br><span class="line">跳转成功后，重新调用onload方法，JS代码如下：</span><br><span class="line"><span class="attr">backIndex</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    wx.switchTab(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;/pages/index/index&#x27;</span>,</span><br><span class="line">      <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> page = getCurrentPages().pop();</span><br><span class="line">        <span class="keyword">if</span> (page == <span class="literal">undefined</span> || page == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        page.onLoad();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

# react 父组件通过 ref 获取不到子组件的解决方案

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在子组件中</span><br><span class="line">this.customfunction = this.customfunction.bind(this);</span><br><span class="line">即可</span><br></pre></td></tr></table></figure>

# React PureComponent 和 Component 区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">	React.PureComponent 与 React.Component 几乎完全相同，但 React.PureComponent 通过prop和state的浅对比来实现 shouldComponentUpate()。</span><br><span class="line">　　如果React组件的 render() 函数在给定相同的props和state下渲染为相同的结果，在某些场景下你可以使用 React.PureComponent 来提升性能。</span><br><span class="line">　　React.PureComponent 的 shouldComponentUpdate() 只会对对象进行浅对比。如果对象包含复杂的数据结构，它可能会因深层的数据不一致而产生错误的否定判断(表现为对象深层的数据已改变视图却没有更新, 原文：false-negatives)。当你期望只拥有简单的props和state时，才去继承 PureComponent ，或者在你知道深层的数据结构已经发生改变时使用 forceUpate() 。或者，考虑使用 不可变对象 来促进嵌套数据的快速比较。</span><br><span class="line">　　此外,React.PureComponent 的 shouldComponentUpate() 会忽略整个组件的子级。请确保所有的子级组件也是”Pure”的。</span><br><span class="line">　　</span><br><span class="line">PureComponent的作用：</span><br><span class="line">	PureComponent 其实是在内部帮我们简单实现了一下shouldComponentUpdate的功能，以便提供组件的性能；这里的简单指是：对prop和state做浅比较，若浅比较结果相同，则该组件以及其子组件不做render；否则，render。</span><br><span class="line"></span><br><span class="line">使用PureComponent注意事项：</span><br><span class="line">	PureComponent主要针对prop和state为基本数据类型，如bool、string、number；</span><br><span class="line">	对于数组和对象等引用类型，则要引用不同，才会渲染；如果引用相同，则PureComponent浅比较返回结果相同，不做render；</span><br><span class="line">	PureComponent 中不建议再另外重写shouldComponentUpdate方法，否则会报warning信息：</span><br><span class="line">	PureComponent的最好作为展示组件，如果prop和state每次都会变，PureComponent做浅比较也会影响性能，可以考虑直接用Component；</span><br><span class="line">	对于prop和state数据结构比较复杂的情况，可以考虑自己重写shouldComponentUpdate方法来做优化；</span><br></pre></td></tr></table></figure>

# react 中调用 setState 之后发生

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">React会将当前传入的参数对象与组件当前的状态合并,然后触发调和过程,在调和的过程中,React会以相对高效的方式根据新的状态构建React元素树并且重新渲染整个UI界面.</span><br><span class="line"></span><br><span class="line">React得到的元素树之后,React会自动计算出新的树与老的树的节点的差异,然后根据差异对界面进行最小化的渲染,在React的差异算法中,React能够精确的知道在哪些位置发生看改变以及应该如何去改变,这样就保证了UI是按需更新的而不是重新渲染整个界面</span><br></pre></td></tr></table></figure>

# SPA 和 MPA 的异同

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">单页应用（SinglePage Application，SPA）</span><br><span class="line">	指只有一个主页面的应用，一开始只需加载一次 js,css 等相关资源。所有的内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅刷新局部资源。</span><br><span class="line"></span><br><span class="line">多页应用（MultiPage Application，MPA）</span><br><span class="line">	指有多个独立的页面的应用，每个页面必须重复加载 js,css 等相关资源。多页应用跳转，需要整页资源刷新。</span><br><span class="line"></span><br><span class="line">两者对比表格：</span><br><span class="line"> 	                    SPA	   |||     MPA</span><br><span class="line">结构:一个主页面 + 许多模块的组件	  |||   许多完整的页面</span><br><span class="line">体验:页面切换快，体验佳；当初次加载文件过多时，需要做相关的调优。 |||	页面切换慢，网速慢的时候，体验尤其不好</span><br><span class="line">资源文件:组件公用的资源只需要加载一次 |||	每个页面都要自己加载公用的资源</span><br><span class="line">适用场景:对体验度和流畅度有较高要求的应用，不利于 SEO（可借助 SSR 优化 SEO）  |||	适用于对 SEO 要求较高的应用</span><br><span class="line">过渡动画:Vue 提供了 transition 的封装组件，容易实现	|||	很难实现</span><br><span class="line">内容更新:相关组件的切换，即局部更新	|||	整体 HTML 的切换，费钱（重复 HTTP 请求）</span><br><span class="line">路由模式:可以使用 hash ，也可以使用 history  |||	普通链接跳转</span><br><span class="line">数据传递:因为单页面，使用全局变量就好（Vuex）  |||	cookie 、localStorage 等缓存方案，URL 参数，调用接口保存等</span><br><span class="line">相关成本:前期开发成本较高，后期维护较为容易	|||	前期开发成本低，后期维护就比较麻烦，因为可能一个功能需要改很多地方</span><br><span class="line"></span><br><span class="line">单页应用实现核心：前端路由</span><br><span class="line">前端路由的核心：改变视图的同时不会向后端发出请求。</span><br></pre></td></tr></table></figure>

# TS

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TS好处：</span><br><span class="line">1、强类型</span><br><span class="line">2、不需要去浏览器中浏览效果，就能知道编译错误</span><br><span class="line">   静态类型检查可以做到early fail，即你编写的代码即使没有被执行到，一旦你编写代码时发生类型不匹配，</span><br><span class="line">   语言在编译阶段（解释执行也一样，可以在运行前）即可发现</span><br><span class="line">4、类型就是最好的注释，看类型我们就知道这个是什么</span><br><span class="line">3、即使ts中有编译报错，tsc依旧可以将其编译成js</span><br><span class="line"></span><br><span class="line">学习TS的基本数据类型</span><br><span class="line">定类型是为了安全，规矩多就安全</span><br><span class="line">1、基础数据类型 ：number \string\boolean\null\undefined</span><br><span class="line">	any 表示任意类型 void 表示空类型，空类型是针对函数的，表示函数没有返回值。返回空</span><br><span class="line">2、内置对象类型 ： Array \  Boolean \  HTMLElement</span><br><span class="line">3、自定义类型 : 接口  类  泛型  枚举类型</span><br></pre></td></tr></table></figure>

# TS 中 interface 和 type 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在ts中，定义类型由两种方式：接口（interface）和类型别名（type alias）</span><br><span class="line">interface只能定义对象类型，</span><br><span class="line">type声明的方式可以定义组合类型，交叉类型和原始类型</span><br><span class="line"></span><br><span class="line">如果用type alias 声明的方式，会导致一些功能的缺失</span><br><span class="line"> 	1.interface方式可以实现接口的extends/implements，而type 不行</span><br><span class="line">	2.interface可以实现接口的merge，但是type不行</span><br></pre></td></tr></table></figure>

# Webpack

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">webpack打包react  vue,与自己的源代码分离使用splitchunks</span><br><span class="line">webpack热更新:不用刷新浏览器而将新变更的模块替换掉旧的模块。</span><br><span class="line"></span><br><span class="line">webpack会分析每个入口文件，解析包依赖关系的各个文件，每个模块都打包到bundle.js。webpack给每个模块分配一个唯一的ID并通过这个ID索引和访问模块。页面运行时，先启动entry.js，其他模块会在运行require时候执行。</span><br><span class="line"></span><br><span class="line">1.Webpack  Loader   Plugin</span><br><span class="line"></span><br><span class="line">（loader ，plugin分别什么作用，哪个配置可以把依赖包抽离出来，不打包进去）</span><br><span class="line">【Loader】：用于对模块源码的转换，loader描述了webpack如何处理非javascript模块，并且在buld中引入这些依赖。loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，或者将内联图像转换为data URL。比如说：CSS-Loader，Style-Loader等。babel-loader优雅降级配置ES高版本转成低版本</span><br><span class="line"></span><br><span class="line">【Plugin】：是用于在webpack打包编译过程里，在对应的事件节点里执行自定义操作，比如资源管理、bundle文件优化等操作,</span><br><span class="line"></span><br><span class="line">依赖包抽离  const ExtractTextWebapckPlugin= require(&quot;extract-text-webpack-plugin&quot;)    module    exclude node_modules</span><br><span class="line"></span><br><span class="line">排除excloude排除node_modules</span><br><span class="line"></span><br><span class="line">loader的使用很简单：</span><br><span class="line"></span><br><span class="line">在webpack.config.js中指定loader。module.rules可以指定多个loader，对项目中的各个loader有个全局概览。</span><br><span class="line"></span><br><span class="line">loader是运行在NodeJS中，可以用options对象进行配置。plugin可以为loader带来更多特性。loader可以进行压缩，打包，语言翻译等等。</span><br><span class="line"></span><br><span class="line">loader从模板路径解析，npm install node_modules。也可以自定义loader，命名XXX-loader。</span><br><span class="line"></span><br><span class="line">语言类的处理器loader：CoffeeScript，TypeScript，ESNext（Bable）,Sass,Less,Stylus。任何开发技术栈都可以使用webpack。</span><br><span class="line"></span><br><span class="line">webpack常用的loader</span><br><span class="line"></span><br><span class="line">样式：style-loader、css-loader、less-loader、sass-loader等</span><br><span class="line">文件：raw-loader、file-loader 、url-loader等</span><br><span class="line">编译：babel-loader、coffee-loader 、ts-loader等</span><br><span class="line">校验测试：mocha-loader、jshint-loader 、eslint-loader等</span><br><span class="line"></span><br><span class="line">目的在于解决loader无法实现的其他事，从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。</span><br><span class="line"></span><br><span class="line">webpack功能强大，难点在于它的配置文件，webpack4默认不需要配置文件，可以通过mode选项为webpack指定了一些默认的配置，mode分为：development/production，默认是production。</span><br><span class="line"></span><br><span class="line">插件可以携带参数，所以在plugins属性传入new实例。</span><br><span class="line"></span><br><span class="line">webpack常用的plugin</span><br><span class="line">webpack内置UglifyJsPlugin，压缩和混淆代码。</span><br><span class="line">webpack内置CommonsChunkPlugin，提高打包效率，将第三方库和业务代码分开打包。</span><br><span class="line">ProvidePlugin：自动加载模块，代替require和import</span><br><span class="line"></span><br><span class="line">html-webpack-plugin可以根据模板自动生成html代码，并自动引用css和js文件extract-text-webpack-plugin 将js文件中引用的样式单独抽离成css文件</span><br><span class="line"></span><br><span class="line">DefinePlugin 编译时配置全局变量，这对开发模式和发布模式的构建允许不同的行为非常有用。</span><br><span class="line"></span><br><span class="line">【Mode】可以在config文件里面配置，也可以在CLI参数中配置：webpack--mode=production（一般会选择在CLI，也就是npm scripts里面进行配置）。</span><br><span class="line"></span><br><span class="line">在webpack4以下版本，webpack3.XX，通过plugins进行环境变量的配置。</span><br><span class="line"></span><br><span class="line">【resolve】模块，resolver是个库，帮助webpack找到bundle需要引入的模块代码，打包时，webpack使用enhanced-resolve来解析路径。</span><br><span class="line"></span><br><span class="line">2.webpack优化</span><br><span class="line">多进程打包   安装插件thread-loader   parallel-webpack   HappyPack</span><br><span class="line"></span><br><span class="line">多进程压缩   parallel-uglify-plugin    terser-webpack-plugin</span><br><span class="line">资源CDN    公用代码提取，使用 CDN 加载</span><br><span class="line">动态polyfill     动态 polyfill 指的是根据不同的浏览器，动态载入需要的 polyfill</span><br></pre></td></tr></table></figure>

# flex 布局

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">flex是由 flex-grow:1父容器在主轴上还有多少剩余空间，</span><br><span class="line"></span><br><span class="line">flex-shrink当父元素的宽度大于所有子元素的宽度的和时（即父元素会有剩余空间），</span><br><span class="line">子元素如何分配父元素的剩余空间</span><br><span class="line"></span><br><span class="line">flex-basis基准值组成</span><br><span class="line"></span><br><span class="line">flex 怎么实现1个盒子垂直居中	如何实现四个盒子水平均匀分布</span><br><span class="line"></span><br><span class="line">父容器 display:flex; justify-content: center; align-items: center;</span><br><span class="line"></span><br><span class="line">display: flex; justify-content:space-evenly; align-items: center;</span><br></pre></td></tr></table></figure>

# 实现导航的吸顶效果

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设置css:fixed固定定位</span><br><span class="line"></span><br><span class="line">判断滚动条滚动的距离大于导航条距顶部的距离,来判断是否实现吸顶,然后addClass添加样式</span><br></pre></td></tr></table></figure>

# less 的 hover 简写

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a&#123;</span><br><span class="line">	&amp;:hover &#123;&#125; //这里&amp;代表它的上一级就是a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

# CSS 伪类 ::after,before 的应用场景

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">::before和::after必须配合content属性来使用，</span><br><span class="line">content用来定义插入的内容，content必须有值，至少是空。</span><br><span class="line">默认情况下，伪类元素的display是默认值inline，可以通过设置display:block来改变其显示。</span><br><span class="line"></span><br><span class="line">1.清除浮动:</span><br><span class="line">在浮动元素后面添加一个空的Div标签，然后在设置它的清除浮动要是，使用after伪元素</span><br><span class="line"></span><br><span class="line">2.常见消息框 :</span><br><span class="line">伪类content:&#x27; &#x27;  伪类4条边必须宽度相同，而且其他三条边为transparent</span><br><span class="line">可以通过设置定位元素left,top值为50%,translate(-50%,-50%) 来使任意宽高的元素居中。</span><br><span class="line"></span><br><span class="line">div::before&#123;</span><br><span class="line">          content:&#x27; &#x27;;</span><br><span class="line"></span><br><span class="line">3.阴影 : 通过设置before，after不同位置，不同旋转角度,要保证伪类的颜色及z-index</span><br><span class="line"></span><br><span class="line">div.outer::before,div.outer::after&#123;content:&#x27;&#x27;;</span><br><span class="line">            z-index:1;</span><br><span class="line">            width:50%;</span><br><span class="line">            height:3px;</span><br><span class="line">            position:absolute;</span><br><span class="line">            left:10px;</span><br><span class="line">            bottom:7px;</span><br><span class="line">            background-color:transparent;</span><br><span class="line">            box-shadow:5px 5px 10px rgba(0,0,0,0.5);</span><br><span class="line">            -webkit-transform:rotate(-3deg);</span><br><span class="line"></span><br><span class="line">4.做出各种图形效果</span><br><span class="line"></span><br><span class="line">#star-five:before &#123;</span><br><span class="line">            border-bottom: 80px solid red;</span><br><span class="line">            border-left: 30px solid transparent;</span><br><span class="line">            border-right: 30px solid transparent;</span><br><span class="line">            position: absolute;</span><br><span class="line">            height: 0;</span><br><span class="line">            width: 0;</span><br><span class="line">            top: -45px;</span><br><span class="line">            left: -65px;</span><br><span class="line">            content: &#x27;&#x27;;</span><br><span class="line">            transform: rotate(-35deg);</span><br><span class="line">        &#125;</span><br><span class="line">        #star-five:after &#123;</span><br><span class="line">            width: 0;</span><br><span class="line">            height: 0;</span><br><span class="line">            border-left: 100px solid transparent;</span><br><span class="line">            border-right: 100px solid transparent;</span><br><span class="line">            border-bottom: 70px solid yellow;</span><br><span class="line">            top: 7px;</span><br><span class="line">            left: -110px;</span><br><span class="line">            position: absolute;</span><br><span class="line">            display: block;</span><br><span class="line">            content: &#x27;&#x27;;</span><br><span class="line">            transform: rotate(-70deg);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

# CSS 权重的计算

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">权重叠加 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0,1,0，所以不会存在10个div能赶上一个类选择器的情况</span><br><span class="line"></span><br><span class="line">继承的权重是0</span><br><span class="line">1)如果选中了，那么以上面的公式来计权重。谁大听谁的。</span><br><span class="line">2)如果没有选中，那么权重是0，因为继承的权重为0</span><br><span class="line"></span><br><span class="line">当选择器冲突时，权重高的生效；当权重相同时，写在后头的会把前面的覆盖。</span><br></pre></td></tr></table></figure>

# http

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">http2.0，https连接，</span><br><span class="line"></span><br><span class="line">http概述:超文本传输协议,是互联网上应用最为广泛的一种网络协议</span><br><span class="line"></span><br><span class="line">http的缺点</span><br><span class="line">1.通信使用明文可能会被窃听。</span><br><span class="line">2.不验证通信方的身份可能遭遇伪装。</span><br><span class="line">3.无法证明报文的完整性，可能已遭篡改。</span><br><span class="line"></span><br><span class="line">https就是在安全的传输层上发送的http。它在将http报文发送给TCP之前，先将其发送给了一个安全层 ，对其进行加密。http安全层是通过ssl及其现代替代协议TSL来实现的。</span><br><span class="line"></span><br><span class="line">https的优点</span><br><span class="line">（1）使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</span><br><span class="line">（2）HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</span><br><span class="line"></span><br><span class="line">https的缺点</span><br><span class="line">但是https因为加了层ssl，所以在效率方面比较低，会使页面加载的时长延长近50%,也会增加10-20%的耗电。</span><br><span class="line">需要安装证书，在一定基础上增加部署费用，并且报文加密解密对数据传递有一点的效率影响。</span><br><span class="line"></span><br><span class="line">http/2.0的目标是改善用户加载页面的时候更快</span><br><span class="line">HTTP/2采用二进制格式而非文本格式</span><br><span class="line">HTTP/2是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行</span><br></pre></td></tr></table></figure>

# http 对称加密非对称加密

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对称密钥加密是指加密和解密使用同一个密钥的方式,一方通过密钥将信息加密后，把密文传给另一方，另一方通过这个相同的密钥将密文解密，转换成可以理解的明文</span><br><span class="line"></span><br><span class="line">非对称加密是加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。</span><br></pre></td></tr></table></figure>

# WebSocket 和 http 有什么区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">socket是传输控制层协议，webSocket是应用层协议</span><br><span class="line"></span><br><span class="line">WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信(full-duplex)。</span><br><span class="line">一开始的握手需要借助HTTP请求完成。</span><br><span class="line"></span><br><span class="line">HTTP请求缺点：</span><br><span class="line">会导致过多不必要的请求，浪费流量和服务器资源，每一次请求、应答，都浪费了一定流量在相同的头部信息上</span><br><span class="line"></span><br><span class="line">然而WebSocket的出现可以弥补这一缺点。</span><br><span class="line">在WebSocket中，只需要服务器和浏览器通过HTTP协议进行一个握	手的动作，然后单独建立一条TCP的通信通道进行数据的传送。</span><br><span class="line"></span><br><span class="line">原理:(webSocket)</span><br><span class="line">WebSocket同HTTP一样也是应用层的协议，但是它是一种双向通信协议，是建立在TCP之上的。</span><br><span class="line"></span><br><span class="line">1. 浏览器、服务器建立TCP连接，三次握手。这是通信的基础，传输控制层，若失败后续都不执行。</span><br><span class="line">2. TCP连接成功后，浏览器通过HTTP协议向服务器传送WebSocket支持的版本号等信息。（开始前的HTTP握手）</span><br><span class="line">3. 服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据。</span><br><span class="line">4. 当收到了连接成功的消息后，通过TCP通道进行传输通信。</span><br><span class="line"></span><br><span class="line">WebSocket与HTTP的关系</span><br><span class="line">相同点:</span><br><span class="line">都是一样基于TCP的，都是可靠性传输协议。</span><br><span class="line">都是应用层协议</span><br><span class="line"></span><br><span class="line">不同点:</span><br><span class="line">WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息。HTTP是单向的。</span><br><span class="line">WebSocket是需要握手进行建立连接的。</span><br></pre></td></tr></table></figure>

# 错误调试工具

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F12    断点   错误附近输出打印    火狐中的firebug    IE开发者工具   Emmet</span><br></pre></td></tr></table></figure>

# HTTP 和 HTTPS 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP是超文本传输协议，信息是明文传输的，HTTPS是具有ssl/tls加密传输协议。</span><br><span class="line"></span><br><span class="line">默认端口不同，前者是80，后者是443。</span><br><span class="line"></span><br><span class="line">HTTPS比HTTP安全</span><br><span class="line"></span><br><span class="line">HTTPS协议需要到CA申请证书，需要一定费用</span><br></pre></td></tr></table></figure>

# SSL/TLS 介绍

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SSL 是安全套接层(secure sockets layer)，叫传输层安全)。说白点，</span><br><span class="line">就是在明文的上层和 TCP 层之间加上一层加密，这样就保证上层信息传输的安全。如HTTP 协议是明文传输，加上 SSL 层之后，就有了雅称 HTTPS。它存在的唯一目的就是保证上层通讯安全的一套机制。它的发展依次经历了下面几个时期，像手机软件升级一样，每次更新都添加或去除功能，比如引进新的加密算法，修改握手方式等。</span><br><span class="line"></span><br><span class="line">SSL1<span class="number">.0</span>: 已废除</span><br><span class="line">SSL2<span class="number">.0</span>: RFC6176, 已废除</span><br><span class="line">SSL3<span class="number">.0</span>: RFC6101, 基本废除</span><br><span class="line">TLS1<span class="number">.0</span>: RFC2246, 少数古董服务器仍在使用</span><br><span class="line">TLS1<span class="number">.1</span>: RFC4346</span><br><span class="line">TLS1<span class="number">.2</span>: RFC5246, 目前已广泛使用</span><br><span class="line">TLS1<span class="number">.3</span>: IETF正在酝酿中</span><br><span class="line"></span><br></pre></td></tr></table></figure>

## SPA SEO SSR 三者有什么区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">SPA通俗的说就是单页面应用（single page application）</span><br><span class="line">优点</span><br><span class="line">页面之间的切换非常快</span><br><span class="line">一定程度减少了后端服务器的压力</span><br><span class="line">后端程序只需要提供api，不需要客户端到底是web端还是手机等</span><br><span class="line"></span><br><span class="line">缺点</span><br><span class="line">首屏打开速度很慢，因为用户首次加载需要先下载SPA框架及应用程序的代码，然后再渲染页面。</span><br><span class="line">不利于SEO搜索引擎优化</span><br><span class="line">1. 全称 Single Page Application  单页面应用</span><br><span class="line">2. 什么是SPA</span><br><span class="line">   - SPA指的是一个网站只有一个页面，也就是只有1个html文件</span><br><span class="line">3. 为什么前端现在流行使用SPA?</span><br><span class="line">   - SPA好处</span><br><span class="line">     - 可以较少html文件之间的切换时间</span><br><span class="line">     - 多个html切换时，会产生白屏，这个白屏给用户体验不好，而SPA就一个页面，所以白屏我们可以用loading、骨架屏技术来处理</span><br><span class="line">4. SPA实现要求？</span><br><span class="line">   - 前端路由实现</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SEO通俗的说就是搜索引擎优化(search engine optimization)</span><br><span class="line">SEO是一种通过了解搜索引擎的运作规则（如何抓取网站页面，如何索引以及如何根据特定的关键字展现搜索结果排序等）来调整网站，以提高该网站在搜索引擎中某些关键词的搜索结果排名。</span><br><span class="line"></span><br><span class="line">我们之前说SPA单页面应用，通过AJAX获取数据，这就难保证我们的页面能被搜索引擎正常收到，并且有一些搜索引擎不支持执行js和通过ajax获取数据，那就更不用提SEO了。为了解决这个问题，，SSR登场了</span><br><span class="line">SSR通俗的说就是服务器端渲染(server side rendering)</span><br><span class="line">优点</span><br><span class="line">更快的响应时间，不用等待所有的js都下载完成，浏览器变成显示比较完整的页面</span><br><span class="line">更好的SSR，我们可以将SEO的关键信息直接在后台就渲染成html，从而保证搜索引擎的爬虫都能爬取到关键数据</span><br><span class="line"></span><br><span class="line">缺点</span><br><span class="line">占用更多的cpu和内存资源</span><br><span class="line">一些常用的浏览器的api可能无法正常使用，比如window，document，alert等，如果使用的话需要对运行环境加以判断</span><br><span class="line">开发调试会有一些麻烦，因为涉及到了浏览器及服务器，对于SPA的一些组件的声明周期的管理会变得复杂</span><br><span class="line">可能会由于某些因素导致服务器渲染的结果与浏览器端的结果不一致。</span><br><span class="line"></span><br><span class="line">前后端分离的概念</span><br><span class="line">传统的web前后端开发大多是前端将页面写好，让后端将页面集成到项目中，这里就存着一个前后端耦合的问题，首先对于后端来说，不仅要写后端逻辑，还得要集成前端页面。对于前端来说，也不是很轻松就能看到页面的真正渲染出来的样子，这样 肯定是不利于开发调试的，效率自然也就成了问题。针对上述问题，前后端分离的思想应运而生。</span><br><span class="line"></span><br><span class="line">基本概念</span><br><span class="line">前后端根据AJAX接口进行数据的交互，目前常见的是后端直接将数据已JSON的格式返回给前端，前端根据后端服务器返回的数据，操作DOM。</span><br><span class="line"></span><br><span class="line">主要优点</span><br><span class="line">分工明确，前后端各司其职，后端专注业务逻辑和功能的实现，前端专注页面实现和渲染。</span><br><span class="line">接口明确，并行开发。在后端接口没有实现好之前，前端可以自己模拟接口提供测试数据。</span><br><span class="line">提高开发效率，一定程度上减少了前后端的沟通成本</span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">前后端分离降低了前端和都端的耦合度，提高了开发效率；</span><br><span class="line">SPA是前后端分离中前端的一种解决方案；</span><br><span class="line">SEO对于跟多网站很重要而普通的SPA又不利于SEO；</span><br><span class="line">SSR的出现一定成都上解决了SPA首屏慢的问题，又极大减少了普通SPA对于SEO的不利影响。</span><br></pre></td></tr></table></figure>

# 浏览器的缓存机制

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">什么是浏览器缓存</span><br><span class="line">	Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个URL地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。浏览器和网站服务器是根据缓存机制进行缓存的</span><br><span class="line"></span><br><span class="line">非HTTP协议定义的缓存机制</span><br><span class="line">	浏览器缓存机制，其实主要就是HTTP协议定义的缓存机制（如： Expires； Cache-control等）。但是也有非HTTP协议定义的缓存机制，如使用HTML Meta 标签，Web开发者可以在HTML页面的&lt;head&gt;节点中加入&lt;meta&gt;标签</span><br><span class="line"></span><br><span class="line">	&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt;</span><br><span class="line">	上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。使用上很简单，但只有部分浏览器可以支持，而且所有缓存代理服务器都不支持，因为代理不解析HTML内容本身。</span><br><span class="line"></span><br><span class="line">浏览器在第一次请求发生后，再次请求时：</span><br><span class="line">	浏览器会先获取该资源缓存的header信息，根据其中的expires和cache-control判断是否命中强缓存），若命中则直接从缓存中获取资源，包括缓存的header信息，本次请求不会与服务器进行通信；</span><br><span class="line">	如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/IF-Modified-Since、Etag/IF-None-Match）,由服务器根据请求中的相关header信息来对比结果是否命中协商缓存，若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容</span><br></pre></td></tr></table></figure>

# 浏览器的强缓存和协商缓存

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">这里说的缓存是指浏览器（客户端）在本地磁盘中对访问过的资源保存的副本文件。</span><br><span class="line"></span><br><span class="line">浏览器缓存主要有以下几个优点：</span><br><span class="line">1. 减少重复数据请求，避免通过网络再次加载资源，节省流量。</span><br><span class="line">2. 降低服务器的压力，提升网站性能。</span><br><span class="line">3. 加快客户端加载网页的速度，提升用户体验。</span><br><span class="line"></span><br><span class="line">浏览器缓存分为强缓存和协商缓存，两者有两个比较明显的区别：</span><br><span class="line">1. 如果浏览器命中强缓存，则不需要给服务器发请求；而协商缓存最终由服务器来决定是否使用缓存，即客户端与服务器之间存在一次通信。</span><br><span class="line">2. 在chrome中强缓存（虽然没有发出真实的http请求）的请求状态码返回是200(from cache)；而协商缓存如果命中走缓存的话，请求的状态码是304(not modified)。不同浏览器的策略不同，在Fire Fox中，from cache状态码是304.</span><br><span class="line"></span><br><span class="line">强缓存</span><br><span class="line">强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间。</span><br><span class="line">Expires:</span><br><span class="line">	该字段是http1.0时的规范，它的值为一个绝对时间的GMT格式的时间字符串，比如Expires:Mon,18 Oct 2066 23:59:59 GMT。这个时间代表着这个资源的失效时间，在此时间之前，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。</span><br><span class="line">Cache-Control:</span><br><span class="line">	Cache-Control是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对时间，例如Cache-Control:max-age=3600，代表着资源的有效期是3600秒。cache-control除了该字段外，还有下面几个比较常用的设置值：</span><br><span class="line"></span><br><span class="line">no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，</span><br><span class="line">		如果之前的响应中存ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。</span><br><span class="line">no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</span><br><span class="line">public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。</span><br><span class="line">private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</span><br><span class="line"></span><br><span class="line">Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高。</span><br><span class="line"></span><br><span class="line">为什么要有Etag</span><br><span class="line">HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</span><br><span class="line"></span><br><span class="line">1.一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)</span><br><span class="line">	这个时候我们并不希望客户端认为这个文件被修改了，而重新GET</span><br><span class="line">2.某些文件修改非常频繁，</span><br><span class="line">	比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</span><br><span class="line">3.某些服务器不能精确的得到文件的最后修改时间。</span><br><span class="line"></span><br><span class="line">Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</span><br><span class="line"></span><br><span class="line">200 OK（from cache）与304 Not Modified的区别</span><br><span class="line">	200 OK( from cache )不向服务器发送请求，直接使用本地缓存文件。</span><br><span class="line">	304 Not Modified则向服务器询问，若服务器认为浏览器的缓存版本还可用，那么便会返回304。</span><br><span class="line"></span><br><span class="line">缓存类型	获取资源形式	  状态码	               发送请求到服务器</span><br><span class="line">强缓存	     从缓存取	    200（from cache）	       否，直接从缓存取</span><br><span class="line">协商缓存	从缓存取	   304（Not Modified）	  否，通过服务器来告知缓存是否可用</span><br><span class="line"></span><br><span class="line">用户行为对缓存的影响</span><br><span class="line">用户操作		  Expires/Cache-Control		    Last-Modied/Etag</span><br><span class="line">地址栏回车		    有效							有效</span><br><span class="line">页面链接跳转	       有效						    有效</span><br><span class="line">新开窗口		     有效						     有效</span><br><span class="line">前进回退	         有效	                         有效</span><br><span class="line">F5刷新	          无效	                       有效</span><br><span class="line">Ctrl+F5强制刷新	     无效	                          无效</span><br></pre></td></tr></table></figure>

# 不能被缓存的请求

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache（HTTP1.0），</span><br><span class="line">   或Cache-Control:max-age=0等告诉浏览器不用缓存的请求</span><br><span class="line">2. 需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的</span><br><span class="line">3. 经过HTTPS安全加密的请求</span><br><span class="line">4. POST请求无法被缓存</span><br><span class="line">5. HTTP响应头中不包含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存</span><br></pre></td></tr></table></figure>

# 用户行为对缓存的影响

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qq、fire fox 、safari 、chrome 这几个浏览器的访问同一个页面，不同的浏览器在 F5 刷新的时候 ，同一个文件 qq 、fire fox 浏览器会返回 `304 Not Nodified`，在请求头中不携带 `Expires/Cache-Control`； 而 chrome 和 safari 刷新的时候，会返回 `200 from cache`， 没有真正发起请求，走强缓存。可见不同的浏览器反馈是不一致的，所以下面表格中&quot;F5刷新&quot;时 `Expires/Cache-Control` 会无效我认为是存在一定争议的。而 Ctrl + F5 强制刷新的时候，会暂时禁用强缓存和协商缓存。</span><br></pre></td></tr></table></figure>

# eslint 规则

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Eslint 是一个JavaScript验证工具,有了它可以让你的编辑器像ide一样进行一些静态的错误提示功能.</span><br><span class="line"></span><br><span class="line">npm install eslint -g</span><br><span class="line"></span><br><span class="line">某些文件关闭eslint检测</span><br><span class="line">	在文件的最顶端加上注释 /*eslint-disable*/</span><br><span class="line"></span><br><span class="line">关闭某一行代码的eslint检查</span><br><span class="line">	// eslint-disable-next-line</span><br><span class="line"></span><br><span class="line">.eslintrc.json配置rules选项</span><br></pre></td></tr></table></figure>

# git

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">（版本回退是什么命令，哪个命令查看已删除的提交commitId）</span><br><span class="line"></span><br><span class="line">git-reset 版本回退</span><br><span class="line"></span><br><span class="line">git reset --hard xxx	回到上一个版本</span><br><span class="line"></span><br><span class="line">git reset --soft xxx 该命令将最近一次提交节点的提交记录回退到暂存区</span><br><span class="line"></span><br><span class="line">git reset --mixed xxx	是将最近一次提交节点记录回退到工作区</span><br><span class="line"></span><br><span class="line">git log 与 git reflog 查看历史记录（被删除的历史commit ID）</span><br><span class="line"></span><br><span class="line">git场景问题</span><br><span class="line">提交暂存区git  add 出错    git reset HEAD &lt;文件名&gt; 回退</span><br><span class="line"></span><br><span class="line">提交本地仓库</span><br><span class="line">git  commit出错:</span><br><span class="line">1.更改 commit 信息:git commit --amend -m“新提交消息”</span><br><span class="line">2.漏提交:git add missed-file              // missed-file 为遗漏提交文件</span><br><span class="line">		git commit --amend --no-edit     //--no-edit提交消息不会更改</span><br><span class="line">3.git reset --hard commit_id      git  log查看提交的版本</span><br><span class="line"></span><br><span class="line">git revert 是提交一个新的版本</span><br><span class="line">git fetch  将远程主机的更新全部放到本地中</span><br><span class="line"></span><br><span class="line">git revert 和 git reset 的区别:</span><br><span class="line"></span><br><span class="line">(1)git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit。</span><br><span class="line">(2)git revert是用一次逆向的commit“中和”之前的提交   ,合并的时候回滚的变化不会出现</span><br><span class="line"></span><br><span class="line">git reset是之间把某些commit在某个branch上删除,合并时候回滚的commit会被引入</span><br></pre></td></tr></table></figure>

# node.js

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1.Node不是一个后端语言，但是它可以做类似后端语言的功能</span><br><span class="line">2.Node是使用谷歌V8引擎</span><br><span class="line">3.Node是js的一个运行环境</span><br><span class="line">4.Node具有非阻塞I/O 特点</span><br><span class="line">5.Node采用了Common.js规范</span><br><span class="line"></span><br><span class="line">node+koa2   node+express</span><br><span class="line"></span><br><span class="line">用于快速构建Node.js项目</span><br><span class="line"></span><br><span class="line">node.js 是一个基于 Chrome V8 引擎的 JavaScirpt 运行环境。</span><br><span class="line"></span><br><span class="line">Node.js使用了一个事件驱动、非阻塞式I/O的模型,使其轻量又高效**</span><br><span class="line"></span><br><span class="line">Node.js基于commonjs规范</span><br><span class="line"></span><br><span class="line">事件驱动： 任务执行，发布者，订阅者，事件驱动 .</span><br><span class="line">异步（非阻塞）： 执行某一个任务的同时也可以执行其他任务</span><br><span class="line">同步（阻塞）： 执行某一个任务，这个任务如果没有执行完成，其他任务必须等待</span><br><span class="line">I/O: 输入/输出（ 数据库操作，文件系统操作等  ） - 服务器的环境</span><br><span class="line">非阻塞I/O模型： 当使用Node.js来实现数据库操作、文件系统等操作时，要进行的异步操作，异步操作的核心传统实现方式就是回调函数和事件。</span><br><span class="line"></span><br><span class="line">Node.js的包管理工具npm</span><br><span class="line"></span><br><span class="line">优点：Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，异步编程，使其轻量又高效。</span><br><span class="line">缺点：单进程，单线程，只支持单核cpu，不能充分的利用多核cpu服务器。一旦这个进程崩掉，那么整个web服务就崩掉了。</span><br><span class="line"></span><br><span class="line">内置模块 http 是用于创建一个能够处理和响应 http 响应的服务</span><br><span class="line"></span><br><span class="line">fs 用于对系统文件及目录进行读写操作。</span><br><span class="line">path 提供了一些用于处理文件路径的小工具</span><br><span class="line">Url：帮助我们对提交上来的url进行解析处理</span><br><span class="line">querystring  提供用于解析和格式化 URL 查询字符串的工具。qs.parse()   qs.stringify()</span><br></pre></td></tr></table></figure>

# TS 语法

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">TypeScript具有类型系统，且是JavaScript的超集。它可以编译成普通的JavaScript代码。</span><br><span class="line">TypeScript支持任意浏览器，任意环境，任意系统并且是开源的。</span><br><span class="line"></span><br><span class="line">npm install -g typescript</span><br><span class="line"></span><br><span class="line">tsc --init 生成tsconfig.json配置文件</span><br><span class="line"></span><br><span class="line">基础数据类型</span><br><span class="line">number、string、boolean、null 、undefined</span><br><span class="line">any 表示任意类型</span><br><span class="line">void 表示空类型</span><br><span class="line">内置对象类型</span><br><span class="line">	Array Boolean</span><br><span class="line">	HTMLElement</span><br><span class="line">	HTMLDivElement</span><br><span class="line">自定义类型</span><br><span class="line">接口 interface</span><br><span class="line">类</span><br><span class="line">泛型  未来的类型定义的时候不知道是什么类型，调用的时候才知道</span><br><span class="line"></span><br><span class="line">元组</span><br><span class="line">1、数组中的数据类型必须和规定的类型顺序对应起来</span><br><span class="line">2、当使用越界索引给数组赋值的时候，会使用联合类型（只要值是规定类型的某一种即可）。</span><br><span class="line"></span><br><span class="line">枚举  enum类型是对JavaScript标准数据类型的一个补充</span><br><span class="line"></span><br><span class="line">never类型表示的是那些永不存在的值的类型。</span><br><span class="line"></span><br><span class="line">readonly:只读属性,不可修改</span><br><span class="line"></span><br><span class="line">sex? :表示sex是一个可传属性,可以有也可以没有</span><br><span class="line"></span><br><span class="line">[propName: string]: any;表示新增的属性可以是任意类型</span><br><span class="line"></span><br><span class="line">arr3: Array&lt;number&gt;  数组类型定义</span><br><span class="line"></span><br><span class="line">arr2: (number | string)[]</span><br><span class="line"></span><br><span class="line">fn (a: number, b: number) : number  函数类型定义</span><br></pre></td></tr></table></figure>

# linux 命令

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pwd:输入pwd命令，Linux会输出当前目录。</span><br><span class="line"></span><br><span class="line">ls命令用来查看目录的内容。</span><br><span class="line"></span><br><span class="line">cd命令用来改变所在目录。</span><br><span class="line"></span><br><span class="line">cat命令可以用来合并文件，也可以用来在屏幕上显示整个文件的内容。</span><br><span class="line"></span><br><span class="line">grep命令的最大功能是在一堆文件中查找一个特定的字符串。</span><br><span class="line"></span><br><span class="line">touch命令用来创建新文件</span><br><span class="line"></span><br><span class="line">cp命令用来拷贝文件</span><br><span class="line"></span><br><span class="line">mv命令用来移动文件</span><br><span class="line"></span><br><span class="line">rm命令用来删除文件。</span><br><span class="line"></span><br><span class="line">mkdir   创建文件夹创建目录</span><br></pre></td></tr></table></figure>

# CSS3 新特性

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1 圆角边框：border-radius</span><br><span class="line">2 多背景图：background</span><br><span class="line">3 颜色和透明度：background: rgba(0,0,0,.5)</span><br><span class="line">4 多列布局和弹性盒：display: flex</span><br><span class="line">5 盒子的变幻（2D、3D）</span><br><span class="line">	transform: translate(50px,100px);//移动</span><br><span class="line">	transform: rotate();             //旋转</span><br><span class="line">	transform: scale();  			 //缩放</span><br><span class="line">	transform: skew();  			 //倾斜</span><br><span class="line">6 过渡 transition: width 1s linear 2s;</span><br><span class="line">动画：animation: myfirst 5s;</span><br><span class="line">@keyframes myfirst &#123; 0% &#123;background: block;&#125; 25% &#123;background: red;&#125; 50% &#123;background: yellow;&#125; 100% &#123;background: green;&#125; &#125;</span><br><span class="line">7 引入web字体（在服务器端存储）</span><br><span class="line">8 媒体查询</span><br><span class="line">9 阴影 h</span><br><span class="line">10 文字阴影 text-shadow div</span><br><span class="line">11 盒子阴影 box-shadow</span><br></pre></td></tr></table></figure>

# HTML5 h5 新特性

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1 语义化标签 section aside header nav</span><br><span class="line">2 表单新特性：autofocus 自动获取焦点</span><br><span class="line">	placeholder 占位</span><br><span class="line">	multiple</span><br><span class="line">	autocomplete  自动补全，是否自动记录之前提交的数据，以用于下一次输入建议</span><br><span class="line">	required 在表单提交时会验证是否有输入，没有则弹出提示消息。</span><br><span class="line">	min：限定输入数字的最小值。</span><br><span class="line">	max：限定输入数字的最大值</span><br><span class="line">3 video（视频）和audio（音频）</span><br><span class="line">4 canvas画布</span><br><span class="line">5 webworker  就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。</span><br><span class="line">6 webscoket  服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</span><br><span class="line">7 拖拽api</span><br><span class="line">	dragstart：源对象开始拖放。</span><br><span class="line">	drag：源对象拖放过程中。</span><br><span class="line">	dragend：源对象拖放结束。</span><br><span class="line">	过程对象：</span><br><span class="line">	dragenter：源对象开始进入过程对象范围内。</span><br><span class="line">	dragover：源对象在过程对象范围内移动。</span><br><span class="line">	dragleave：源对象离开过程对象</span><br></pre></td></tr></table></figure>

# 标准盒模型与怪异盒模型区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">标准盒模型一个块的总宽度= width + margin(左右) + padding(左右) + border(左右)</span><br><span class="line">怪异盒模型一个块的总宽度= width + margin(左右)（即width已经包含了padding和 border值）</span><br></pre></td></tr></table></figure>

# CSS3 弹性盒

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">弹性盒 display:flex（父元素添加）</span><br><span class="line">弹性盒：控制子元素按主轴方向排列</span><br><span class="line">弹性盒可以设置单独内容水平垂直居中</span><br><span class="line">父元素：display:flex 子元素：margin:auto</span><br><span class="line">灵活元素：灵活元素即使是内联元素也能设置宽高</span><br><span class="line"></span><br><span class="line">加父元素身上</span><br><span class="line">1.flex-direction 属性指定了弹性子元素在父容器中的位置。</span><br><span class="line">	row：横向从左到右排列（左对齐），默认的排列方式。</span><br><span class="line">	row-reverse：反转横向排列（右对齐，从后往前排，最后一项排在最前面。</span><br><span class="line">	column：纵向排列。</span><br><span class="line">	olumn-reverse：反转纵向排列，从后往前排，最后一项排在最上面。</span><br><span class="line">2.justify-content:flex-start/flex-end/space-between/space-around</span><br><span class="line">3.align-items: 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式。</span><br><span class="line">		center/flex-start/flex-end/baseline/stretch</span><br><span class="line">4.flex-wrap:属性用于指定弹性盒子的子元素换行方式。nowrap/wrap/wrap-reverse</span><br><span class="line">5.align-content:设置各个行的对齐:</span><br><span class="line">	stretch - 默认。各行将会伸展以占用剩余的空间。</span><br><span class="line">	flex-start - 各行向弹性盒容器的起始位置堆叠。</span><br><span class="line">	flex-end - 各行向弹性盒容器的结束位置堆叠。</span><br><span class="line">	center -各行向弹性盒容器的中间位置堆叠。</span><br><span class="line">	space-between -各行在弹性盒容器中平均分布。</span><br><span class="line">	space-around</span><br><span class="line"></span><br><span class="line">加子元素身</span><br><span class="line">1、align-self：属性用于设置弹性元素自身在侧轴（纵轴）方向上的对齐方式。</span><br><span class="line">	align-self: auto | flex-start | flex-end | center | baseline | stretch</span><br><span class="line">	flex 属性用于指定弹性子元素如何分配空间。</span><br><span class="line">     	1: 计算值为 1 1 auto</span><br><span class="line">    	initial: 计算值为 0 1 auto</span><br><span class="line">     	none：计算值为 0 0 auto</span><br><span class="line">inherit：从父元素继承</span><br><span class="line">2、第一个参数表示: flex-grow 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大</span><br><span class="line">3、第二个参数表示: flex-shrink 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小</span><br><span class="line">4、第三个参数表示: flex-basis给上面两个属性分配多余空间之前, 计算项目是否有多余空间, 默认值为 auto, 即项目本身的大小</span><br></pre></td></tr></table></figure>

# CSS 元素居中

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.使用margin进行固定长度的偏移</span><br><span class="line"></span><br><span class="line">2.使用绝对定位并进行偏移(已知宽高)</span><br><span class="line">#father&#123; position:relative; &#125;</span><br><span class="line">#son&#123; position: absolute; left:50%; top:50%;</span><br><span class="line">	  margin-left: -子元素的宽/2; margin-top: -子元素的高/2; &#125;</span><br><span class="line"></span><br><span class="line">3.使用绝对定位并margin自适应进行居中</span><br><span class="line">#father&#123; position:relative;&#125;</span><br><span class="line">#son&#123;position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin:auto; &#125;</span><br><span class="line">			  (啊不斯陆特)</span><br><span class="line">4.使用弹性盒子来实现居中</span><br><span class="line">#father&#123; display: flex; justify-content: center; align-items: center; &#125;</span><br><span class="line">						(加斯特佛)				  (额来) (哎特木)</span><br><span class="line">5.使用定位 + transform</span><br><span class="line">#father&#123; position:relative;&#125;</span><br><span class="line">#son&#123; position: absolute; left: 50%; top: 50%; transform:translate(-50% -50%) &#125;</span><br><span class="line"></span><br><span class="line">6.table-cell布局</span><br><span class="line">因为table-cell相当与表格的td，td为行内元素，无法设置宽和高，所以嵌套一层，嵌套一层必须设置display: inline-block;</span><br></pre></td></tr></table></figure>

# CSS 几种定位的区别 relative, absolute, fixed

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、相对定位position:relative;参考物是自己,不脱离文档流(初始位置仍然占据空 间),top:100px; 给正值是向该容器的中心点移动;</span><br><span class="line"></span><br><span class="line">2、绝对定位position:absolute; 参考物是外层具有position属性的元素, 如果向外 都么有找到最后会参考body/html做定位</span><br><span class="line"></span><br><span class="line">3、固定定位position:fixed; 参考物是可视窗口</span><br><span class="line"></span><br><span class="line">4、粘性定位(了解)position:sticky; 是绝对定位+固定定位</span><br></pre></td></tr></table></figure>

# div 外边距重叠的原因及解决办法

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">情况一:</span><br><span class="line">	两个div垂直边界相邻，margin会等于二者中margin较大的值</span><br><span class="line">解决方案:</span><br><span class="line">1.position：absolute</span><br><span class="line">2.float:left</span><br><span class="line"></span><br><span class="line">情况二:</span><br><span class="line">	子元素在父元素内，子元素的margin-top会与父元素的margin-top重叠，值等于二者中较大的，如果只有子元素设置了margin-top，则显示为父元素的margin-top</span><br><span class="line">解决方案:</span><br><span class="line">1.给父元素设置border（给子元素设置边框没有用）</span><br><span class="line">2.给父元素设置padding值</span><br><span class="line">3.给父元素或子元素添加float：left</span><br><span class="line">4.给父元素或子元素添加position：absolute</span><br><span class="line">5.给父元素添加overflow：hidden</span><br><span class="line">6.给子元素添加display：inline-block</span><br><span class="line"></span><br><span class="line">情况三:</span><br><span class="line">	一个空白元素自身的margin-top和margin-bottom会重叠，值为而这种较大的</span><br><span class="line">解决方案:</span><br><span class="line">1.设置透明border</span><br></pre></td></tr></table></figure>

# px，em，rem，pt 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、px实际上就是像素，用px设置字体大小时，比较稳定和精确</span><br><span class="line">2、em就是根据基准来缩放字体的大小</span><br><span class="line">3、rem是相对于根元素字体大小来显示的</span><br><span class="line">4、pt的大小等于1英寸的1/72 浏览器的兼容性除了IE6 - IE8，其他的浏览器都支持em和rem，px所有浏览器都支持</span><br></pre></td></tr></table></figure>

# CSS 的 BFC

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1、什么是BFC BFC（Block formatting context）直译为“块级格式化上下文”。</span><br><span class="line">他是一个独立的渲染区域，也可以理解成一个独立的容器，并且这个容器里box的布局，与这个容器外的毫不相干。</span><br><span class="line"></span><br><span class="line">2、BFC渲染规则</span><br><span class="line">a.内部的box会在垂直方向，一个接一个的放置</span><br><span class="line">b.box垂直方向的距离由margin决定。属于同一个BFC的两个相邻box的margin会发生重 叠</span><br><span class="line">c.每个元素的margin box的左边，与包含块border box的左边相接触（对于从左往右的格 式化，否则相反）。</span><br><span class="line">即使存在浮动也是如此</span><br><span class="line">d.BFC的区域不会与float box重叠</span><br><span class="line">e.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之 也如此</span><br><span class="line">f.计算BFC的高度时，浮动元素也参与计算</span><br><span class="line"></span><br><span class="line">3、如何产生BFC</span><br><span class="line">a.根元素</span><br><span class="line">b.float属性不为none</span><br><span class="line">c.position为absolute或fixed</span><br><span class="line">d.display为inline-block， table-cell，table-caption，flex，inline-flex</span><br><span class="line">e.overflow不为visible</span><br><span class="line"></span><br><span class="line">4、BFC的作用</span><br><span class="line">a.自适应两栏布局</span><br><span class="line">b.清除内部浮动</span><br><span class="line">c.防止垂直margin重叠（放在两个BFC里）</span><br></pre></td></tr></table></figure>

# 兼容问题

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1）css浏览器兼容问题（比如设置元素透明度，ie浏览器使用滤镜实现，filter</span><br><span class="line">：progid：DXlmage Transform.Microsoft.Alpha(style=0,opacity=50);非IE浏览器</span><br><span class="line">opacity：0.5）</span><br><span class="line">解决方法：现在前端开发已经出现了非常多的框架和类库用于浏览器的兼容问题，比如jq类 库，解决获取元素中包含的所有文本内容兼容性问题，$(“element”).text(“element text”)</span><br><span class="line"></span><br><span class="line">2）css3浏览器前缀问题</span><br><span class="line">	-ms-：ie浏览器</span><br><span class="line">	-o-：opera欧朋浏览器</span><br><span class="line">	-webkit-：谷歌浏览器</span><br><span class="line">	-moz-：火狐浏览器</span><br><span class="line"></span><br><span class="line">工作中遇到的困难</span><br><span class="line">	1）IE6中高度不对问题</span><br><span class="line">		在div中给定了高度为1px,其它浏览器显示正常，可是ie6中显示的高度就不对了，这时我</span><br><span class="line">		给样式表中加 了个font-size:0px;line-height:0px;就好了</span><br><span class="line">	2)把border设为“0”像素虽然在页面上看不见，但按border默认值理解，</span><br><span class="line">		浏览器依然对 border- width/border-color进行了渲染，</span><br><span class="line">		即已经占用了内存值把border设为“none”即没有，浏览器解析“none”时将不作出渲染动作，即不会消耗内存</span><br></pre></td></tr></table></figure>



# 什么是 CSS 预处理器？优点是什么

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">css预处理器用一种专门的编程语言，进行web页面样式设计，然后在编译成正常的css文件，</span><br><span class="line">以供项目使用 在css中使用变量、简单的逻辑程序、函数。可以让你的css更加简洁、适应性更强、可读性更佳、更易于代码的维护</span><br></pre></td></tr></table></figure>

# 0.5px 线怎么实现（单边框 0.5px）

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方式一：border + border - img + 线性渐变linear-gradient</span><br><span class="line">方式二：定位 + 伪元素 + background + 线性渐变linear-gradient</span><br><span class="line">方式三：定位 + 伪元素 + transform缩放（scale）</span><br></pre></td></tr></table></figure>

# CSS 布局 - 左侧宽度固定，右侧自适应

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">方法一:</span><br><span class="line">	设置绝对定位</span><br><span class="line">	宽度固定区域设置 position：absolute+ left/right+ top + width</span><br><span class="line">	自适应区域设置 margin-left/margin-right: 固定宽度区域的宽度。</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">	（1）若左侧固定的高度大于右侧自适应区域高度</span><br><span class="line">		页面布局就变成这样了：（测试布局区域紧挨着自适应区域的下方，盖住了部分固定区域）</span><br><span class="line">		简单粗暴的就是测试布局区域定位的top值直接设置为两个区域最高的高度值</span><br><span class="line">	（2）若左侧固定的高度大于右侧自适应区域高度，且测试区域不进行定位</span><br><span class="line">方法二:</span><br><span class="line">	浮动布局</span><br><span class="line">	左侧固定区域浮动+宽度，右侧自适应区域 设置margin-left :左侧宽度值。</span><br><span class="line">方法三:</span><br><span class="line">	BFC规则</span><br><span class="line">	左侧固定区域浮动+宽度，右侧自适应区域（非浮动元素）设置overflow：hidden。</span><br></pre></td></tr></table></figure>

# CSS 布局 - 左右侧宽度固定，中间自适应

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、绝对定位布局：position + margin</span><br><span class="line">缺点: 如果中间栏含有最小宽度限制，或是含有宽度的内部元素，当浏览器宽度小到一定程度，会发生层重叠的情况。</span><br><span class="line">2、浮动布局： float + margin</span><br><span class="line">3、flex布局</span><br><span class="line">	高度由内容决定。</span><br><span class="line">4、table布局</span><br><span class="line">	高度由内容决定。</span><br><span class="line">5、Grid网格布局</span><br><span class="line">6、圣杯布局</span><br><span class="line">7、双飞翼布局</span><br><span class="line">8、对比圣杯布局和双飞翼布局</span><br><span class="line">（1）都是左右栏定宽，中间栏自适应的三栏布局，中间栏都放到文档流前面，保证先行渲染。</span><br><span class="line">（2）解决方案基本相似：都是三栏全部设置左浮动float：left,然后分别结局中间栏内容被覆盖的问题。</span><br><span class="line">（3）解决中间栏内容被覆盖问题时，圣杯布局设置父元素的padding,双飞翼布局在中间栏嵌套一个div,</span><br><span class="line">	内容放到新的	div中，并设置margin，实际上，双飞翼布局就是圣杯布局的改进方案。</span><br></pre></td></tr></table></figure>

# webpack 打包优化 怎么减少打包时间

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">多进程打包 - 速度分析</span><br><span class="line">多进程压缩 - 体积分析</span><br><span class="line">资源CDN</span><br><span class="line">动态polyfill - 根据不同浏览器，动态载入需要的polyfill,大幅度减少构建体积</span><br><span class="line"></span><br><span class="line">split-thunk</span><br><span class="line">前端构建项目中，为了提高打包效率，往往将第三库与业务逻辑代码分开打包，因为第三方库往往不需要经常打包更新。webpack建议使用CommonsChunk 来单独打包第三方库</span><br><span class="line"></span><br><span class="line">webpack loader(转换器)和plugin(插件)有什么区别:</span><br><span class="line">	loader它是一个转换器，将A文件进行编译形成B文件，这里操作的是文件，比如将A.scss转换为A.css，单纯的文件转换过程</span><br><span class="line">	plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务</span><br><span class="line"></span><br><span class="line">loader:</span><br><span class="line">	优雅降级，</span><br><span class="line">	图片打包</span><br><span class="line">plugin:</span><br><span class="line">	html产出：把public下面的html文件打包到build里面的index.html并自动引入app.js</span><br><span class="line">	css抽离</span><br><span class="line">	静态资源拷贝</span><br></pre></td></tr></table></figure>

# 继承的 6 种方式

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1.原型链继承</span><br><span class="line">	重点：让新实例的原型等于父类的实例。</span><br><span class="line">	特点：1、实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。</span><br><span class="line">　　　		（新实例不会继承父类实例的属性！）</span><br><span class="line">	缺点：1、新实例无法向父类构造函数传参。</span><br><span class="line">		 2、继承单一。</span><br><span class="line">		 3、所有新实例都会共享父类实例的属性。</span><br><span class="line">　　　　　　（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）</span><br><span class="line">2.借用构造函数继承</span><br><span class="line">	重点：用.call()和.apply()将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））</span><br><span class="line">	特点：1、只继承了父类构造函数的属性，没有继承父类原型的属性。</span><br><span class="line">		 2、解决了原型链继承缺点1、2、3。</span><br><span class="line">		 3、可以继承多个构造函数属性（call多个）。</span><br><span class="line">		 4、在子实例中可向父实例传参。</span><br><span class="line">	缺点：1、只能继承父类构造函数的属性。</span><br><span class="line">		 2、无法实现构造函数的复用。（每次用每次都要重新调用）</span><br><span class="line">		 3、每个新实例都有父类构造函数的副本，臃肿。</span><br><span class="line">3.组合继承（组合原型链继承和借用构造函数继承）</span><br><span class="line">	重点：结合了两种模式的优点，传参和复用</span><br><span class="line">	特点：1、可以继承父类原型上的属性，可以传参，可复用。</span><br><span class="line">		 2、每个新实例引入的构造函数属性是私有的。</span><br><span class="line">	缺点：调用了两次父类构造函数（耗内存），子类的构造函数会代替原型上的那个父类构造函数。</span><br><span class="line">4.原型式继承</span><br><span class="line">	重点：用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。			 object.create()就是这个原理。</span><br><span class="line">	特点：类似于复制一个对象，用函数来包装。</span><br><span class="line">	缺点：1、所有实例都会继承原型上的属性。</span><br><span class="line">		 2、无法实现复用。（新实例属性都是后面添加的）</span><br><span class="line">5.寄生式继承</span><br><span class="line">	重点：就是给原型式继承外面套了个壳子。</span><br><span class="line">	优点：没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。</span><br><span class="line">	缺点：没用到原型，无法复用。</span><br><span class="line">6.寄生组合式继承（常用）</span><br><span class="line">	重点：修复了组合继承的问题</span><br><span class="line">	寄生：在函数内返回对象然后调用</span><br><span class="line">	组合：1、函数的原型等于另一个实例。</span><br><span class="line">		 2、在函数中用apply或者call引入另一个构造函数，可传参　</span><br></pre></td></tr></table></figure>

# 阻止冒泡和取消默认事件(默认行为)

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">防止事件捕获和冒泡:</span><br><span class="line">w3c的方法是e.stopPropagation()</span><br><span class="line">IE则是使用e.cancelBubble = true</span><br><span class="line"></span><br><span class="line">取消默认事件</span><br><span class="line">w3c的方法是e.preventDefault()</span><br><span class="line">IE则是使用e.returnValue = false</span><br><span class="line"></span><br><span class="line">jQuery用法</span><br><span class="line">阻止默认事件 return false (不停止冒泡)</span><br></pre></td></tr></table></figure>

# 作用域和作用域链

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">变量的作用域无非就是两种：</span><br><span class="line">全局变量和局部变量。javascript的作用域是相对函数而言的，可以称为函数作用域</span><br><span class="line"></span><br><span class="line">全局作用域：</span><br><span class="line">最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是可以访问的</span><br><span class="line"></span><br><span class="line">局部作用域：</span><br><span class="line">局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无法访问的</span><br><span class="line"></span><br><span class="line">作用域链：</span><br><span class="line">根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问。</span><br><span class="line">	作用域链的前端，始终都是当前执行的代码所在环境的变量对象</span><br><span class="line">	作用域链中的下一个对象来自于外部环境，而在下一个变量对象则来自下一个外部环境，一直到全局执行环境</span><br><span class="line">	全局执行环境的变量对象始终都是作用域链上的最后一个对象</span><br></pre></td></tr></table></figure>

# 遍历数组的方式

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">1.for循环</span><br><span class="line">使用临时变量，将长度缓存起来，避免重复获取数组长度，当数组较大时优化效果才会比较明显。</span><br><span class="line"></span><br><span class="line">2.foreach循环</span><br><span class="line">遍历数组中的每一项，没有返回值，对原数组没有影响，不支持IE。</span><br><span class="line">有一些局限，不能continue跳过或者break终止循环</span><br><span class="line"></span><br><span class="line">3.map循环</span><br><span class="line">有返回值，可以return出来</span><br><span class="line">map的回调函数中支持return返回值</span><br><span class="line">并不影响原来的数组，return的是新数组</span><br><span class="line"></span><br><span class="line">4.for of遍历</span><br><span class="line">可以正确响应break、continue和return语句</span><br><span class="line"></span><br><span class="line">5.filter遍历</span><br><span class="line">不会改变原始数组,返回新数组</span><br><span class="line"></span><br><span class="line">6.every遍历</span><br><span class="line">every()是对数组中的每一项运行给定函数，如果该函数对每一项返回true,则返回true。</span><br><span class="line"></span><br><span class="line">7.some遍历</span><br><span class="line">some()是对数组中每一项运行指定函数，如果该函数对任一项返回true，则返回true。</span><br><span class="line"></span><br><span class="line">8.reduce</span><br><span class="line">reduce()方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。</span><br><span class="line"></span><br><span class="line">9.reduceRight</span><br><span class="line">reduceRight()方法的功能和reduce()功能是一样的，</span><br><span class="line">不同的是reduceRight()从数组的末尾向前将数组中的数组项做累加。</span><br><span class="line"></span><br><span class="line">10.find</span><br><span class="line">find()方法返回数组中符合测试函数条件的第一个元素。否则返回undefined</span><br><span class="line"></span><br><span class="line">11.findIndex</span><br><span class="line">对于数组中的每个元素，findIndex方法都会调用一次回调函数（采用升序索引顺序），直到有元素返回 true。</span><br><span class="line">只要有一个元素返回 true，findIndex立即返回该返回 true 的元素的索引值。</span><br><span class="line">如果数组中没有任何元素返回 true，则 findIndex 返回 -1。</span><br><span class="line">findIndex 不会改变数组对象。</span><br><span class="line"></span><br><span class="line">12.keys，values，entries</span><br><span class="line">ES6 提供三个新的方法 —— entries()，keys()和values() —— 用于遍历数组。</span><br><span class="line">它们都返回一个遍历器对象，可以用for...of循环进行遍历，</span><br><span class="line">唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历</span><br></pre></td></tr></table></figure>

# 数据分页

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前端的话，定义一个新的数组for循环判断，有个公式，计算起始页和终止页的。</span><br><span class="line">符合条件push仅数组中，后端就是用limt判断</span><br></pre></td></tr></table></figure>

# 数组排序

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1. 普通数组排序　　</span><br><span class="line">　　js中用方法sort()为数组排序。sort()方法有一个可选参数，是用来确定元素顺序的函数。如果这个参数被省略，那么数组中的元素将按照ASCII字符顺序进行排序。</span><br><span class="line">2. 冒泡排序</span><br><span class="line">（1）比较相邻的元素。如果第一个比第二个大，就交换他们两个位置。</span><br><span class="line">（2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</span><br><span class="line">（3）针对所有的元素重复以上的步骤，除了最后一个。</span><br><span class="line">（4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</span><br><span class="line">3. 快速排序：递归思想，两边快速的排序，冒泡排序的改进</span><br><span class="line">（1）选择数组中间数作为基数，并从数组中取出此基数；</span><br><span class="line">（2）准备两个数组容器，遍历数组，逐个与基数比对，较小的放左边容器，较大的放右边容器；</span><br><span class="line">（3）进行相同的操作，直到数组中只有一个元素时，返回该数组。</span><br><span class="line">4. 插入排序</span><br><span class="line">（1）从第一个元素开始，该元素可以认为已经被排序</span><br><span class="line">（2）取出下一个元素，在已经排序的元素序列中扫描</span><br><span class="line">（3）如果该元素（已排序）大于新元素，将该元素移到下一位置</span><br><span class="line">（4）重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</span><br><span class="line">（5）将新元素插入到下一位置中</span><br><span class="line">（6）重复步骤2</span><br><span class="line">5. 选择排序</span><br><span class="line">（1）在未排序序列中找到最小（大）元素</span><br><span class="line">（2）并存放到排序序列的起始位置</span><br><span class="line">（3）然后，再从剩余未排序元素中继续寻找最小（大）元素</span><br><span class="line">（4）然后放到已排序序列的末尾。</span><br><span class="line">（5）以此类推</span><br></pre></td></tr></table></figure>

# 数组合并

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1、concat</span><br><span class="line">	js的Array对象提供了一个叫concat()方法，连接两个或更多的数组，并返回结果。</span><br><span class="line">		var c = a.concat(b); //c=[1,2,3,4,5,6];</span><br><span class="line"></span><br><span class="line">	这里有一个问题，concat方法连接a、b两个数组后，a、b两个数组的数据不变，同时会返回一个新的数组。这样当我们需要进行多次的数组合并时，会造成很大的内存浪费，如果是数据量比较小的时候，还可以勉强用，如果数据量大的时候，这个就不妥了，所以这个方法肯定不是最好的。</span><br><span class="line"></span><br><span class="line">2、for循环</span><br><span class="line">大概的思路是：遍历其中一个数组，把该数组中的所有元素依次添加到另外一个数组中。直接上代码：</span><br><span class="line">	for(var i in b) &#123; a.push ( b[i] );&#125;</span><br><span class="line"></span><br><span class="line">3、apply</span><br><span class="line">	函数的apply方法有一个特性，那就是func.apply(obj,argv)，argv是一个数组。</span><br><span class="line">		a.push.apply(a,b);</span><br><span class="line">	调用a.push这个函数实例的apply方法，同时把，b当作参数传入，</span><br><span class="line">	这样a.push这个方法就会遍历b数组的所有元素，达到合并的效果。</span><br><span class="line">	这里可能有点绕，我们可以把b看成[4,5,6]，变成这样：</span><br><span class="line">		a.push.apply(a,[4,5,6]);</span><br><span class="line">	然后上面的操作就等同于：</span><br><span class="line">		a.push(4,5,6);</span><br><span class="line">	这样就很清楚了！</span><br></pre></td></tr></table></figure>

# 数组方法

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">push，在数组末尾添加一位或多位元素</span><br><span class="line">pop，删除数组最后一位元素</span><br><span class="line">unshift，在数组的开头添加一位或多位元素</span><br><span class="line">shift，删除数组的第一位元素</span><br><span class="line">join，将数组转换为字符串</span><br><span class="line">reserve，反转数组元素的顺序</span><br><span class="line">sort，对数组进行排序</span><br><span class="line">concat，连接两个或多个数组</span><br><span class="line">splice，添加或删除数组中的元素</span><br><span class="line">slice，从已有的数组中返回选定的元素</span><br><span class="line">indexOf、lastIndexOf，查找数组中的元素</span><br><span class="line">forEach，对数组进行遍历循环，对数组中每一项运行指定的函数</span><br><span class="line">map，迭代数组</span><br><span class="line">filter，对数组中的元素进行指定的检查返回符合条件的元素放入一个新数组中</span><br><span class="line">every，测试所有元素是否都符合指定条件</span><br><span class="line">some，测试某些元素是否符合指定条件</span><br><span class="line">reduce，接收一个函数作为累加器，数组中的每个值开始缩减，最终计算为一个值</span><br><span class="line">toString，将数组转换为字符串</span><br></pre></td></tr></table></figure>

# 数组去重

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">使用ES6 Set</span><br><span class="line">	var arr = [1, 1, 4, 2, 2, 3, 3, 3, 6, 6, 6];</span><br><span class="line">	arr = Array.from(new Set(arr));</span><br><span class="line">	console.log(arr);//[1, 4, 2, 3, 6]</span><br><span class="line"></span><br><span class="line">使用indexOf</span><br><span class="line">	var arr = [1, 1, 4, 2, 2, 3, 3, 3, 6, 6, 6];</span><br><span class="line">	var newArr = [];</span><br><span class="line">	arr.forEach((item) =&gt; &#123;</span><br><span class="line">  		newArr.indexOf(item) === -1 ? newArr.push(item) : &quot;&quot;;</span><br><span class="line">	&#125;);</span><br><span class="line">	console.log(newArr);//[1, 4, 2, 3, 6]</span><br><span class="line"></span><br><span class="line">使用lastIndexOf</span><br><span class="line">	var arr = [1, 1, 4, 2, 2, 3, 3, 3, 6, 6, 6];</span><br><span class="line">	var newArr = [];</span><br><span class="line">	arr.forEach((item) =&gt; &#123;</span><br><span class="line">  		newArr.lastIndexOf(item) === -1 ? newArr.push(item) : &quot;&quot;;</span><br><span class="line">	&#125;);</span><br><span class="line">    console.log(newArr);//[1, 4, 2, 3, 6]</span><br><span class="line"></span><br><span class="line">使用双重for循环加splice方法</span><br><span class="line">	var arr = [1, 1, 4, 2, 2, 3, 3, 3, 6, 6, 6];</span><br><span class="line">	for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line"> 		for (var j = i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">    		if (arr[i] == arr[j]) &#123;</span><br><span class="line">      			arr.splice(j,1);</span><br><span class="line">      			j--;</span><br><span class="line">    		&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	console.log(arr);//[1, 4, 2, 3, 6]</span><br><span class="line"></span><br><span class="line">使用forEach和includes方法</span><br><span class="line">	var arr = [1, 1, 4, 2, 2, 3, 3, 3, 6, 6, 6];</span><br><span class="line">	var newArr = [];</span><br><span class="line">	arr.forEach((item) =&gt; &#123;</span><br><span class="line">  		newArr.includes(item) ? &quot;&quot; : newArr.push(item);</span><br><span class="line">	&#125;);</span><br><span class="line">	console.log(newArr);//[1, 4, 2, 3, 6]</span><br><span class="line"></span><br><span class="line">使用fliter和includes方法</span><br><span class="line">	var arr = [1, 1, 4, 2, 2, 3, 3, 3, 6, 6, 6];</span><br><span class="line">	var newArr = [];</span><br><span class="line">	arr.filter((item) =&gt; &#123;</span><br><span class="line">  		newArr.includes(item) ? &quot;&quot; : newArr.push(item);</span><br><span class="line">	&#125;);</span><br><span class="line">	console.log(newArr);//[1, 4, 2, 3, 6]</span><br><span class="line"></span><br><span class="line">使用排序，比较前一个值跟后一个值是否相等</span><br><span class="line"></span><br></pre></td></tr></table></figure>

# for...of 原理

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">for...of 是ES6引入用来遍历所有数据结构的统一方法。</span><br><span class="line"></span><br><span class="line">这里的所有数据结构只指具有iterator接口的数据。</span><br><span class="line">一个数据只要部署了 Symbol.iterator，就具有了 iterator接口，就可以使用 for...of 循环遍历它的成员。</span><br><span class="line">也就是说，for...of循环内部调用的数据结构为Symbol.iterator方法。</span><br><span class="line">部署在 Symbol.iterator 属性，或者说，一个数据结构只要具有 Symbol.iterator 属性，就认为是&quot;可遍历的&quot;。</span><br><span class="line"></span><br><span class="line">Iterator(伊特瑞特):</span><br><span class="line">	遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。</span><br><span class="line">	任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</span><br><span class="line">	通俗点理解就是为了解决不同数据结构遍历的问题，引入了Iterator.</span><br><span class="line"></span><br><span class="line">Iterator的特点:</span><br><span class="line">	各种数据结构，提供一个统一的、简便的访问接口</span><br><span class="line">	使得数据结构的成员能够按某种次序排列</span><br><span class="line">	ES6 创造了一种新的遍历命令for...of循环，Iterator 接口主要供for...of消费</span><br><span class="line"></span><br><span class="line">原生具备 Iterator 接口的数据结构如下。</span><br><span class="line">	Array</span><br><span class="line">	Map</span><br><span class="line">	Set</span><br><span class="line">	String：字符串是一个类似数组的对象，也原生具有 Iterator 接口。</span><br><span class="line">	TypedArray：</span><br><span class="line">		通俗理解：ArrayBuffer是一片内存空间，不能直接引用里面的数据，可以通过TypedArray类型引用，</span><br><span class="line">				用户只能通过TypedArray使用这片内存，不能直接通过ArrayBuffer使用这片内存</span><br><span class="line">	函数的 arguments 对象</span><br><span class="line">	NodeList 对象</span><br><span class="line"></span><br><span class="line">除了原生具备Iterator 接口的数据之外，其他数据结构（主要是对象）的 Iterator 接口，</span><br><span class="line">都需要自己在Symbol.iterator属性上面部署，这样才会被for...of循环遍历。</span><br><span class="line"></span><br><span class="line">对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。</span><br><span class="line"></span><br><span class="line">一个对象如果要具备可被for...of循环调用的 Iterator 接口，就必须在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</span><br></pre></td></tr></table></figure>

# 遍历对象的方式

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">第一种：</span><br><span class="line">for...in</span><br><span class="line"></span><br><span class="line">第二种：</span><br><span class="line">1）Object.keys（obj）</span><br><span class="line">2）Object.values（obj）</span><br><span class="line">参数：</span><br><span class="line">	obj：要返回其枚举自身属性的对象</span><br><span class="line">返回值：</span><br><span class="line">	一个表示给定对象的所有可枚举属性的字符串数组。</span><br><span class="line"></span><br><span class="line">第三种：</span><br><span class="line">使用Object.getOwnPropertyNames(obj)</span><br><span class="line">返回一个数组，包含对象自身的所有属性（包含不可枚举属性）</span><br><span class="line">遍历可以获取key和value</span><br></pre></td></tr></table></figure>

# map 与 filter 和 forEach 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map 与 filter 区别:</span><br><span class="line">	相同点：filter 和 map 都是对数组的操作，均返回一个新的数组</span><br><span class="line">	不同点：filter是满足条件的留下，是对原数组的过滤；map则是对原数组的加工，映射成一对一映射的新数组</span><br><span class="line"></span><br><span class="line">map 与 forEach 区别:</span><br><span class="line">	map()会分配内存空间存储新数组并返回，forEach()不会返回数据(undefined)。</span><br><span class="line">	forEach()允许callback更改原始数组的元素。map()返回新的数组。</span><br></pre></td></tr></table></figure>

# 面向对象编程

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">面向对象编程:</span><br><span class="line">将所需要做的功能抽象成一个“对象”，然后一遍遍地调用这个对象来完成你想要的功能。</span><br><span class="line"></span><br><span class="line">面向对象的三大特征:</span><br><span class="line">1.封装</span><br><span class="line">我们平时所用的方法和类都是一种封装，当我们在项目开发中，遇到一段功能的代码在好多地方重复使用的时候，我们可以把他单独封装成一个功能的方法，这样在我们需要使用的地方直接调用就可以了。</span><br><span class="line"></span><br><span class="line">2.继承</span><br><span class="line">继承在我们的项目开发中主要使用为子类继承父类，继承会继承父类的实例属性和实例方法，并不会继承静态属性和静态方法，并且静态方法只能通过类名去调用。</span><br><span class="line"></span><br><span class="line">3.多态</span><br><span class="line">多态的具体表现为方法重载和方法重写：</span><br><span class="line">方法重载：</span><br><span class="line">重载是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数</span><br><span class="line">方法重写：</span><br><span class="line">重写（也叫覆盖）是指在派生类中重新对基类中的虚函数（注意是虚函数）重新实现。即函数名和参数都一样，只是函数的实现体不一样</span><br><span class="line"></span><br><span class="line">三大特征的优点：</span><br><span class="line">封装：</span><br><span class="line">封装的优势在于定义只可以在类内部进行对属性的操作，外部无法对这些属性指手画脚，要想修改，也只能通过你定义的封装方法；</span><br><span class="line"></span><br><span class="line">继承：</span><br><span class="line">继承减少了代码的冗余，省略了很多重复代码，开发者可以从父类底层定义所有子类必须有的属性和方法，以达到耦合的目的；</span><br><span class="line"></span><br><span class="line">多态：</span><br><span class="line">多态实现了方法的个性化，不同的子类根据具体状况可以实现不同的方法，光有父类定义的方法不够灵活，遇见特殊状况就捉襟见肘了</span><br></pre></td></tr></table></figure>

# window.onload 与 document.ready 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.执行时间</span><br><span class="line">	window.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。</span><br><span class="line">	$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。</span><br><span class="line"></span><br><span class="line">2.编写个数不同</span><br><span class="line">	window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个</span><br><span class="line">	$(document).ready()可以同时编写多个，并且都可以得到执行</span><br><span class="line"></span><br><span class="line">3.简化写法</span><br><span class="line">	window.onload没有简化写法</span><br><span class="line">	$(document).ready(function()&#123;&#125;)可以简写成$(function()&#123;&#125;);</span><br></pre></td></tr></table></figure>

# this

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">this代表函数运行时，自动生成的一个内部对象，只能在函数内部使用，</span><br><span class="line">随着函数使用场合的不同，this的值会发生变化。</span><br><span class="line"></span><br><span class="line">指向:</span><br><span class="line">1.在方法中，this 表示该方法所属的对象。</span><br><span class="line">2.如果单独使用，this 表示全局对象。</span><br><span class="line">3.函数中，this 表示全局对象。</span><br><span class="line">4.严格模式下，this 是未定义的(undefined)。</span><br><span class="line">5.在事件中，this 表示接收事件的元素。</span><br><span class="line">6.类似 call() 和 apply() 方法可以将 this 引用到任何对象。</span><br><span class="line">7.箭头函数本身是没有this和arguments的，引用的this实际上是调用的是定义时的上一层作用域的this。</span><br></pre></td></tr></table></figure>

# &lt;!DOCTYPE&gt;

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE&gt; 声明位于文档中的最前面的位置，处于 &lt;html&gt; 标签之前。</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE&gt; 声明不是一个 HTML 标签；它是用来告知 Web 浏览器页面使用了哪种 HTML 版本。</span><br><span class="line"></span><br><span class="line">在 HTML 4.01 中，&lt;!DOCTYPE&gt; 声明需引用 DTD （文档类型声明），</span><br><span class="line">因为 HTML 4.01 是基于 SGML （Standard Generalized Markup Language 标准通用标记语言）。</span><br><span class="line">DTD 指定了标记语言的规则，确保了浏览器能够正确的渲染内容。</span><br><span class="line"></span><br><span class="line">HTML5 不是基于 SGML，因此不要求引用 DTD。</span><br><span class="line"></span><br><span class="line">给您 HTML 文档添加 &lt;!DOCTYPE&gt; 声明，确保浏览器能够预先知道文档类型。</span><br></pre></td></tr></table></figure>

# CSS position 属性

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">absolute:生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。</span><br><span class="line">fixed	:生成固定定位的元素，相对于浏览器窗口进行定位。</span><br><span class="line">relative:生成相对定位的元素，相对于其正常位置进行定位。</span><br><span class="line">static	:默认值。没有定位。</span><br><span class="line">sticky	:粘性定位，该定位基于用户滚动的位置。</span><br><span class="line">inherit	:规定应该从父元素继承 position 属性的值。</span><br></pre></td></tr></table></figure>

# js 的解构

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">解构定义：允许按照一定模式，从数组和对象中提取值，对变量进行赋值。</span><br><span class="line">解构必须满足的条件：（模式匹配），只要等号两边的模式相同，左边的变量就会被赋予对应的值。</span><br><span class="line">主要介绍2种解构常用的类型：数组解构和对象解构。</span><br><span class="line"></span><br><span class="line">数组解构：</span><br><span class="line">	1.数组中的变量个数比赋值的数组中个数少的解构：</span><br><span class="line">	2.数组中的变量个数比赋值的数组中个数多的解构：</span><br><span class="line">	3.数组中的变量中有空字符的解构：上面的3种数组解构，赋值的数组的数值按位赋值给另外一方数组中的变量</span><br><span class="line">	4.数组中的变量中有不定参数(有些时候也叫扩展运算符)的解构：需要注意的是不定参数必须放最后。</span><br><span class="line">	5.数组中的变量中有默认值的解构：如果赋值的数组个数没有另外一方数组变量个数多，并且变量数组有默认，</span><br><span class="line">								没有进行赋值用默认，进行赋值用赋值的</span><br><span class="line"></span><br><span class="line">对象的解构：两方也需要相同类型的括号，对象结构使用大括号&#123;&#125;</span><br><span class="line">普通对象解构：</span><br><span class="line">	对象跟数值解构不同的一点，对象解构不是按位去赋值，是根据键名(属性名) 来进行赋值</span><br><span class="line">有默认值的对象解构</span><br><span class="line">	跟数组的默认值差不多，有赋值就用赋值的，没有就用默认值</span><br><span class="line">有不定参数的对象解构</span><br><span class="line">	跟数组的不定参数差不多，不定参数放在最后，不定参数创建一个对象接受的剩下的键名键值(属性名属性值)</span><br><span class="line">有嵌套的对象解构</span><br><span class="line">	主要注意嵌套层次是不是赋值一方对象的嵌套层次相同。</span><br></pre></td></tr></table></figure>

# js 实现轮播图思路

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">1.图片移动实现原理：</span><br><span class="line">利用浮动将所有所有照片依次排成一行，给这一长串图片添加一个父级的遮罩，每次只显示一张图，其余的都隐藏起来。对图片添加绝对定位，通过控制left属性，实现照片的移动。</span><br><span class="line"></span><br><span class="line">2.图片移动动画原理：</span><br><span class="line">从a位置移动到b位置，需要先计算两点之间的差值，通过差值和时间间隔，计算出每次移动的步长，通过添加定时器，每次移动相同的步长，实现动画效果。</span><br><span class="line"></span><br><span class="line">3.图片定位停止原理：</span><br><span class="line">每一张照片都有相同的宽度，每张照片都有一个绝对的定位数值，通过检测定每次移动后，照片当前位置和需要到达位置之间的距离是否小于步长，如果小于，说明已经移动到位，可以将定时器清除，来停止动画。</span><br><span class="line"></span><br><span class="line">4图片切换原理：</span><br><span class="line">在全局设置一个变量，记录当前图片的位置，每次切换或跳转时，只需要将数值修改，并调用图片页数转像素位置函数，再调用像素运动函数即可。</span><br><span class="line"></span><br><span class="line">5.自动轮播原理：</span><br><span class="line">设置定时器，一定时间间隔后，将照片标记加1，然后开始切换。</span><br><span class="line"></span><br><span class="line">6.左右点击切换原理：</span><br><span class="line">修改当前位置标记，开始切换。这里需要注意与自动轮播之间的冲突。当点击事件触发之后，停止自动轮播计时器，开始切换。当动画结束后再次添加自动轮播计时器。</span><br><span class="line"></span><br><span class="line">7.无缝衔接原理：</span><br><span class="line">需要无缝衔接，难度在于最后一页向后翻到第一页，和第一页向前翻到最后一页。由于图片的基本移动原理。要想实现无缝衔接，两张图片就必须紧贴在一起。所以在第一张的前面需要添加最后一张，最后一张的后面需要添加第一张。</span><br><span class="line"></span><br><span class="line">首先判断图片的位置，是否移动到位。当满足当前位置，与预定位置之间的距离小于一步时，认定为移动到位，并把图片直接定位到预定位置。然后判断，图片的位置是否需要跳转。</span><br><span class="line">ps：这里一定要在图片运动函数结束后，在进行跳转。</span><br><span class="line"></span><br><span class="line">8.预防鬼畜原理：</span><br><span class="line">始终保证轮播图的运动动画只有一个，从底层杜绝鬼畜。需要在每次动画开始之前，尝试停止动画定时器，然后开始为新的动画添加定时器。</span><br><span class="line"></span><br><span class="line">轮播图鬼畜的本质原因就是，同一时间多个定时器添加在图片上，这些定时器直接相互冲突，造成图片的抖动。</span><br><span class="line">解决方法：每次执行运动函数之前，先尝试清除一下，上一个轮播图的定时器。确保同时触发运动函数时，只有一个定时器在工作。</span><br><span class="line"></span><br><span class="line">9.预防暴力点击原理：</span><br><span class="line">如果用户快速点击触发事件，会在短时间内多次调用切换函数，虽然动画函数可以保证，不会发生鬼畜，但在照片从最后一张到第一张的切换过程，不会按照正常的轮播，而是实现了跳转。所以需要通过添加口令的方式来，限制用户的点击。当用户点击完成后，口令销毁，动画结束后恢复口令。</span><br><span class="line"></span><br><span class="line">10.小圆点的位置显示原理：</span><br><span class="line">每次触发动画时，通过全局变量标记，获取当前页数，操作清除所有小圆点，然后指定一页添加样式。</span><br><span class="line"></span><br><span class="line">11.点击触发跳转的原理：</span><br><span class="line">类似于左右点击触发，只是这是将全局页面标记，直接修改，后执行动画。需要避免与自动轮播定时器的冲突。</span><br></pre></td></tr></table></figure>

# js 数组和对象的扩展

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.Array.from()方法用于将对象转为真正的数组(类数组转数组)</span><br><span class="line">2.Array.of()方法用于将一组值，转换为数组。</span><br><span class="line">  console.log(Array.of(1,2,3,4,4,50));//[1, 2, 3, 4, 4, 50]</span><br><span class="line">3.Object.assi                                                                                                                                                                                      gn(目标对象,对象1,对象2)用于对象的合并,将源对象的所有可枚举属性，复制到目标对象。(浅拷贝)</span><br></pre></td></tr></table></figure>

# js 提升

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一、提升（Hosting）</span><br><span class="line">简单说就是在js代码执行前引擎会先进行预编译，预编译期间会将变量声明与函数声明提升至其对应作用域的最顶端。</span><br><span class="line"></span><br><span class="line">二、变量提升</span><br><span class="line">在ES6之前，JavaScript没有块级作用域(一对花括号&#123;&#125;即为一个块级作用域)，只有全局作用域和函数作用域。</span><br><span class="line">变量提升即将变量声明提升到它所在作用域的最开始的部分。</span><br><span class="line">变量声明的提升是以变量所处的第一层词法作用域为“单位”的，即全局作用域中声明的变量会提升至全局最顶层，函数内声明的</span><br><span class="line"></span><br><span class="line">三、函数提升</span><br><span class="line">即函数提升只会提升函数声明，而不会提升函数表达式。</span><br><span class="line"></span><br><span class="line">四、为什么会有提升？</span><br><span class="line">函数提升就是为了解决相互递归的问题，大体上可以解决像ML语言这样自下而上的顺序问题。</span><br><span class="line">大概是说，变量提升是人为实现的问题，而函数提升在当初设计时是有目的的。</span><br></pre></td></tr></table></figure>

# 比较 redux 和 vuex 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redux和vuex的区别</span><br><span class="line">	1）vuex是redux的基础上进行改变，对仓库的管理更加明确</span><br><span class="line">	2）使用mutation来替换redux中的reducer</span><br><span class="line">	3)vuex有自动渲染的功能，所以不需要更新</span><br><span class="line"></span><br><span class="line">redux和flux的区别</span><br><span class="line">　　1）redux是flux中的一个实现</span><br><span class="line">　　2））在redux中我们只能定义一个store，在flux中我们可以定义多个</span><br><span class="line">　　3）在redux中，store和dispatch都放到了store，结构更加清晰</span><br><span class="line">　　4）在redux中本身就内置State对象，对仓库的管理更加明确</span><br></pre></td></tr></table></figure>

# CSS 选择符

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CSS选择符</span><br><span class="line">	id选择器（#myid）</span><br><span class="line">	类选择器（.myclassname）</span><br><span class="line">	标签选择器（div）</span><br><span class="line">	相邻选择器（h1+p）</span><br><span class="line">	子选择器（ul&gt;li）</span><br><span class="line">	后代选择器（li a）</span><br><span class="line">	群组选择器（div，p&#123;&#125;）</span><br><span class="line">	通配符选择器（*）</span><br><span class="line">	属性选择器（a[title=&quot;&quot;]）</span><br><span class="line">	伪类选择器（a:hover&#123;&#125;或者li:nth-child&#123;&#125;）</span><br></pre></td></tr></table></figure>

# CSS 中 link 和@import 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">link属于HTML标签，@import是CSS提供的</span><br><span class="line"></span><br><span class="line">页面被加载时，link引用的css文件会同时被加载，而@import引用的css文件要等到页面被加载完毕再加载</span><br><span class="line"></span><br><span class="line">import只在IE5以上才能识别，link是HTML标签，无兼容问题</span><br><span class="line"></span><br><span class="line">link 引入样式的权重大于@import 的引用</span><br></pre></td></tr></table></figure>

# CSS 中 display:none、visibility:hidden 和 opacity:0;的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">display:none;隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢。</span><br><span class="line"></span><br><span class="line">visibility:hidden;隐藏对应的元素，但在文档布局中仍保留原来的空间。</span><br><span class="line"></span><br><span class="line">opacity:0;内容不可见，占据空间。</span><br></pre></td></tr></table></figure>

# CSS 中 rgba()和 opacity 的透明效果区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rgba()和 opacity 都能实现透明效果，但最大的不同是 opacity 作用于元素，以及元素内的所有内容的透明度；</span><br><span class="line"></span><br><span class="line">rgba()只作用于元素的颜色或其背景色（设置 rgba 透明的元素的子元素不会继承透明效果）。</span><br></pre></td></tr></table></figure>

# CSS 的外边距重叠

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在 CSS 当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。</span><br><span class="line"></span><br><span class="line">折叠结果遵循下列计算规则如下</span><br><span class="line"></span><br><span class="line">两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</span><br><span class="line"></span><br><span class="line">两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</span><br><span class="line"></span><br><span class="line">两个外边距一正一负时，折叠结果是两者之和。</span><br></pre></td></tr></table></figure>

# CSS 清除浮动

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">清除浮动主要是为了解决父元素因为子元素浮动引起的内部高度为0的问题。</span><br><span class="line">常见清除浮动的方法</span><br><span class="line">	额外标签法。在最后浮动元素后加一个标签，设置clear:both；</span><br><span class="line">	给父级元素设置高度</span><br><span class="line">	给父级元素添加浮动</span><br><span class="line">	给父级元素设置overflow属性为hidden或者auto</span><br><span class="line">	使用after伪元素清除</span><br><span class="line">		.clearfix:after &#123;</span><br><span class="line">    		/*伪元素是行内元素 正常浏览器清除浮动方法*/</span><br><span class="line">    		content: &quot;&quot;;</span><br><span class="line">    		display: block;</span><br><span class="line">    		height: 0;</span><br><span class="line">    		clear: both;</span><br><span class="line">   		 	visibility: hidden;</span><br><span class="line">		&#125;</span><br><span class="line">		/*ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行*/</span><br><span class="line">		.clearfix &#123;</span><br><span class="line">  			*zoom: 1;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

# CSS3transition 过渡和 animation 动画的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">animation属性类似于transition，他们都是随着时间改变元素的属性值，</span><br><span class="line"></span><br><span class="line">其主要区别在于：</span><br><span class="line">transition需要触发一个事件才会随着时间改变其CSS属性；</span><br><span class="line">animation在不需要触发任何事件的情况下，也可以显式的随时间变化来改变元素CSS属性，达到一种动画的效果</span><br><span class="line"></span><br><span class="line">1）动画不需要事件触发，过渡需要。</span><br><span class="line">2）过渡只有一组（两个：开始-结束） 关键帧，动画可以设置多个。</span><br></pre></td></tr></table></figure>

# 前后端开发中数据是怎么交互的

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">web后端和前端是怎么连接的？</span><br><span class="line"></span><br><span class="line">网站数据处理主要分为三层。</span><br><span class="line">第一层，表示层，这部分可以用HTML代码，CSS/Javascript代码来实现等。</span><br><span class="line">	通过前端代码可以实现网页的布局和设计。这层又可以称为显示层。也就是你用浏览器打开能看到的网页。</span><br><span class="line">第二层，是业务层，这层是负责处理数据的。常用的代码语言有PHP,JSP，Java等。</span><br><span class="line">	通过这些后台处理语言的算法来处理前台传回的数据。必要的时候进行操作数据库，然后把结果返回给前端网页。</span><br><span class="line">第三层，是数据层，这个就是数据库，用来存储数据的。</span><br><span class="line">	通过业务层的操作可以实现增删改数据库的操作。</span><br><span class="line"></span><br><span class="line">在网页上填一个表格然后提交会有以下几种数据传输经过：</span><br><span class="line">①你接触到的是这个网页是属于表示层，这个网页一般由HTML标签结合CSS/JAVASCRIPT来实现的。这时候你要先填入数据。</span><br><span class="line">②然后你按提交触发后台处理机制，这时候数据会传到后台的代码进行处理。这部分代码根据不同网站可以使PHP,JSP，JAVA等。代码根据程序员预设的算法将收到的数据进行处理之后会相应的对数据库进行操作，存储数据等。</span><br><span class="line">③成功操作完数据库之后，业务层的代码会再向表示层也就是显示器端传回一个指令通知你表格填写成功</span><br><span class="line"></span><br><span class="line">从前端向后台传递参数方法</span><br><span class="line"></span><br><span class="line">一、通过表单传递参数</span><br><span class="line">1.前端部分，在前端jsp页面设置form表单，确定需要传递的参数name让用户输入，</span><br><span class="line">  通过点击按钮后submit()提交到后台</span><br><span class="line">2.后台对前端请求的反应，接收数据，处理数据以及返回数据。</span><br><span class="line"></span><br><span class="line">二．通过ajax传递参数（有post和get写法）</span><br><span class="line">1.ajax是如何将前端数据传到后台的</span><br><span class="line">	type: &quot;POST&quot;,//type是ajax的方法</span><br><span class="line">	url : &quot;&lt;%=path%&gt;/resource/usermenus&quot;,//参数url,要把参数传到什么地方</span><br><span class="line">	data : &#123;parentid:parentid,parentpath:parentpath&#125;,//传递什么数据</span><br><span class="line">	success : function(data)&#123;//sucess表示，当数据返回成功后要怎么做，返回的数据存储在data</span><br><span class="line">2.后台对前端请求的反应，接收数据</span><br><span class="line">3.前端接收到后端返回的数据进行处理的</span><br></pre></td></tr></table></figure>

# cookie 的理解

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cookie又叫会话跟踪技术，是由web服务器保存在用户浏览器上的小文本文件，它可以记录用户ID、密码、浏览过的网页、停留的时间等信息。当用户再次来到该网站时，网站通过读取cookie，得知用户相关信息，就可以做出相应的动作，如在页面显示欢迎用户标语，或者让用户不用输入ID、密码就直接登录等等。如果用户清理了cookie，那么用户曾登录过的网站信息就没有了。</span><br><span class="line"></span><br><span class="line">优点</span><br><span class="line">	极高的扩展性和可用性</span><br><span class="line">	通过良好的编程，可以控制保存在cookie中的session对象的大小</span><br><span class="line">	通过加密技术和安全传输技术，减少cookie被破解的可能</span><br><span class="line">	只在cookie中存放不敏感数据，即使被盗也不会有重大的损失</span><br><span class="line">	控制cookie的生命周期，使之不会永久有效。偷盗者可能拿到一个过期的cookie</span><br><span class="line"></span><br><span class="line">缺点</span><br><span class="line">	cookie有数量和长度的限制。每个domain最多有20条cookie，长度不能超过4KB，否则会被裁掉。</span><br><span class="line">	安全性问题。如果cookie被人拦截了，那个人就可以取得所有的session信息。即使加密也于事无补，因为拦截者不需要知道cookie的意义，他只需要原样转发就能达到目的。</span><br><span class="line">	有些状态不可能保存在客户端。</span><br></pre></td></tr></table></figure>

# 从用户打开网页到浏览器渲染一共完成经历了哪些过程

- 第一步输入网址,后端发送到 DNS 服务器，与 web 服务器进行 TCP 链接，浏览器向 web 服务器发送 http 请求，然后 web 服务器响应请求。然后返回指定的 url 数据，如果是错误信息，跳转到错误页面，然后浏览器下载 web 服务器返回的数据，解析 html 源文件，最终生成 dom 树，然后解析 css 和 js,然后渲染结束。

# 输入网址到呈现网页发生的过程

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">a.域名解析</span><br><span class="line">	DNS解析，每一台连上网计算机都有一个唯一标识即它的IP地址，DNS解析就将输入的网址解析成IP地址。</span><br><span class="line">DNS解析是一个递归查询的过程，例如要解析“www.baidu.com”时，过程如下：</span><br><span class="line">	在本地域名服务器中查询IP地址，未找到域名；</span><br><span class="line">	本地域名服务器会向根域名服务器发送请求，未找到域名；</span><br><span class="line">	本地域名服务器向.com顶级域名服务器发送请求，未找到域名；</span><br><span class="line">	本地域名服务器向.baidu.com域名服务器发送请求，找到该域名，将相应的IP返回给本地域名服务器；</span><br><span class="line"></span><br><span class="line">b.发起TCP连接的三次握手</span><br><span class="line">	HTTP协议是使用TCP协议作为其传输层协议的，在拿到服务器的IP地址后，客户端浏览器会与服务器建立TCP连接，该过程包括三次握手：</span><br><span class="line">	第一次握手：建立连接时，客户端向服务端发送请求报文（SYN）</span><br><span class="line">	第二次握手：服务器收到请求报文后，如同意连接，则向客户端发送确认报文（SYN/ACK）</span><br><span class="line">	第三次握手：客户端收到服务器的确认后，再次向服务器发送确认报文，完成连接（ACK）</span><br><span class="line">三次握手主要是为了防止已经失效的请求报文字段发送给服务器，浪费资源。</span><br><span class="line"></span><br><span class="line">c.建立TCP连接后浏览器发起HTTP请求</span><br><span class="line">	浏览器构建HTTP请求报文，并通过TCP协议传送到服务器的指定端口。HTTP请求报文一共有三个部分：</span><br><span class="line">		报文首部（请求行+各种首部字段+其他）</span><br><span class="line">		空行（它的作用是通过一个空行，告诉服务器请求头部到此为止。）</span><br><span class="line">		报文主体（应被发送的数据）通常并不一定要有报文主体</span><br><span class="line"></span><br><span class="line">d.服务端响应http请求，返回响应报文</span><br><span class="line">HTTP响应报文由四部分组成：响应行、响应头、空行、响应体</span><br><span class="line">响应行</span><br><span class="line">	响应行一般由协议版本、状态码及其描述组成</span><br><span class="line"></span><br><span class="line">响应头</span><br><span class="line">	响应头用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据。</span><br><span class="line">常见的响应头字段含义：</span><br><span class="line"></span><br><span class="line">响应体</span><br><span class="line">响应体就是响应的消息体，如果是纯数据就是返回纯数据，如果请求的是HTML页面，那么返回的就是HTML代码，如果是JS就是JS代码，如此之类。</span><br><span class="line"></span><br><span class="line">e.浏览器页面渲染</span><br><span class="line">　　解析文档构建DOM树</span><br><span class="line">　　构建渲染树</span><br><span class="line">　　布局和绘制渲染树</span><br><span class="line">　　</span><br><span class="line">f.断开TCP连接</span><br><span class="line">	第一次挥手：客户端想分手，发送消息（FIN）给服务器</span><br><span class="line">	第二次挥手：服务器通知客户端已经接受的挥手请求，返回确认消息（ACK），但还没做好分手准备</span><br><span class="line">	第三次挥手：服务器已经做好分手准备，通知客户端（FIN）</span><br><span class="line">	第四次挥手：客户端发送消息给服务器（ACK），确认分手，服务器关闭连接。</span><br></pre></td></tr></table></figure>

# 浏览器渲染原理及流程

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：</span><br><span class="line">   当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。</span><br><span class="line"></span><br><span class="line">2. 将CSS解析成 CSS Rule Tree 。</span><br><span class="line"></span><br><span class="line">3. 根据DOM树和CSSOM来构造 Rendering Tree。</span><br><span class="line">   注意：Rendering Tree 渲染树并不等同于 DOM 树，</span><br><span class="line">        因为一些像Header或display:none的东西就没必要放在渲染树中了。</span><br><span class="line"></span><br><span class="line">4. 有了R        ender Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。</span><br><span class="line">   下一步操作称之为layout，顾名思义就是计算出每个节点在屏幕中的位置。</span><br><span class="line"></span><br><span class="line">5. 再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。</span><br></pre></td></tr></table></figure>

# 浏览器本地存储

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTML5中的Web Storage包含了两种存储方式，sessionStorage和localStorage。</span><br><span class="line"></span><br><span class="line">sessionStorage用于本地存储一个会话中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此，sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。</span><br><span class="line"></span><br><span class="line">localStorage用于持久化的本地存储，除非主动删除数据，否则数据永远不会过期</span><br><span class="line"></span><br><span class="line">首先总的来说，三者都是用于持久化数据存储的手段，都是存储在浏览器端，且同源.</span><br><span class="line"></span><br><span class="line">localStorage和sessionStorage都是Web存储，大小5M左右，完全存储在客户端，它们是因为本地存储数据而存在.</span><br><span class="line"></span><br><span class="line">cookies也是存储在浏览器端的，大小不超过4k，由服务器端存储在客户端。</span><br><span class="line"></span><br><span class="line">localStorage属于永久性存储,数据存储量大,而sessionStorage属于当会话结束的时候，存储的值会被清空，而cookie是通过设置过期时间来存储的。</span><br></pre></td></tr></table></figure>

# cookie,localStorage,sessionStorage 区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">介绍</span><br><span class="line">1.cookie又叫会话跟踪技术，是由web服务器保存在用户浏览器上的小文本文件，它可以记录用户ID、密码、浏览过的网页、停留的时间等信息。当用户再次来到该网站时，网站通过读取cookie，得知用户相关信息,如果用户清理了cookie，那么用户曾登录过的网站信息就没有了。</span><br><span class="line">2.sessionStorage和localStorage是H5新增的本地存储</span><br><span class="line"></span><br><span class="line">区别</span><br><span class="line">1.存储大小的不同</span><br><span class="line">	localStorage的大小一般为5M</span><br><span class="line">	sessionStorage的大小一般为5M</span><br><span class="line">	cookies的大小一般为4K</span><br><span class="line">2.有效期不同：</span><br><span class="line">    localStorage的有效期为永久有效，除非你进行手动删除。</span><br><span class="line">    sessionStorage在当前会话下有效，关闭页面或者浏览器时会被清空。</span><br><span class="line">    cookies在设置的有效之前有效，当超过有效期便会失效。</span><br><span class="line">3.与服务器端的通信</span><br><span class="line">	localStorage不参与服务器端的通信。</span><br><span class="line">	sessionStorage不参与服务器端的通信。</span><br><span class="line">	cookies参与服务器端通信，每次都会携带http的头信息中。（如果使用cookie保存过多数据会带来性能问题）</span><br><span class="line"></span><br><span class="line">应用场景</span><br><span class="line">1.因为考虑到每个 HTTP 请求都会带着 Cookie 的信息，比较常用的一个应用场景就是判断用户是否登录。针对登录过的用户，服务器端会在他登录时往 Cookie 中插入一段加密过的唯一辨识单一用户的辨识码，下次只要读取这个值就可以判断当前用户是否登录啦。曾经还使用 Cookie 来保存用户在电商网站的购物车信息，如今有了 localStorage，现在基本更加方便</span><br><span class="line">2.sessionStorage:</span><br><span class="line">	可以用来统计当前页面元素的点击次数。</span><br><span class="line">3.localStoragese：</span><br><span class="line">	常用于长期登录(判断用户是否已登录),适合长期保存在本地的数据。sessionStorage：敏感账号一次性登录；</span><br><span class="line"></span><br><span class="line">登陆信息用cookie好还是localStorage好？</span><br><span class="line">	1.建议登陆信息用 cookie。即设置过期时间的cookie,看法是 cookie 默认会发送回到后端，</span><br><span class="line">	  这样方便后端读取,而使用localStorage，你需要在每次请求的时候，都手动带上这个信息，</span><br><span class="line">	  这大大增加了开发过程中带来的困难，非常麻烦，而且还要手动维护过期时间。</span><br><span class="line">	2.cookie有时效，而localStorage如果不手动清理则永久保存。</span><br><span class="line">	3.如果要设置关闭网页/标签就失效,请用SessionStorage。 这个类似你设置“不带时间的cookie”。</span><br></pre></td></tr></table></figure>

# hash 值获取方式

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以通过window.location.hash获取hash值</span><br></pre></td></tr></table></figure>

# document.write 和 innerHTML 的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.write会重绘整个页面</span><br><span class="line"></span><br><span class="line">innerHTML重绘页面的一部分</span><br></pre></td></tr></table></figure>

# 进程和线程的区别

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">一个程序至少有一个进程，一个进程至少有一个线程</span><br><span class="line"></span><br><span class="line">线程的划分尺度小于进程，使得多线程程序的并发性高</span><br><span class="line"></span><br><span class="line">进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大提高了程序的运行效率</span><br><span class="line"></span><br><span class="line">每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制</span><br><span class="line"></span><br><span class="line">从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别</span><br></pre></td></tr></table></figure>

# babel 原理

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Babel 是一个通用的多功能 JavaScript 编译器，但与一般编译器不同的是它只是把同种语言的高版本规则转换为低版本规则，而不是输出另一种低级机器可识别的代码，并且在依赖不同的拓展插件下可用于不同形式的静态分析。（静态分析：指在不需要执行代码的前提下对代码进行分析以及相应处理的一个过程，主要应用于语法检查、编译、代码高亮、代码转换、优化、压缩等等）</span><br><span class="line"></span><br><span class="line">babel 做了什么</span><br><span class="line">和编译器类似，babel 的转译过程也分为三个阶段，这三步具体是：</span><br><span class="line"></span><br><span class="line">1.解析 Parse</span><br><span class="line">将代码解析生成抽象语法树( 即AST )，也就是计算机理解我们代码的方式(扩展：一般来说每个 js 引擎都有自己的 AST，比如熟知的 v8，chrome 浏览器会把 js 源码转换为抽象语法树，再进一步转换为字节码或机器代码)，而 babel 则是通过 babylon 实现的 。简单来说就是一个对于 JS 代码的一个编译过程，进行了词法分析与语法分析的过程。</span><br><span class="line">2.转换 Transform</span><br><span class="line">对于 AST 进行变换一系列的操作，babel 接受得到 AST 并通过 babel-traverse 对其进行遍历，在此过程中进行添加、更新及移除等操作。</span><br><span class="line">3.生成 Generate</span><br><span class="line">将变换后的 AST 再转换为 JS 代码, 使用到的模块是 babel-generator。</span><br><span class="line"></span><br><span class="line">而 babel-core 模块则是将三者结合使得对外提供的API做了一个简化。</span><br><span class="line"></span><br><span class="line">此外需要注意的是，babel 只是转译新标准引入的语法，比如ES6箭头函数：而新标准引入的新的原生对象，部分原生对象新增的原型方法，新增的 API 等（Proxy、Set 等）, 这些事不会转译的，需要引入对应的 polyfill 来解决。</span><br></pre></td></tr></table></figure>

# Proxy

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-代理模式（Proxy Pattern），23个经典模式中的一个，又称之为委托模式，就是为目标对象提供了一个代理，这个代理可以控制对目标对象的访问。代理对象可以添加审查和监控功能。</span><br></pre></td></tr></table></figure>

# DVA 工作流程

## dva 中 redux 流程 -SSSSSSSSSSSSSSSSSSSSSSSSSSSSSS

## dva 数据流

- 步骤：
  1. 需要有一个 store 存储数据
  2. store 中的 reducer 初始化 state 并定义 state 修改规则
  3. 通过 dispatch 一个 action 来提交对数据的修改
  4. action 提交到 reducer 函数里，根据 action.type，返回新的 state

1. dva 中的 redux 是放到了一个 models 目录中 dav
2. 关注的方向有两个
   1. models 中的文件
      1. 定义 redux 数据
      2. models 中的每一个文件就是一个数据块
   2. src/index.js 调用 redux 数据块
      1. app.model(require(&#39;./models/example&#39;).default);
   3. 组件中如何来使用 redux

### 总结：cra 的 redux 和 dva 的 redux 有什么区别：

1. cra 的 redux 需要自己配置 dva 的 redux 不需要自己配置

2. cra 的 model 或者 store 类似与 vuex 的公共的仓库 数据方法 谁用谁取
3. dva 中的 connect 只取数据，不取方法,如果要取方法，使用 props.dispatch 来调用数据请求

   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateFromProps</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取数据，然后绑定到App的props</span></span><br><span class="line">  <span class="keyword">return</span> state.home;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchFroProps</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 取方法的</span></span><br><span class="line">  <span class="keyword">return</span> bindActionCreators(actionCreators, dispatch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export default connect(mapStateFromProps,mapDispatchFroProps)(App)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><figcaption><span>dva redux</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//todo 这里书写list的数据块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> services <span class="keyword">from</span> <span class="string">&quot;../services&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">namespace</span>: <span class="string">&quot;list&quot;</span>, <span class="comment">// 命名空间</span></span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="comment">//! state</span></span><br><span class="line">    <span class="attr">list</span>: [],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">effects</span>: &#123;</span><br><span class="line">    <span class="comment">//!  effects 就是我们redux的构成部分之一的 actionCreators</span></span><br><span class="line">    <span class="comment">//todo 异步数据请求（call来调用）    创建action,发送action（put来送送action）</span></span><br><span class="line">    <span class="comment">//todo effects中存放的是 generator函数</span></span><br><span class="line">    <span class="comment">// *getList (action,effects) &#123;  //? effects中有很多函数，我们要的只是call,put</span></span><br><span class="line">    <span class="comment">// *getList (action,&#123;call,put&#125;) &#123;</span></span><br><span class="line">    *<span class="function"><span class="title">getList</span>(<span class="params">&#123; payload: &#123; cid &#125; &#125;, &#123; call, put &#125;</span>)</span> &#123;</span><br><span class="line">      <span class="comment">//!  redux-saga实现的</span></span><br><span class="line">      <span class="comment">/* </span></span><br><span class="line"><span class="comment">           action 表示组件传递过来的参数 包括了type 而我们只要payload</span></span><br><span class="line"><span class="comment">           effects表示动作触发函数对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">      <span class="comment">//! yield  是generator函数的关键字，每一个yield后面跟着一个任务，前一个任务执行结束，后一个任务才可以进行</span></span><br><span class="line">      <span class="keyword">const</span> r = <span class="keyword">yield</span> call(services.getHotList, cid);</span><br><span class="line">      <span class="keyword">yield</span> put(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;GET_LIST&quot;</span>,</span><br><span class="line">        <span class="attr">payload</span>: r,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">reducers</span>: &#123;</span><br><span class="line">    <span class="comment">//! reducers 也是redux构成部分之一，它用于修改数据</span></span><br><span class="line">    <span class="function"><span class="title">GET_LIST</span>(<span class="params">state, action</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(action.payload.data.content);</span><br><span class="line">      <span class="comment">// ...state   list:[]</span></span><br><span class="line">      <span class="comment">//...&#123;list:action.payload.data.content&#125;   list:[&#123;&#125;]</span></span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, ...&#123; <span class="attr">list</span>: action.payload.data.content &#125; &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">subscriptions</span>: &#123;</span><br><span class="line">    <span class="comment">//todo? 异步操作 日期 通信连接</span></span><br><span class="line">    <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&quot;dva&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&quot;./IndexPage.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IndexPage</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// dispatch 就是用于激活redux中effects中的方法的</span></span><br><span class="line">    props.dispatch(&#123;</span><br><span class="line">      <span class="comment">// type: &#x27;数据块namespace名称/effects中的方法名&#x27;</span></span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;list/getList&quot;</span>,</span><br><span class="line">      <span class="attr">payload</span>: &#123; <span class="attr">cid</span>: <span class="number">17</span> &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.normal&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="xml">          props.history.push(&quot;/upload&quot;);</span></span><br><span class="line"><span class="xml">        &#125;&#125;</span></span><br><span class="line"><span class="xml">      &gt;</span></span><br><span class="line"><span class="xml">        &#123;&quot; &quot;&#125;</span></span><br><span class="line"><span class="xml">        去upload&#123;&quot; &quot;&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;props.list.map((v) =&gt; (</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;v.id&#125;</span>&gt;</span> &#123;v.d_title&#125; <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        ))&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IndexPage.propTypes = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(<span class="function">(<span class="params">state</span>) =&gt;</span> state.list)(IndexPage); <span class="comment">//connect 中取对应的数据模块</span></span><br></pre></td></tr></table></figure>

# connect 函数

- connect 函数返回值的高阶组件中返回的类组件给了一个名字 叫做 容器(解耦)组件
- 我们这里自定义的 App 组件给了名字 UI 组件
- connect 函数最终实现了帮助 UI 组件获取数据和方法的功能

# 计算当前日期

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算当前日期</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getDate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">let</span> year = date.getFullYear();</span><br><span class="line">  <span class="keyword">let</span> month = date.getMonth() + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> day = date.getDate();</span><br><span class="line">  <span class="keyword">let</span> week = date.getDay();</span><br><span class="line">  <span class="keyword">let</span> weekList = [<span class="string">&quot;日&quot;</span>, <span class="string">&quot;一&quot;</span>, <span class="string">&quot;二&quot;</span>, <span class="string">&quot;三&quot;</span>, <span class="string">&quot;四&quot;</span>, <span class="string">&quot;五&quot;</span>, <span class="string">&quot;六&quot;</span>];</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">`<span class="subst">$&#123;year&#125;</span>年<span class="subst">$&#123;month&#125;</span>月<span class="subst">$&#123;day&#125;</span>日      星期<span class="subst">$&#123;weekList[week]&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

# 防抖 节流

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.函数的防抖</span></span><br><span class="line"><span class="comment">//函数防抖：当事件被触发一段时间后再执行回调，如果在这段时间内事件又被触发，则重新计时。</span></span><br><span class="line"><span class="keyword">const</span> oInput = <span class="built_in">document</span>.querySelector(<span class="string">&quot;input&quot;</span>);</span><br><span class="line">oInput.addEventListener(<span class="string">&quot;input&quot;</span>, debounce(fn, <span class="number">500</span>), <span class="literal">false</span>); <span class="comment">//第二个参数是函数体或者函数名，不能是函数调用。</span></span><br><span class="line">oInput.addEventListener(<span class="string">&quot;input&quot;</span>, fn, <span class="literal">false</span>); <span class="comment">//第二个参数是函数体或者函数名，不能是函数调用。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">//原先是事件处理函数 指向oninput 因为封装了 在定时器里面指向window</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//闭包  防抖的函数</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>; <span class="comment">//确保刚开始没有定时器的存在</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//arguments存在函数内部</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">//this返回是事件处理函数 指向oninput</span></span><br><span class="line">    <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//箭头函数解决arguments问题。箭头函数没有arguments</span></span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">//arguments表示return后面的函数。但是此函数可能需要传递多个参数，为什么要加arguments，因为我们要事件对象e</span></span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面的封装会有两个问题要解决</span></span><br><span class="line"><span class="comment">//  1. 获取事件对象上面获取不到事件对象了</span></span><br><span class="line"><span class="comment">//  2. 解决this问题   事件处理函数第一个参数就是e arguments[0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.函数的节流</span></span><br><span class="line"><span class="comment">// 函数节流（throttle）：指定时间间隔内，若事件被多次触发，只会执行一次</span></span><br><span class="line"><span class="keyword">const</span> oInput = <span class="built_in">document</span>.querySelector(<span class="string">&quot;input&quot;</span>);</span><br><span class="line">oInput.oninput = throttle(fn, <span class="number">2000</span>);</span><br><span class="line">函数体;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;我被触发了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据题目的意思，大于2000毫秒执行一次，通过时间差。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> startTime = <span class="number">0</span>;</span><br><span class="line">  初始时间;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime(); <span class="comment">//获取当前时间的毫秒数 1970.1.1离当前时间的毫秒数</span></span><br><span class="line">    <span class="built_in">console</span>.log(currentTime - startTime);</span><br><span class="line">    <span class="keyword">if</span> (currentTime - startTime &gt; delay) &#123;</span><br><span class="line">      <span class="comment">//第一次的事件时间和第二次事件的时间&gt;2000，触发事件</span></span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>); <span class="comment">//触发事件  不断计算之后才触发</span></span><br><span class="line">      startTime = currentTime; <span class="comment">//当前的时间赋值给上一次的时间</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">callback, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>; <span class="comment">// 计时器</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arg = <span class="built_in">arguments</span>; <span class="comment">// 获得实参</span></span><br><span class="line">    <span class="built_in">console</span>.log(arg);</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer); <span class="comment">// 如果有计时器就清除计时器</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(</span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        callback.apply(<span class="built_in">this</span>, arg); <span class="comment">// 调用回调 传入实参  需要事件对象</span></span><br><span class="line">      &#125;.bind(<span class="built_in">this</span>),</span><br><span class="line">      wait</span><br><span class="line">    ); <span class="comment">// bind(this)  是修正 事件中的this指向</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

# 自己的防抖

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const search = document.querySelector(&#x27;#search&#x27;);</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//这个函数一开始执行频率很高，减少一些，封装一个函数来执行fn函数达到减少执行次数的目的。</span></span><br><span class="line">  <span class="comment">// console.log(&#x27;事件触发了&#x27;);</span></span><br><span class="line">  <span class="comment">// console.log(this); //这里指向了当前操作的元素</span></span><br><span class="line">  <span class="built_in">console</span>.log(e, <span class="string">&quot;e&quot;</span>); <span class="comment">//正常情况这里无法直接获取事件对象，通过事件处理函数(debounce返回值)传参。</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>, <span class="string">&quot;fn&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//事件处理函数,无法确认事件处理函数有多少参数的时候。</span></span><br><span class="line">    <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>, <span class="string">&quot;debounce&quot;</span>);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(this,&#x27;thi1111s&#x27;);</span></span><br><span class="line">      <span class="comment">// fn.apply(this)</span></span><br><span class="line">      <span class="comment">// this:父级的this，父级的this指向当前的操作的元素对象</span></span><br><span class="line">      <span class="comment">// fn.apply(this, arguments[0]);   //call也能，但是call第二个参数开始是函数本身的参数，这里不知道函数本身的参数</span></span><br><span class="line">      <span class="comment">// apply第二个参数是数组，数组项就是函数本身的参数。</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">search.oninput = debounce(fn); <span class="comment">//debounce结果是函数体  封装debounce函数</span></span><br><span class="line"><span class="comment">// search.oninput = fn;</span></span><br><span class="line"><span class="comment">// function abc() &#123;</span></span><br><span class="line"><span class="comment">//     console.log(arguments.length); //22</span></span><br><span class="line"><span class="comment">//     console.log(arguments[0]); //100</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// abc(100, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 41, 2, 3, 41, 2, 3, 4);</span></span><br><span class="line"><span class="comment">// function abc() &#123;</span></span><br><span class="line"><span class="comment">//     console.log(arguments.length);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// abc();//普通调用 长度0</span></span><br><span class="line"><span class="comment">// document.onclick = abc; //事件下调用，长度1</span></span><br></pre></td></tr></table></figure>

# koa2 express

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在koa中，一切的流程都是中间件，数据流向遵循洋葱模型，先入后出，是按照类似堆栈的方式组织和执行的，koa-compose是理解koa中间件的关键，在koa中间件中会深入分析。</span><br><span class="line">  koa2与koa1的最大区别是koa2实现异步是通过async/awaite，koa1实现异步是通过generator/yield，而express实现异步是通过回调函数的方式。</span><br><span class="line">  koa2与express 提供的API大致相同，express是大而全，内置了大多数的中间件，更让人省心，koa2不绑定任何的框架，干净简洁，小而精，更容易实现定制化，扩展性好。</span><br><span class="line">  express是没有提供ctx来提供上下流服务，需要更多的手动处理，express本身是不支持洋葱模型的数据流入流出能力的，需要引入其他的插件。</span><br><span class="line"></span><br><span class="line">  koa的数据流入流出，next()后，会进入下一个中间件并执行，然后从最后一个中间件反向执行。</span><br></pre></td></tr></table></figure>

## 为什么 React 用 hooks 为什么使用 hook

不必写 class 组件就可以用 state 和其他的 React 特性；
为了让函数组件拥有类组件的功能。
原因
比如 useState、（useReducer） 状态定义
比如 useEffect、useLayoutEffect 实现生命周期功能,代码更简洁
比如 useRef useImperativeHandle 替代了类组件的 Ref
比如为了优化函数组件，useMemo、useCallback

    函数组件添加新的方法,如
        useDebugValue显示自定义hook，自己添加hook类名
        自定义hooks来复用状态

优点 4 点

1.  让函数组件可以定义状态
    让函数组件可以使用生命周期、监听数据
    让函数组件可以有 Ref 的功能（父组件获取子组件）
    优化函数组件 useMemo、useCallback
    自定义 hooks 来复用状态,
    代码量比类组件更少，更清爽。 2.使用规则 2 点
    不要在循环，条件或嵌套函数中调用 Hook
    只在函数组件中使用 Hooks

## hooks

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hooks不能嵌套使用 写在函数的最上方</span><br><span class="line">字符串处理</span><br><span class="line">日期处理,补零，货币,大小写,小数位数保留</span><br><span class="line">useRequset</span><br><span class="line">数据类型验证</span><br><span class="line">界面的唯一性处理</span><br></pre></td></tr></table></figure>

## React 中 keys 的作用是什么？

Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。
在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在
React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移
动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来
判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要
性。

## 调用 setState 之后发生了什么？

在代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合
并，然后触发所谓的调和过程（Reconciliation）。经过调和过程，React 会以相对
高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面。在
React 会自动计算出新的树与老树的节点差异，然后根据
差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪
些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲
染。

## react 生命周期函数

• 初始化阶段：
o getDefaultProps:获取实例的默认属性
o getInitialState:获取每个实例的初始化状态
o componentWillMount：组件即将被装载、渲染到页面上
o render:组件在这里生成虚拟的 DOM 节点
o componentDidMount:组件真正在被装载之后
• 运行中状态：
o componentWillReceiveProps:组件将要接收到属性的时候调用
o shouldComponentUpdate:组件接受到新属性或者新状态的时候（可
以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不
会被继续执行了）
o componentWillUpdate:组件即将更新不能修改属性和状态
o render:组件重新描绘
o componentDidUpdate:组件已经更新
• 销毁阶段：
o componentWillUnmount:组件即将销毁
shouldComponentUpdate 是做什么的，（react 性能优
化是哪个周期函数？）
shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。

## 为什么虚拟 dom 会提高性能?(必考)

虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没
有必要的 dom 操作，从而提高性能。用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。

## React 中 refs 的作用是什么？

Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可
以为元素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会
作为回调函数的第一个参数返回：
上述代码中的 input 域包含了一个 ref 属性，该属性声明的回调函数会接收 input 对
应的 DOM 元素，我们将其绑定到 this 指针以便在其他的类函数中使用。另外值得
一提的是，refs 并不是类组件的专属，函数式组件同样能够利用闭包暂存其值：
如果你创建了类似于下面的 Twitter 元素，那么它相
关的类定义是啥样子的？
如果你还不熟悉回调渲染模式（Render Callback Pattern），这个代码可能看起来有
点怪。这种模式中，组件会接收某个函数作为其子组件，然后在渲染函数中以
props.children 进行调用： 这种模式的优势在于将父组件与子组件解耦和，父组件可以直接访问子组件的内部状态而不需要再通过 Props 传递，这样父组件能够更为方便地控制子组件展示的 UI
界面。譬如产品经理让我们将原本展示的 Badge 替换为 Profile，我们可以轻易地修
改下回调函数即可：

## 展示组件 (Presentational component) 和容器组件(Container component)之间有何不同

• 展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并
且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关
心 UI 状态而不是数据的状态。
• 容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容
器组件提供数据和行为(behavior)，它们会调用 Flux actions，并将其作为回
调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数
据源。



## (组件的)状态(state)和属性(props)之间有何不同

• State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随
着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。
• Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，
并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的
props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅
是数据--回调函数也可以通过 props 传递。

## 何为受控组件(controlled component)

在 HTML 中，类似 &lt;input&gt;, &lt;textarea&gt; 和 &lt;select&gt; 这样的表单元素会维护自身
的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随
表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中
追踪输入的值，并且每次调用回调函数时，如 onChange 会更新 state，重新渲染组
件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称
为&quot;受控元素&quot;。

## 何为高阶组件(higher order component)

高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、
逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和
简单的组合，HOC 最好的方式是共享 React 组件之间的行为。如果你发现你在不
同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的
HOC。



## 为什么建议传递给 setState 的参数是一个 callback 而不是一个对象

因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个
state。

## 除了在构造函数中绑定 this，还有其它方式吗

你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react￾app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都
会创建一个新的回调。

## (在构造函数中)调用 super(props) 的目的是什么

在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在
constructor 中调用 super()。传递 props 给 super() 的原因则是便于(在子类中)能在
constructor 访问 this.props。

## 应该在 React 组件的何处发起 Ajax 请求

在 React 组件中，应该在 componentDidMount 中发起网络请求。这个方法会在组
件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重
要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味
着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在
`componentDidMount 中发起网络请求将保证这有一个组件可以更新了。

## 描述事件在 React 中的处理方式。

为了解决跨浏览器兼容性问题，您的 React 中的事件处理程序将传递
SyntheticEvent 的实例，它是 React 的浏览器本机事件的跨浏览器包装器。
这些 SyntheticEvent 与您习惯的原生事件具有相同的接口，除了它们在所有浏览器
中都兼容。有趣的是，React 实际上并没有将事件附加到子节点本身。React 将使
用单个事件监听器监听顶层的所有事件。这对于性能是有好处的，这也意味着在更
新 DOM 时，React 不需要担心跟踪事件监听器。

## createElement 和 cloneElement 有什么区别？

React.createElement():JSX 语法就是用 React.createElement()来构建 React 元素的。
它接受三个参数，第一个参数可以是一个标签名。如 div、span，或者 React 组
件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。
React.cloneElement()与 React.createElement()相似，不同的是它传入的第一个参数
是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入
到返回的新元素中，而就的子元素奖杯替换。

## React 中有三种构建组件的方式

React.createClass()、ES6 class 和无状态函数。

## react 组件的划分业务组件技术组件？

• 根据组件的职责通常把组件分为 UI 组件和容器组件。
• UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。
• 两者通过 React-Redux 提供 connect 方法联系起来。
简述 flux 思想
Flux 的最大特点，就是数据的&quot;单向流动&quot;。

1. 用户访问 View
2. View 发出用户的 Action
3. Dispatcher 收到 Action，要求 Store 进行相应的更新
4. Store 更新后，发出一个&quot;change&quot;事件
5. View 收到&quot;change&quot;事件后，更新页面

## React 项目用过什么脚手架（本题是开放性题目）

creat-react-app Yeoman 等
了解 redux 么，说一下 redux 把 • redux 是一个应用数据流框架，主要是解决了组件间状态共享的问题，原理是集中式管理，主要有三个核心方法，action，store，reducer，工作流程是
view 调用 store 的 dispatch 接收 action 传入 store，reducer 进行 state 操
作，view 通过 store 提供的 getState 获取最新的数据，flux 也是用来进行数
据操作的，有四个组成部分 action，dispatch，view，store，工作流程是
view 发出一个 action，派发器接收 action，让 store 进行数据更新，更新完
成以后 store 发出 change，view 接受 change 更新视图。Redux 和 Flux 很
像。主要区别在于 Flux 有多个可以改变应用状态的 store，在 Flux 中
dispatcher 被用来传递数据到注册的回调事件，但是在 redux 中只能定义一
个可更新状态的 store，redux 把 store 和 Dispatcher 合并,结构更加简单清晰
• 新增 state,对状态的管理更加明确，通过 redux，流程更加规范了，减少手
动编码量，提高了编码效率，同时缺点时当数据更新时有时候组件不需
要，但是也要重新绘制，有些影响效率。一般情况下，我们在构建多交
互，多数据流的复杂项目应用时才会使用它们

## redux 有什么缺点

• 一个组件所需要的数据，必须由父组件传过来 Provider，而不能像 flux 中直接从
store 取。
• 当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还
是会重新 render，可能会有效率影响，或者需要写复杂的 shouldComponentUpdate 进行判断。

## setState 原理

setState -- 入队列 -- 出队列 -- 清空队列
定义一个数组，每次执行时模拟数组的 push 方法将 state 存进数组中
渲染函数取数组中的最后一个值 清空数组
//2. 同步/异步原理

setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的 callback 拿到更新后的结果。

setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和 setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。

SetState
1.#作用：用于修改 state
2.#参数： 两个参数
第一个用来修改数据 - 第一个参数如果是对象 不合并 是函数才合并
第二个用来获取修改后的最新数据

## redux 流程 redux 的原理

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">用createStore创建一个store,创建一个reducers,然后定义一个状态,然后reducres返回一个新状态给store,然后再在入口文件中利用Provider绑定store来进行数据通信,在组件中把store里的数据取出来,在执行actionCreators里的方法,生成action,发送action,给了reducers,然后reducers通过类型的判断,判断action里的type,看是哪个动作,然后去做对应的数据修改</span><br><span class="line"></span><br><span class="line">redux组成</span><br><span class="line">	state  :用来存储数据和数据管理的、更新视图</span><br><span class="line">	reducer:是一个纯函数，接收旧 state 和 action，根据不同的 Action 做出不同的操作并返回新的 state</span><br><span class="line">	actions:发送动作给reducer,reducer接收动作，判断动作类型修改数据，修改事件后，组件重新做redux事件的订阅</span><br><span class="line"></span><br><span class="line">Redux三大原则</span><br><span class="line">单一数据源:</span><br><span class="line">	整个应用的 state 被存储在一个 Object tree 中，且只存在于唯一的Store中</span><br><span class="line"></span><br><span class="line">state 是只读的:</span><br><span class="line">	唯一改变 state 的方法就是触发 action，action 是一个用于描述发生事件的普通对象，视图部分只需要表达想要修改的意图，所有修改都会被集中化处理。</span><br><span class="line"></span><br><span class="line">状态的改变通过纯函数来完成:</span><br><span class="line">	Redux使用纯函数方式来执行状态的修改，Action表明了修改状态值的意图，而真正执行状态修改的则是Reducer。且Reducer必须是一个纯函数，当Reducer接收到Action时，Action并不能直接修改State的值，而是通过创建一个新的状态对象来返回修改的状态。</span><br></pre></td></tr></table></figure>

## react-router(路由)原理

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">react-router依赖基础 - history</span><br><span class="line"></span><br><span class="line">history是一个独立的第三方js库，可以用来兼容在不同浏览器、不同环境下对历史记录的管理</span><br><span class="line"></span><br><span class="line">老浏览器的history:</span><br><span class="line">	主要通过hash来实现，对应createHashHistory</span><br><span class="line">高版本浏览器:</span><br><span class="line">	通过html5里面的history，对应createBrowserHistory</span><br><span class="line">node环境下:                         (不弱惹)</span><br><span class="line">	主要存储在历史记录memeory里面，对应createMemoryHistory</span><br><span class="line">抽象了一个公共的文件createHistory:</span><br><span class="line">	此时的location跟浏览器原生的location是不相同的，最大的区别就在于里面多了key字段，</span><br><span class="line">	history内部通过key来进行location的操作</span><br><span class="line"></span><br><span class="line">原理:</span><br><span class="line">1.执行URL前进</span><br><span class="line">	createBrowserHistory: pushState、replaceState</span><br><span class="line">	createHashHistory: location.hash=*** location.replace()</span><br><span class="line">	createMemoryHistory: 在内存中进行历史记录的存储</span><br><span class="line">1.检测URL回退</span><br><span class="line">	createBrowserHistory: popstate</span><br><span class="line">	createHashHistory: hashchange</span><br><span class="line">	createMemoryHistory: 因为是在内存中操作，跟浏览器没有关系，不涉及UI层面的事情，所以可以直接进行历史信息的回退</span><br><span class="line">1.state的存储</span><br><span class="line">	为了维护state的状态，将其存储在sessionStorage里面:</span><br><span class="line">	基本原理:实现URL与UI可视化界面的同步。其中在react-router中，URL对应Location对象，而UI是由react components来决定的，这样就转变成location与components之间的同步问题。</span><br><span class="line"></span><br><span class="line">在react-router中最主要的component是Router、RouterContext、Link，history库起到了中间桥梁的作用</span><br><span class="line"></span><br><span class="line">安装react-router-dom</span><br><span class="line">	Link组件用于点击链接跳转其他页面，没有路由激活</span><br><span class="line">	NavLink 用于有路由激活效果的s</span><br></pre></td></tr></table></figure>

# 去重

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;你是&quot;</span>, <span class="number">20</span>, <span class="number">520</span>, <span class="number">520</span>, <span class="number">20</span>, <span class="number">100</span>, <span class="string">&quot;大帅哥&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> newarr = arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(newarr);</span><br><span class="line"><span class="built_in">console</span>.log(...new <span class="built_in">Set</span>(newarr));</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组去重。</span></span><br><span class="line"><span class="comment">//3.filter()对数组中的每一项运行给定函数，返回该函数结果为 true 的项组成的数组。</span></span><br><span class="line"><span class="comment">//过滤的意思，返回的是一个数组</span></span><br><span class="line"><span class="comment">// var arr = [1, 2, 3, 4, 1, 2, 3, 4];</span></span><br><span class="line"><span class="comment">// var result = arr.filter(function(value, index, array) &#123;</span></span><br><span class="line"><span class="comment">//     // console.log(index); //每一个数组项的索引位置。就是0-7个索引</span></span><br><span class="line"><span class="comment">//     console.log(arr.indexOf(value)); //当前value在数组中第一次出现的位置。</span></span><br><span class="line"><span class="comment">//     return array.indexOf(value) === index;</span></span><br><span class="line"><span class="comment">//     //如果满足此条件，证明当前的value是第一次出现，绝对不会第二次出现。</span></span><br><span class="line"><span class="comment">//     //每个值进来都会IndexOf,后面的1234进来indexof没有设置点，永远寻找到前面的1234</span></span><br><span class="line"><span class="comment">//     //这个时候后面的索引index是4567,所以不会满足条件，结果为false.</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"><span class="comment">// console.log(result);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var arr = [2, 5, 8, 6, 9, 8, 5, 2, 6, 9, ];</span></span><br><span class="line"><span class="comment">// var newarr = [];</span></span><br><span class="line"><span class="comment">//思路：</span></span><br><span class="line"><span class="comment">//如果待去重的数组项在新的数组中不存在，添加到新数组。  一.位置方法--indexOf()  lastIndexOf()返回要查找的项在数组中的索引位置，没找到的情况下返回-1。</span></span><br><span class="line"><span class="comment">//第一种用indexOf如果等于-1就是不存在来做</span></span><br><span class="line"><span class="comment">// for (var i = 0; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//     if (newarr.indexOf(arr[i]) === -1) &#123; //这是满足条件，不存在</span></span><br><span class="line"><span class="comment">//         newarr.push(arr[i]);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var arr = [12, 12, 6, 6, 6];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function isArrRepeat(arr) &#123;</span></span><br><span class="line"><span class="comment">//     // var newarr = arr.sort();</span></span><br><span class="line"><span class="comment">//     // console.log(newarr);</span></span><br><span class="line"><span class="comment">//     for (i = 1; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//         if (arr[i] !== arr[i - 1]) &#123;</span></span><br><span class="line"><span class="comment">//             arr.push(arr[i]);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="comment">// isArrRepeat(arr);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//includes这是包含，如果包含，就不会进去了，所以取反，让他不包含才及进去</span></span><br><span class="line"><span class="comment">// var arr = [2, 5, 8, 6, 9, 8, 5, 2, 6, 9, ];</span></span><br><span class="line"><span class="comment">// var newarr = [];</span></span><br><span class="line"><span class="comment">// for (var i = 1; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//     if (!newarr.includes(arr[i])) &#123; //这是满足条件，不存在</span></span><br><span class="line"><span class="comment">//         newarr.push(arr[i]);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// console.log(newarr);</span></span><br><span class="line"><span class="comment">// console.log(newarr.sort());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.数组去重。</span></span><br><span class="line"><span class="comment">// 去重+排序</span></span><br><span class="line"><span class="comment">// var arr = [12, 5, 6, 100, 12, 5, 6, 6, 6, 100];</span></span><br><span class="line"><span class="comment">// arr = arr.sort(function(a, b) &#123;</span></span><br><span class="line"><span class="comment">//     return a - b;</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"><span class="comment">// console.log(arr); // [5, 5, 6, 6, 6, 6, 12, 12, 100, 100]</span></span><br><span class="line"><span class="comment">// var newarr = [arr[0]];   //这里要特别注意</span></span><br><span class="line"><span class="comment">// // 比较后一位和前一位是否相等。 不相等才追加到新数组</span></span><br><span class="line"><span class="comment">// for (i = 1; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//     if (arr[i] !== arr[i - 1]) &#123;</span></span><br><span class="line"><span class="comment">//         newarr.push(arr[i]);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// console.log(newarr);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//去重+对象+排序</span></span><br><span class="line"><span class="comment">//利用数组的值作为空对象的属性名,注意原先里面就没有值undefined;</span></span><br><span class="line"><span class="comment">//属性名要给他一个属性值</span></span><br><span class="line"><span class="comment">// var arr = [12, 12, 5, 5, 6, 100, 12, 5, 6, 6, 6, 100]; //数组的值都有一个属性</span></span><br><span class="line"><span class="comment">// var obj = &#123;&#125; // 准备空对象</span></span><br><span class="line"><span class="comment">// var newarr = [];</span></span><br><span class="line"><span class="comment">// for (i = 0; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//     if (!obj[arr[i]]) &#123; //注意不是obj的[i]//注意原先里面就没有值undefined;</span></span><br><span class="line"><span class="comment">//         obj[arr[i]] = &#x27;这是一个属性名属性值&#x27;;</span></span><br><span class="line"><span class="comment">//         newarr.push(arr[i]);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// console.log(newarr); //12 5 6 100</span></span><br><span class="line"><span class="comment">// console.log(newarr.sort(function(a, b) &#123;</span></span><br><span class="line"><span class="comment">//     return a - b;</span></span><br><span class="line"><span class="comment">// &#125;)); //5 6 12 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var arr = [12, 12, 5, 6, 100, 12, 5, 6, 6, 6, 100, 500, 500];</span></span><br><span class="line"><span class="comment">// //标记法</span></span><br><span class="line"><span class="comment">// var newarr = []; //如果arr里面的值在新数组里面存在，就改变标记</span></span><br><span class="line"><span class="comment">// for (i = 0; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//     var flag = 1;</span></span><br><span class="line"><span class="comment">//     //入口标记</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     //检测站</span></span><br><span class="line"><span class="comment">//     for (j = 0; j &lt; newarr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">//         if (arr[i] === newarr[j]) &#123;</span></span><br><span class="line"><span class="comment">//             flag = 2; //存在相等，改变标记</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     //出口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     if (flag === 1) &#123;</span></span><br><span class="line"><span class="comment">//         newarr.push(arr[i]);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// console.log(newarr);  // [12, 5, 6, 100, 500]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写函数norepeat(arr) 将数组的重复元素去掉 - splice(改变原数组)</span></span><br><span class="line"><span class="comment">// var arr = [12, 12, 5, 6, 100, 12, 5, 6, 6, 6, 100, 500, 500];</span></span><br><span class="line"><span class="comment">// //思路：如果前后相等，就去掉他</span></span><br><span class="line"><span class="comment">// var arr1 = arr.sort(function(a, b) &#123;</span></span><br><span class="line"><span class="comment">//     return a - b;</span></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"><span class="comment">// console.log(arr1); // [5, 5, 6, 6, 6, 6, 12, 12, 12, 100, 100, 500, 500]</span></span><br><span class="line"><span class="comment">// for (i = 0; i &lt; arr1.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//     for (j = i + 1; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">//         if (arr1[i] === arr1[j]) &#123;</span></span><br><span class="line"><span class="comment">//             arr1.splice(j, 1)</span></span><br><span class="line"><span class="comment">//             j--;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// console.log(arr1);</span></span><br></pre></td></tr></table></figure>

## token 和 axios 请求拦截器

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">token;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * axios拦截器/比如：关卡</span></span><br><span class="line"><span class="comment"> * 请求拦截</span></span><br><span class="line"><span class="comment"> * 响应拦截</span></span><br><span class="line"><span class="comment"> * axios拦截器应用场景</span></span><br><span class="line"><span class="comment"> * 统一携带token</span></span><br><span class="line"><span class="comment"> * 什么是token ?</span></span><br><span class="line"><span class="comment"> * token 我们也称之为 令牌</span></span><br><span class="line"><span class="comment"> * 举例： 工牌</span></span><br><span class="line"><span class="comment"> * token这个东西是一个加密字符串</span></span><br><span class="line"><span class="comment"> * 1.前端可以通过node.js来做</span></span><br><span class="line"><span class="comment"> * 2.后端也可以做，比如java/php/python,一般都是这个后端做</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ins = axios.create(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&quot;http://59.110.226.77:5000/api/private/v1/&quot;</span>, <span class="comment">//统一基准地址</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">20000</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 设置请求拦截器</span></span><br><span class="line">ins.interceptors.request.use(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//config  就是请求的配置</span></span><br><span class="line">    <span class="comment">//业务场景： 统一携带token令牌</span></span><br><span class="line">    config.headers.common[<span class="string">&quot;Authorization&quot;</span>] = cookie.get(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 错误处理的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 设置响应拦截器</span></span><br><span class="line">ins.interceptors.response.use(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//res就是数据请求的结果</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;res&quot;</span>, res);</span><br><span class="line">    <span class="comment">// 业务场景： 数据格式化处理： 数组扁平化、数组去重、数组排序，后端给的数据不理想</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

## 为什么要用 mock 模拟数据

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 为什么要Mock数据呢？</span><br><span class="line">   1. 前后端分离开发，在后端接口还没有写好时，我们需要模拟数据来继续项目</span><br><span class="line">2. 自己手写一个json文件    最不可取的</span><br><span class="line">3. 通过mock.js这个库来生成模拟数据</span><br><span class="line">   1. fs写入json文件</span><br><span class="line">   2. 第三方网站  https://www.fastmock.site/#/</span><br><span class="line">   3. 经验： 直接拿参考网站的</span><br></pre></td></tr></table></figure>



## MVC 与 MVVM MVP

1. 什么项目现在流行用框架呢？

1. 前端框架 都是 jq 替代方案
1. 前端框架比 jq 小 比如： vue.js 20 多 kb jq: 100-200kb
1. jq 没有使用模块化开发
1. jq 在大量的做 DOM 操作，而前端框架它是使用数据来控制视图，我们操作数据， 前端框架性能更好
1. jq 没有生态系统，但是前端框架有
   - 生态系统： 比如： 小米： 手机

## 2. 前端框架是如何产生的？

1. 如果我们只是用 jq，那么相当于我们将一个项目看成一个完整的部分，比喻成一个人，那么这个人就是啥都要做，这个人身上的负担太重
2. 前端引入了后端的一个架构思维： MVC
   - M model 用来管数据
   - V view 视图
   - C Controller 控制器 用来管逻辑
3. MVC
   - M model 用来管数据
   - V view 视图
   - C Controller 控制器 用来管逻辑
4. MVP
   - M model 用来管数据
   - V view 视图
   - p presenter 提供者 中间人
5. MVVM ---- 双向数据绑定: 数据改变，视图响应，视图改变，数据也自动改变
   - M model 用来管数据
   - V view 视图
   - VM ViewModel 视图模型
     - vm 是偏向于 V

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">一、对于 MVVM 的理解？</span><br><span class="line">MVVM 是 Model-View-ViewModel 的缩写。</span><br><span class="line">Model 代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑。</span><br><span class="line">View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来。</span><br><span class="line">ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一</span><br><span class="line">个同步 View 和 Model 的对象，连接 Model 和 View。 在 MVVM 架构下，View 和 Model 之间并没有直接的联系，而是通过 ViewModel</span><br><span class="line">进行交互，Model 和 ViewModel 之间的交互是双向的， 因此 View 数据的变化会</span><br><span class="line">同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。</span><br><span class="line">ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和</span><br><span class="line">Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻</span><br><span class="line">辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维</span><br><span class="line">护完全由 MVVM 来统一管理</span><br></pre></td></tr></table></figure>
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/16/%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="ckrhwctq00003dww20wi5egyi" data-title="面试题" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-test" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/15/test/" class="article-date">
  <time class="dt-published" datetime="2021-07-15T13:01:31.000Z" itemprop="datePublished">2021-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/15/test/">i 坤</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="坤之大一锅炖不下"><a href="#坤之大一锅炖不下" class="headerlink" title="坤之大一锅炖不下"></a>坤之大一锅炖不下</h1><p><img src="https://img0.baidu.com/it/u=1386987570,375612225&fm=26&fmt=auto&gp=0.jpg" alt="avatar"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/15/test/" data-id="ckrhwctpd0002dww26b3ugwtb" data-title="i 坤" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/07/27/js-4/">book</a>
          </li>
        
          <li>
            <a href="/2021/07/19/2021.07.19/">划水计划</a>
          </li>
        
          <li>
            <a href="/2021/07/16/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
          </li>
        
          <li>
            <a href="/2021/07/15/test/">i 坤</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 banji<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>